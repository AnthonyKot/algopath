{
  "dp": [
    {
      "id": "dp-1",
      "title": "Edit Distance (Levenshtein)",
      "difficulty": "Hard",
      "tags": ["dp", "strings", "edit-distance"],
      "description": "Find minimum operations (insert/delete/replace) to convert word1 to word2.",
      "code": "function editDistance(s1, s2) {\n  let [m, n] = [s1.length, s2.length];\n  if (m < n) { [s1, s2] = [s2, s1]; [m, n] = [n, m]; }\n  const dp = Array(n+1).fill(0);\n  for (let j = 0; j <= n; j++) dp[j] = j;\n  for (let i = 1; i <= m; i++) {\n    let prev = i;\n    for (let j = 1; j <= n; j++) {\n      let temp = dp[j];\n      dp[j] = s1[i-1] === s2[j-1] ? dp[j-1] : 1 + Math.min(dp[j-1], prev, dp[j]);\n      prev = temp;\n    }\n  }\n  return dp[n];\n}",
      "complexity": { "time": "O(mn)", "space": "O(min(m,n))" },
      "insight": "Space optimization using rolling array technique"
    },
    {
      "id": "dp-2",
      "title": "Longest Increasing Subsequence",
      "difficulty": "Hard",
      "tags": ["dp", "binary-search", "lis"],
      "description": "Find length of longest strictly increasing subsequence.",
      "code": "function lengthOfLIS(nums) {\n  const n = nums.length;\n  const dp = new Array(n).fill(1);\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1);\n    }\n  }\n  return Math.max(...dp);\n}",
      "complexity": { "time": "O(N^2)", "space": "O(N)" },
      "insight": "Can be optimized to O(N log N) using patience sorting"
    },
    {
      "id": "dp-3",
      "title": "Coin Change (Min Coins)",
      "difficulty": "Hard",
      "tags": ["dp", "knapsack", "greedy"],
      "description": "Find minimum coins to make amount (unlimited supply).",
      "code": "function coinChange(coins, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let coin of coins) {\n    for (let x = coin; x <= amount; x++) {\n      dp[x] = Math.min(dp[x], dp[x - coin] + 1);\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}",
      "complexity": { "time": "O(amount * coins)", "space": "O(amount)" },
      "insight": "Complete knapsack variant - order of coins doesn't matter"
    },
    {
      "id": "dp-4",
      "title": "Burst Balloons",
      "difficulty": "Hard",
      "tags": ["dp", "interval-dp", "optimization"],
      "description": "Maximize coins by bursting balloons with adjacent multiplication.",
      "code": "function maxCoins(nums) {\n  const n = nums.length;\n  nums = [1, ...nums, 1];\n  const dp = Array(n+2).fill().map(() => Array(n+2).fill(0));\n  for (let len = 1; len <= n; len++) {\n    for (let i = 1; i + len - 1 <= n; i++) {\n      const j = i + len - 1;\n      for (let k = i; k <= j; k++) {\n        dp[i][j] = Math.max(dp[i][j], nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j]);\n      }\n    }\n  }\n  return dp[1][n];\n}",
      "complexity": { "time": "O(N^3)", "space": "O(N^2)" },
      "insight": "Interval DP - think about which balloon to burst last"
    },
    {
      "id": "dp-5",
      "title": "Regular Expression Matching",
      "difficulty": "Hard",
      "tags": ["dp", "regex", "strings"],
      "description": "Match string with pattern containing '.' and '*'.",
      "code": "function isMatch(s, p) {\n  const m = s.length, n = p.length;\n  const dp = Array(m+1).fill().map(() => Array(n+1).fill(false));\n  dp[0][0] = true;\n  for (let j = 1; j <= n; j++) if (p[j-1] === '*') dp[0][j] = dp[0][j-2];\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (p[j-1] === '*') {\n        dp[i][j] = dp[i][j-2] || (matches(p[j-2], s[i-1]) && (dp[i-1][j] || dp[i][j-1]));\n      } else {\n        dp[i][j] = matches(p[j-1], s[i-1]) && dp[i-1][j-1];\n      }\n    }\n  }\n  return dp[m][n];\n}\nfunction matches(c1, c2) { return c1 === '.' || c1 === c2; }",
      "complexity": { "time": "O(mn)", "space": "O(mn)" },
      "insight": "Handle '*' as matching 0, 1, or many of preceding character"
    }
  ],
  "graphs": [
    {
      "id": "graphs-1",
      "title": "Word Ladder (Shortest Path)",
      "difficulty": "Hard",
      "tags": ["bfs", "shortest-path", "strings"],
      "description": "Shortest transformation sequence from beginWord to endWord.",
      "code": "function ladderLength(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) return 0;\n  const queue = [[beginWord, 1]];\n  wordSet.delete(beginWord);\n  while (queue.length) {\n    const [word, steps] = queue.shift();\n    if (word === endWord) return steps;\n    for (let i = 0; i < word.length; i++) {\n      for (let c = 0; c < 26; c++) {\n        const newWord = word.slice(0,i) + String.fromCharCode(97+c) + word.slice(i+1);\n        if (wordSet.has(newWord)) {\n          queue.push([newWord, steps+1]);\n          wordSet.delete(newWord);\n        }\n      }\n    }\n  }\n  return 0;\n}",
      "complexity": { "time": "O(N*26*L^2)", "space": "O(N)" },
      "insight": "BFS guarantees shortest path in unweighted graph"
    },
    {
      "id": "graphs-2",
      "title": "Course Schedule II (Topological Sort)",
      "difficulty": "Hard",
      "tags": ["topological-sort", "bfs", "dag"],
      "description": "Return order to take courses with prerequisites.",
      "code": "function findOrder(numCourses, prerequisites) {\n  const graph = Array(numCourses).fill().map(() => []);\n  const indegree = new Array(numCourses).fill(0);\n  for (let [course, pre] of prerequisites) {\n    graph[pre].push(course);\n    indegree[course]++;\n  }\n  const queue = [];\n  for (let i = 0; i < numCourses; i++) if (!indegree[i]) queue.push(i);\n  const res = [];\n  while (queue.length) {\n    const course = queue.shift();\n    res.push(course);\n    for (let nei of graph[course]) {\n      if (--indegree[nei] === 0) queue.push(nei);\n    }\n  }\n  return res.length === numCourses ? res : [];\n}",
      "complexity": { "time": "O(V+E)", "space": "O(V+E)" },
      "insight": "Kahn's BFS for topological sort + cycle detection"
    },
    {
      "id": "graphs-3",
      "title": "Network Delay Time (Dijkstra)",
      "difficulty": "Hard",
      "tags": ["dijkstra", "shortest-path", "priority-queue"],
      "description": "Find maximum time to reach all nodes from source.",
      "code": "function networkDelayTime(times, N, K) {\n  const adj = Array(N+1).fill().map(() => []);\n  for (let [u,v,w] of times) {\n    adj[u].push([v,w]);\n  }\n  const dist = new Array(N+1).fill(Infinity);\n  dist[K] = 0;\n  const pq = [[0, K]];\n  while (pq.length) {\n    const [d, u] = pq.shift();\n    if (d > dist[u]) continue;\n    for (let [v,w] of adj[u]) {\n      if (dist[v] > d + w) {\n        dist[v] = d + w;\n        pq.push([dist[v], v]);\n        pq.sort((a,b) => a[0] - b[0]);\n      }\n    }\n  }\n  const maxTime = Math.max(...dist.slice(1));\n  return maxTime === Infinity ? -1 : maxTime;\n}",
      "complexity": { "time": "O((V+E)logV)", "space": "O(V+E)" },
      "insight": "Dijkstra's algorithm for weighted shortest paths"
    },
    {
      "id": "graphs-4",
      "title": "Min Cost to Connect Points (Prim's MST)",
      "difficulty": "Hard",
      "tags": ["mst", "prim", "greedy"],
      "description": "Connect all points with minimum cost using Manhattan distance.",
      "code": "function minCostConnectPoints(points) {\n  const n = points.length;\n  const visited = new Set();\n  let minCost = 0;\n  const dist = (a,b) => Math.abs(a[0]-b[0]) + Math.abs(a[1]-b[1]);\n  const minDist = new Array(n).fill(Infinity);\n  minDist[0] = 0;\n  for (let i = 0; i < n; i++) {\n    let u = -1;\n    for (let j = 0; j < n; j++) {\n      if (!visited.has(j) && (u === -1 || minDist[j] < minDist[u])) {\n        u = j;\n      }\n    }\n    visited.add(u);\n    minCost += minDist[u];\n    for (let j = 0; j < n; j++) {\n      if (!visited.has(j)) {\n        const d = dist(points[u], points[j]);\n        minDist[j] = Math.min(minDist[j], d);\n      }\n    }\n  }\n  return minCost;\n}",
      "complexity": { "time": "O(N^2)", "space": "O(N)" },
      "insight": "MST connects all vertices with minimum total edge weight"
    },
    {
      "id": "graphs-5",
      "title": "Pacific Atlantic Water Flow",
      "difficulty": "Hard",
      "tags": ["dfs", "multi-source", "bfs"],
      "description": "Find cells where water can flow to both oceans.",
      "code": "function pacificAtlantic(heights) {\n  const m = heights.length, n = heights[0].length;\n  const pacific = new Set(), atlantic = new Set();\n  const dirs = [[0,1],[0,-1],[1,0],[-1,0]];\n  const bfs = (starts, reachable) => {\n    const q = [...starts];\n    for (const [r,c] of starts) reachable.add(`${r},${c}`);\n    while (q.length) {\n      const [r,c] = q.shift();\n      for (const [dr,dc] of dirs) {\n        const nr = r + dr, nc = c + dc;\n        if (nr >= 0 && nr < m && nc >= 0 && nc < n &&\n            !reachable.has(`${nr},${nc}`) &&\n            heights[nr][nc] >= heights[r][c]) {\n          reachable.add(`${nr},${nc}`);\n          q.push([nr,nc]);\n        }\n      }\n    }\n  };\n  const pacificStarts = [];\n  for (let c = 0; c < n; c++) pacificStarts.push([0,c]);\n  for (let r = 0; r < m; r++) pacificStarts.push([r,0]);\n  bfs(pacificStarts, pacific);\n  const atlanticStarts = [];\n  for (let c = 0; c < n; c++) atlanticStarts.push([m-1,c]);\n  for (let r = 0; r < m; r++) atlanticStarts.push([r,n-1]);\n  bfs(atlanticStarts, atlantic);\n  const result = [];\n  for (let r = 0; r < m; r++) {\n    for (let c = 0; c < n; c++) {\n      if (pacific.has(`${r},${c}`) && atlantic.has(`${r},${c}`)) {\n        result.push([r,c]);\n      }\n    }\n  }\n  return result;\n}",
      "complexity": { "time": "O(mn)", "space": "O(mn)" },
      "insight": "Multi-source BFS from boundaries is optimal"
    }
  ],
  "trees": [
    {
      "id": "trees-1",
      "title": "Range Sum Queries (Segment Tree)",
      "difficulty": "Hard",
      "tags": ["segment-tree", "data-structures"],
      "description": "Process queries: update A[pos] = value, sum on interval [l, r].",
      "code": "class SegmentTree {\n  constructor(arr) {\n    this.n = arr.length;\n    this.tree = new Array(4 * this.n);\n    this.build(1, 0, this.n - 1, arr);\n  }\n  build(node, l, r, arr) {\n    if (l === r) this.tree[node] = arr[l];\n    else {\n      const mid = Math.floor((l + r) / 2);\n      this.build(node * 2, l, mid, arr);\n      this.build(node * 2 + 1, mid + 1, r, arr);\n      this.tree[node] = this.tree[node * 2] + this.tree[node * 2 + 1];\n    }\n  }\n  update(pos, val, node = 1, l = 0, r = this.n - 1) {\n    if (l === r) this.tree[node] = val;\n    else {\n      const mid = Math.floor((l + r) / 2);\n      if (pos <= mid) this.update(pos, val, node * 2, l, mid);\n      else this.update(pos, val, node * 2 + 1, mid + 1, r);\n      this.tree[node] = this.tree[node * 2] + this.tree[node * 2 + 1];\n    }\n  }\n  query(qL, qR, node = 1, l = 0, r = this.n - 1) {\n    if (qL > r || qR < l) return 0;\n    if (qL <= l && r <= qR) return this.tree[node];\n    const mid = Math.floor((l + r) / 2);\n    return this.query(qL, qR, node * 2, l, mid) +\n           this.query(qL, qR, node * 2 + 1, mid + 1, r);\n  }\n}",
      "complexity": { "time": "O(N) build, O(log N) per query", "space": "O(4N)" },
      "insight": "Segment tree supports many operations if associative"
    },
    {
      "id": "trees-2",
      "title": "Distance Queries (LCA with Binary Lifting)",
      "difficulty": "Hard",
      "tags": ["lca", "binary-lifting", "trees"],
      "description": "Answer distance queries between nodes using LCA.",
      "code": "class LCA {\n  constructor(n, edges, root = 0) {\n    this.log = Math.ceil(Math.log2(n)) + 1;\n    this.parent = Array.from({length: this.log}, () => new Array(n).fill(-1));\n    this.depth = new Array(n).fill(0);\n    this.adj = Array(n).fill().map(() => []);\n    for (let [u,v] of edges) {\n      this.adj[u].push(v); this.adj[v].push(u);\n    }\n    this.dfs(root, -1);\n    this.preprocess();\n  }\n  dfs(u, p) {\n    this.parent[0][u] = p;\n    for (let v of this.adj[u]) if (v !== p) {\n      this.depth[v] = this.depth[u] + 1;\n      this.dfs(v, u);\n    }\n  }\n  preprocess() {\n    for (let k=1; k<this.log; k++)\n      for (let v=0; v<this.parent[0].length; v++)\n        if (this.parent[k-1][v] !== -1)\n          this.parent[k][v] = this.parent[k-1][this.parent[k-1][v]];\n  }\n  getLCA(u, v) {\n    if (this.depth[u] < this.depth[v]) [u,v] = [v,u];\n    let diff = this.depth[u] - this.depth[v];\n    for (let k=0; k<this.log; k++)\n      if (diff & (1<<k)) u = this.parent[k][u];\n    if (u === v) return u;\n    for (let k=this.log-1; k>=0; k--)\n      if (this.parent[k][u] !== this.parent[k][v]) {\n        u = this.parent[k][u]; v = this.parent[k][v];\n      }\n    return this.parent[0][u];\n  }\n  getDistance(u, v) {\n    const lca = this.getLCA(u, v);\n    return this.depth[u] + this.depth[v] - 2 * this.depth[lca];\n  }\n}",
      "complexity": { "time": "O(N log N) preprocess, O(log N) per query", "space": "O(N log N)" },
      "insight": "Binary lifting generalizes to many tree queries"
    },
    {
      "id": "trees-3",
      "title": "Tree Diameter",
      "difficulty": "Hard",
      "tags": ["tree-dp", "dfs", "diameter"],
      "description": "Find diameter of tree using tree DP.",
      "code": "function treeDiameter(n, edges) {\n  const adj = Array(n).fill().map(() => []);\n  for (let [u,v] of edges) {\n    adj[u].push(v); adj[v].push(u);\n  }\n  let diameter = 0;\n  function dfs(u, p) {\n    let max1 = 0, max2 = 0;\n    for (let v of adj[u]) if (v !== p) {\n      const h = dfs(v, u) + 1;\n      if (h > max1) { max2 = max1; max1 = h; }\n      else if (h > max2) max2 = h;\n    }\n    diameter = Math.max(diameter, max1 + max2);\n    return max1;\n  }\n  dfs(0, -1);\n  return diameter;\n}",
      "complexity": { "time": "O(N)", "space": "O(N)" },
      "insight": "Tree diameter = max of (sum of two longest child depths)"
    },
    {
      "id": "trees-4",
      "title": "Range Add, Range Sum (Lazy Propagation)",
      "difficulty": "Hard",
      "tags": ["segment-tree", "lazy-propagation"],
      "description": "Support range add and range sum queries efficiently.",
      "code": "class LazySegmentTree {\n  constructor(arr) {\n    this.n = arr.length;\n    this.tree = new Array(4 * this.n).fill(0);\n    this.lazy = new Array(4 * this.n).fill(0);\n    this.build(1, 0, this.n - 1, arr);\n  }\n  build(node, l, r, arr) {\n    if (l === r) this.tree[node] = arr[l];\n    else {\n      const mid = Math.floor((l + r) / 2);\n      this.build(node*2, l, mid, arr);\n      this.build(node*2+1, mid+1, r, arr);\n      this.tree[node] = this.tree[node*2] + this.tree[node*2+1];\n    }\n  }\n  apply(node, l, r, val) {\n    this.tree[node] += val * (r - l + 1);\n    this.lazy[node] += val;\n  }\n  push(node, l, r) {\n    if (this.lazy[node] !== 0) {\n      const mid = Math.floor((l + r) / 2);\n      this.apply(node*2, l, mid, this.lazy[node]);\n      this.apply(node*2+1, mid+1, r, this.lazy[node]);\n      this.lazy[node] = 0;\n    }\n  }\n  rangeAdd(qL, qR, val, node=1, l=0, r=this.n-1) {\n    if (qL > r || qR < l) return;\n    if (qL <= l && r <= qR) {\n      this.apply(node, l, r, val);\n      return;\n    }\n    this.push(node, l, r);\n    const mid = Math.floor((l + r) / 2);\n    this.rangeAdd(qL, qR, val, node*2, l, mid);\n    this.rangeAdd(qL, qR, val, node*2+1, mid+1, r);\n    this.tree[node] = this.tree[node*2] + this.tree[node*2+1];\n  }\n  rangeSum(qL, qR, node=1, l=0, r=this.n-1) {\n    if (qL > r || qR < l) return 0;\n    if (qL <= l && r <= qR) return this.tree[node];\n    this.push(node, l, r);\n    const mid = Math.floor((l + r) / 2);\n    return this.rangeSum(qL, qR, node*2, l, mid) +\n           this.rangeSum(qL, qR, node*2+1, mid+1, r);\n  }\n}",
      "complexity": { "time": "O(log N) per operation", "space": "O(N)" },
      "insight": "Lazy propagation amortizes O(log N) for range updates"
    },
    {
      "id": "trees-5",
      "title": "Fenwick Tree (Binary Indexed Tree)",
      "difficulty": "Hard",
      "tags": ["fenwick-tree", "bit", "data-structures"],
      "description": "Efficient range sum queries and point updates using BIT.",
      "code": "class FenwickTree {\n  constructor(n) {\n    this.n = n;\n    this.tree = new Array(n + 1).fill(0);\n  }\n  update(i, delta) {\n    for (++i; i <= this.n; i += i & -i) {\n      this.tree[i] += delta;\n    }\n  }\n  query(i) {\n    let sum = 0;\n    for (++i; i > 0; i -= i & -i) {\n      sum += this.tree[i];\n    }\n    return sum;\n  }\n  rangeQuery(l, r) {\n    return this.query(r) - (l > 0 ? this.query(l - 1) : 0);\n  }\n}",
      "complexity": { "time": "O(log N) per operation", "space": "O(N)" },
      "insight": "BIT uses bit manipulation for efficient tree traversal"
    }
  ],
  "strings": [
    {
      "id": "strings-1",
      "title": "KMP Pattern Matching",
      "difficulty": "Hard",
      "tags": ["kmp", "strings", "pattern-matching"],
      "description": "Find all occurrences of pattern in text using KMP algorithm.",
      "code": "function buildLPS(pattern) {\n  const m = pattern.length;\n  const lps = new Array(m).fill(0);\n  let len = 0;\n  for (let i = 1; i < m; i++) {\n    while (len > 0 && pattern[i] !== pattern[len]) len = lps[len - 1];\n    if (pattern[i] === pattern[len]) len++;\n    lps[i] = len;\n  }\n  return lps;\n}\n\nfunction kmpSearch(text, pattern) {\n  const n = text.length, m = pattern.length;\n  const lps = buildLPS(pattern);\n  const result = [];\n  let i = 0, j = 0;\n  while (i < n) {\n    if (pattern[j] === text[i]) {\n      i++; j++;\n    }\n    if (j === m) {\n      result.push(i - j);\n      j = lps[j - 1];\n    } else if (i < n && pattern[j] !== text[i]) {\n      if (j !== 0) j = lps[j - 1];\n      else i++;\n    }\n  }\n  return result;\n}",
      "complexity": { "time": "O(N+M)", "space": "O(M)" },
      "insight": "KMP's LPS array precomputes pattern structure"
    },
    {
      "id": "strings-2",
      "title": "Rabin-Karp Rolling Hash",
      "difficulty": "Hard",
      "tags": ["hashing", "strings", "pattern-matching"],
      "description": "Find all occurrences using rolling hash with collision handling.",
      "code": "function rabinKarp(text, pattern, base=256, mod=10**9+7) {\n  const n = text.length, m = pattern.length;\n  if (m > n) return [];\n  let hashPattern = 0, hashText = 0;\n  let h = 1;\n  for (let i = 0; i < m; i++) {\n    hashPattern = (hashPattern * base + pattern.charCodeAt(i)) % mod;\n    hashText = (hashText * base + text.charCodeAt(i)) % mod;\n    if (i < m - 1) h = (h * base) % mod;\n  }\n  const result = [];\n  for (let i = 0; i <= n - m; i++) {\n    if (hashPattern === hashText) {\n      if (text.slice(i, i+m) === pattern) result.push(i);\n    }\n    if (i < n - m) {\n      hashText = ((hashText - text.charCodeAt(i) * h) * base + text.charCodeAt(i+m)) % mod;\n      if (hashText < 0) hashText += mod;\n    }\n  }\n  return result;\n}",
      "complexity": { "time": "O(N+M) expected", "space": "O(M)" },
      "insight": "Rolling hash enables O(1) hash update for sliding window"
    },
    {
      "id": "strings-3",
      "title": "Z-Algorithm for Pattern Finding",
      "difficulty": "Hard",
      "tags": ["z-algorithm", "strings", "prefix-function"],
      "description": "Find all occurrences using Z-algorithm.",
      "code": "function computeZ(s) {\n  const n = s.length;\n  const Z = new Array(n).fill(0);\n  Z[0] = 0;\n  let l = 0, r = 0;\n  for (let i = 1; i < n; i++) {\n    if (i <= r) {\n      Z[i] = Math.min(r - i + 1, Z[i - l]);\n    }\n    while (i + Z[i] < n && s[Z[i]] === s[i + Z[i]]) {\n      Z[i]++;\n    }\n    if (i + Z[i] - 1 > r) {\n      l = i;\n      r = i + Z[i] - 1;\n    }\n  }\n  return Z;\n}\n\nfunction zSearch(pattern, text, special = '$') {\n  const combined = pattern + special + text;\n  const Z = computeZ(combined);\n  const m = pattern.length;\n  const result = [];\n  for (let i = m + 1; i < combined.length; i++) {\n    if (Z[i] === m) {\n      result.push(i - m - 1);\n    }\n  }\n  return result;\n}",
      "complexity": { "time": "O(N+M)", "space": "O(N+M)" },
      "insight": "Z-algorithm computes all prefix matches in linear time"
    },
    {
      "id": "strings-4",
      "title": "Suffix Array Construction",
      "difficulty": "Hard",
      "tags": ["suffix-array", "strings", "sorting"],
      "description": "Build suffix array using doubling technique.",
      "code": "function buildSuffixArray(s) {\n  const n = s.length;\n  const sa = Array.from({length: n}, (_, i) => i);\n  const rank = s.split('').map(c => c.charCodeAt(0));\n  const tmp = new Array(n).fill(0);\n  for (let k = 1; k < n; k *= 2) {\n    sa.sort((a, b) => {\n      const ra = rank[a], rb = rank[b];\n      if (ra === rb) {\n        const rak = rank[a+k] || -1, rbk = rank[b+k] || -1;\n        return rak - rbk;\n      }\n      return ra - rb;\n    });\n    tmp[sa[0]] = 0;\n    for (let i = 1; i < n; i++) {\n      const prev = sa[i-1], curr = sa[i];\n      const prevRank = rank[prev] + ',' + (rank[prev+k] || -1);\n      const currRank = rank[curr] + ',' + (rank[curr+k] || -1);\n      tmp[curr] = tmp[prev] + (prevRank < currRank ? 1 : 0);\n    }\n    [rank, tmp] = [tmp, rank];\n  }\n  return sa;\n}",
      "complexity": { "time": "O(N log N)", "space": "O(N)" },
      "insight": "Doubling technique: sort by prefixes of length 1, 2, 4, 8..."
    },
    {
      "id": "strings-5",
      "title": "Manacher's (Longest Palindrome)",
      "difficulty": "Hard",
      "tags": ["manacher", "palindrome", "strings"],
      "description": "Find longest palindromic substring in O(N) time.",
      "code": "function manacher(s) {\n  const t = '#' + s.split('').join('#') + '#';\n  const n = t.length;\n  const P = new Array(n).fill(0);\n  let C = 0, R = 0;\n  for (let i = 1; i < n - 1; i++) {\n    const mirror = 2*C - i;\n    if (i < R) {\n      P[i] = Math.min(R - i, P[mirror]);\n    }\n    while (i + 1 + P[i] < n && i - 1 - P[i] >= 0 &&\n           t[i + 1 + P[i]] === t[i - 1 - P[i]]) {\n      P[i]++;\n    }\n    if (i + P[i] > R) {\n      C = i;\n      R = i + P[i];\n    }\n  }\n  let maxLen = 0, centerIndex = 0;\n  for (let i = 1; i < n - 1; i++) {\n    if (P[i] > maxLen) {\n      maxLen = P[i];\n      centerIndex = i;\n    }\n  }\n  const start = Math.floor((centerIndex - 1 - maxLen) / 2);\n  return s.slice(start, start + maxLen);\n}",
      "complexity": { "time": "O(N)", "space": "O(N)" },
      "insight": "Manacher's uses symmetry to avoid redundant checks"
    }
  ],
  "math": [
    {
      "id": "math-1",
      "title": "Modular Exponentiation",
      "difficulty": "Hard",
      "tags": ["modular", "exponentiation", "fast-power"],
      "description": "Compute a^b mod m efficiently where a, b, m up to 10^18.",
      "code": "function modPow(a, b, mod) {\n  let result = 1;\n  a = a % mod;\n  while (b > 0) {\n    if (b % 2 === 1) {\n      result = (result * a) % mod;\n    }\n    a = (a * a) % mod;\n    b = Math.floor(b / 2);\n  }\n  return result;\n}",
      "complexity": { "time": "O(log b)", "space": "O(1)" },
      "insight": "Binary exponentiation: a^b = product of a^(2^k) where b's bits are set"
    },
    {
      "id": "math-2",
      "title": "Sieve of Eratosthenes",
      "difficulty": "Hard",
      "tags": ["sieve", "primes", "factorization"],
      "description": "Generate all primes up to N and answer prime queries.",
      "code": "function sieve(N) {\n  const isPrime = new Array(N + 1).fill(true);\n  isPrime[0] = isPrime[1] = false;\n  for (let p = 2; p * p <= N; p++) {\n    if (isPrime[p]) {\n      for (let multiple = p * p; multiple <= N; multiple += p) {\n        isPrime[multiple] = false;\n      }\n    }\n  }\n  const primes = [];\n  for (let i = 2; i <= N; i++) {\n    if (isPrime[i]) primes.push(i);\n  }\n  return primes;\n}",
      "complexity": { "time": "O(N log log N)", "space": "O(N)" },
      "insight": "Sieve marks composites in O(N log log N)"
    },
    {
      "id": "math-3",
      "title": "Extended Euclidean Algorithm",
      "difficulty": "Hard",
      "tags": ["gcd", "modular-inverse", "number-theory"],
      "description": "Find integers x, y such that ax + by = gcd(a,b).",
      "code": "function extendedGCD(a, b) {\n  if (b === 0) {\n    return [a, 1, 0];\n  }\n  const [g, x1, y1] = extendedGCD(b, a % b);\n  return [g, y1, x1 - Math.floor(a / b) * y1];\n}\n\nfunction modInverse(a, mod) {\n  const [g, x, y] = extendedGCD(a, mod);\n  if (g !== 1) {\n    return -1;\n  }\n  return ((x % mod) + mod) % mod;\n}",
      "complexity": { "time": "O(log max(a,b))", "space": "O(1)" },
      "insight": "Extended Euclid enables solving ax ≡ b (mod m)"
    },
    {
      "id": "math-4",
      "title": "Chinese Remainder Theorem",
      "difficulty": "Hard",
      "tags": ["crt", "modular", "number-theory"],
      "description": "Find x such that x ≡ ai (mod mi) for coprime moduli.",
      "code": "function solveCRT(a, m) {\n  function merge(a1, m1, a2, m2) {\n    const [g, p, q] = extendedGCD(m1, m2);\n    if ((a2 - a1) % g !== 0) {\n      return [-1, 0];\n    }\n    const lcm = (m1 / g) * m2;\n    const x = (a1 + ((a2 - a1) / g * p % (m2 / g)) * m1) % lcm;\n    return [(x % lcm + lcm) % lcm, lcm];\n  }\n  let [ans, mod] = [a[0], m[0]];\n  for (let i = 1; i < a.length; i++) {\n    [ans, mod] = merge(ans, mod, a[i], m[i]);\n    if (ans === -1) return [-1, 0];\n  }\n  return ans;\n}",
      "complexity": { "time": "O(k log M)", "space": "O(k)" },
      "insight": "CRT has unique solution modulo lcm of all moduli when coprime"
    },
    {
      "id": "math-5",
      "title": "Fast Fourier Transform (FFT)",
      "difficulty": "Hard",
      "tags": ["fft", "polynomial-multiplication", "number-theory"],
      "description": "Multiply two polynomials efficiently using FFT.",
      "code": "function fft(a, invert = false) {\n  const n = a.length;\n  const rev = new Array(n).fill(0);\n  const bits = Math.log2(n);\n  for (let i = 0; i < n; i++) {\n    rev[i] = (rev[i >> 1] >> 1) | (i & 1) << (bits - 1);\n  }\n  for (let i = 0; i < n; i++) {\n    if (i < rev[i]) [a[i], a[rev[i]]] = [a[rev[i]], a[i]];\n  }\n  for (let len = 2; len <= n; len *= 2) {\n    const ang = 2 * Math.PI / len * (invert ? -1 : 1);\n    const wlen = [Math.cos(ang), Math.sin(ang)];\n    for (let i = 0; i < n; i += len) {\n      let u = [1, 0];\n      for (let j = 0; j < len/2; j++) {\n        const v = [a[i+j+len/2][0] * u[0] - a[i+j+len/2][1] * u[1],\n                 a[i+j+len/2][0] * u[1] + a[i+j+len/2][1] * u[0]];\n        [a[i+j], a[i+j+len/2]] = [[a[i+j][0] + v[0], a[i+j][1] + v[1]],\n                                         [a[i+j][0] - v[0], a[i+j][1] - v[1]]];\n        u = [u[0] * wlen[0] - u[1] * wlen[1],\n              u[0] * wlen[1] + u[1] * wlen[0]];\n      }\n    }\n  }\n  if (invert) {\n    for (let i = 0; i < n; i++) {\n      a[i] = [a[i][0] / n, a[i][1] / n];\n    }\n  }\n  return a;\n}",
      "complexity": { "time": "O(N log N)", "space": "O(N)" },
      "insight": "FFT enables convolution in O(N log N) for polynomial multiplication"
    }
  ],
  "geometry": [
    {
      "id": "geometry-1",
      "title": "Point in Polygon Test",
      "difficulty": "Hard",
      "tags": ["geometry", "polygon", "point-in-polygon"],
      "description": "Determine if point P is inside polygon using ray casting.",
      "code": "function pointInPolygon(P, polygon) {\n  const [px, py] = P;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const [xi, yi] = polygon[i];\n    const [xj, yj] = polygon[j];\n    const intersect = ((yi > py) !== (yj > py)) &&\n                     (px < (xj - xi) * (py - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n  return inside;\n}",
      "complexity": { "time": "O(N) per query", "space": "O(1)" },
      "insight": "Ray casting: odd intersections = inside, even = outside"
    },
    {
      "id": "geometry-2",
      "title": "Line Segment Intersection",
      "difficulty": "Hard",
      "tags": ["geometry", "line-intersection", "orientation"],
      "description": "Determine if two line segments intersect using orientation.",
      "code": "function onSegment(p, q, r) {\n  const min_x = Math.min(p[0], r[0]), max_x = Math.max(p[0], r[0]);\n  const min_y = Math.min(p[1], r[1]), max_y = Math.max(p[1], r[1]);\n  return (q[0] >= min_x && q[0] <= max_x && q[1] >= min_y && q[1] <= max_y);\n}\n\nfunction orientation(p, q, r) {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n  if (val > 0) return 1;\n  if (val < 0) return 2;\n  return 0;\n}\n\nfunction segmentsIntersect(p1, p2, p3, p4) {\n  const o1 = orientation(p1, p2, p3);\n  const o2 = orientation(p1, p2, p4);\n  const o3 = orientation(p3, p4, p1);\n  const o4 = orientation(p3, p4, p2);\n  if (o1 !== o2 && o3 !== o4) return true;\n  if (o1 === 0 && onSegment(p1, p3, p2)) return true;\n  if (o2 === 0 && onSegment(p1, p4, p2)) return true;\n  if (o3 === 0 && onSegment(p3, p1, p4)) return true;\n  if (o4 === 0 && onSegment(p3, p2, p4)) return true;\n  return false;\n}",
      "complexity": { "time": "O(1) per query", "space": "O(1)" },
      "insight": "Orientation (cross product) determines clockwise/counter-clockwise turn"
    },
    {
      "id": "geometry-3",
      "title": "Convex Hull (Monotone Chain)",
      "difficulty": "Hard",
      "tags": ["convex-hull", "geometry", "sorting"],
      "description": "Find convex hull using monotone chain algorithm.",
      "code": "function convexHull(points) {\n  points.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);\n  const cross = (o, a, b) => (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n  const buildHull = (pts) => {\n    const hull = [];\n    for (const p of pts) {\n      while (hull.length >= 2 && cross(hull[hull.length-2], hull[hull.length-1], p) <= 0) {\n        hull.pop();\n      }\n      hull.push(p);\n    }\n    return hull;\n  };\n  const lower = buildHull(points);\n  const upper = buildHull([...points].reverse());\n  const hull = [...lower.slice(0, -1), ...upper.slice(0, -1)];\n  return hull;\n}",
      "complexity": { "time": "O(N log N)", "space": "O(N)" },
      "insight": "Monotone chain removes points that create non-left turn"
    },
    {
      "id": "geometry-4",
      "title": "Closest Pair of Points",
      "difficulty": "Hard",
      "tags": ["divide-and-conquer", "geometry", "closest-pair"],
      "description": "Find minimum Euclidean distance between any two points.",
      "code": "function dist(p1, p2) {\n  return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2;\n}\n\nfunction closestPair(points) {\n  const n = points.length;\n  if (n <= 3) return bruteForce(points);\n  points.sort((a, b) => a[0] - b[0]);\n  const mid = Math.floor(n / 2);\n  const midX = points[mid][0];\n  const left = points.slice(0, mid);\n  const right = points.slice(mid);\n  const [dl, pl] = closestPair(left);\n  const [dr, pr] = closestPair(right);\n  const d = Math.min(dl, dr);\n  const strip = points.filter(p => Math.abs(p[0] - midX) < d);\n  strip.sort((a, b) => a[1] - b[1]);\n  for (let i = 0; i < strip.length; i++) {\n    for (let j = i + 1; j < Math.min(i + 7, strip.length); j++) {\n      if (dist(strip[i], strip[j]) < d) {\n        d = dist(strip[i], strip[j]);\n        pl = [strip[i], strip[j]];\n      }\n    }\n  }\n  return d < dl ? [d, [pl[0], pl[1]]] : [dl, pl];\n}\n\nfunction bruteForce(points) {\n  let minDist = Infinity;\n  let pair = [];\n  for (let i = 0; i < points.length; i++) {\n    for (let j = i + 1; j < points.length; j++) {\n      const d = dist(points[i], points[j]);\n      if (d < minDist) {\n        minDist = d;\n        pair = [points[i], points[j]];\n      }\n    }\n  }\n  return [minDist, pair];\n}",
      "complexity": { "time": "O(N log N)", "space": "O(N)" },
      "insight": "Strip contains O(N) points but only O(1) within distance d"
    },
    {
      "id": "geometry-5",
      "title": "Rotating Calipers (Diameter)",
      "difficulty": "Hard",
      "tags": ["rotating-calipers", "convex-hull", "geometry"],
      "description": "Find diameter (maximum distance) of convex polygon.",
      "code": "function rotatingCalipers(hull) {\n  const n = hull.length;\n  if (n === 2) return Math.sqrt(dist(hull[0], hull[1]));\n  let p0 = 0, p1 = 1, maxDist = dist(hull[0], hull[1]);\n  let q0 = 1, q1 = 2;\n  for (let i = 0; i < n; i++) {\n    const d1 = dist(hull[p0], hull[q1]);\n    if (d1 > maxDist) {\n      maxDist = d1;\n    }\n    const d2 = dist(hull[p1], hull[q0]);\n    if (d2 > maxDist) {\n      maxDist = d2;\n    }\n    p1 = (p1 + 1) % n;\n    q1 = (q1 + 1) % n;\n    q0 = (q0 + 1) % n;\n  }\n  return Math.sqrt(maxDist);\n}\n\nfunction dist(a, b) {\n  return (a[0]-b[0])**2 + (a[1]-b[1])**2;\n}",
      "complexity": { "time": "O(N) on convex hull", "space": "O(1)" },
      "insight": "Rotating calipers exploit convex hull property for antipodal pairs"
    }
  ],
  "design": [
    {
      "id": "design-1",
      "title": "LRU Cache",
      "difficulty": "Hard",
      "tags": ["design", "hash-table", "doubly-linked-list"],
      "description": "Design LRU cache with O(1) get and put operations.",
      "code": "class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n    this.head = { key: 0, val: 0 };\n    this.tail = { key: 0, val: 0 };\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n  \n  addNode(node) {\n    node.prev = this.head;\n    node.next = this.head.next;\n    this.head.next.prev = node;\n    this.head.next = node;\n  }\n  \n  removeNode(node) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n  }\n  \n  moveToHead(node) {\n    this.removeNode(node);\n    this.addNode(node);\n  }\n  \n  popTail() {\n    const last = this.tail.prev;\n    this.removeNode(last);\n    return last;\n  }\n  \n  get(key) {\n    const node = this.cache.get(key);\n    if (node) {\n      this.moveToHead(node);\n      return node.val;\n    }\n    return -1;\n  }\n  \n  put(key, value) {\n    const node = this.cache.get(key);\n    if (node) {\n      node.val = value;\n      this.moveToHead(node);\n    } else {\n      const newNode = { key, val: value };\n      if (this.cache.size >= this.capacity) {\n        const tail = this.popTail();\n        this.cache.delete(tail.key);\n      }\n      this.cache.set(key, newNode);\n      this.addNode(newNode);\n    }\n  }\n}",
      "complexity": { "time": "O(1) per operation", "space": "O(capacity)" },
      "insight": "Doubly linked list + hash map enables O(1) access and reordering"
    },
    {
      "id": "design-2",
      "title": "Design Twitter",
      "difficulty": "Hard",
      "tags": ["design", "heap", "merge-k-lists"],
      "description": "Design Twitter with post, follow, unfollow, and getNewsFeed.",
      "code": "class Twitter {\n  constructor() {\n    this.tweets = new Map();\n    this.following = new Map();\n    this.timestamp = 0;\n  }\n  \n  postTweet(userId, tweetId) {\n    if (!this.tweets.has(userId)) this.tweets.set(userId, []);\n    this.tweets.get(userId).push([this.timestamp++, tweetId]);\n  }\n  \n  getNewsFeed(userId) {\n    const feeds = [];\n    const userTweets = this.tweets.get(userId) || [];\n    feeds.push(...userTweets);\n    \n    const followees = this.following.get(userId) || new Set();\n    for (const followeeId of followees) {\n      const followeeTweets = this.tweets.get(followeeId) || [];\n      feeds.push(...followeeTweets);\n    }\n    \n    feeds.sort((a, b) => b[0] - a[0]);\n    return feeds.slice(0, 10).map(tweet => tweet[1]);\n  }\n  \n  follow(followerId, followeeId) {\n    if (followerId === followeeId) return;\n    if (!this.following.has(followerId)) {\n      this.following.set(followerId, new Set());\n    }\n    this.following.get(followerId).add(followeeId);\n  }\n  \n  unfollow(followerId, followeeId) {\n    if (this.following.has(followerId)) {\n      this.following.get(followerId).delete(followeeId);\n    }\n  }\n}",
      "complexity": { "time": "O(N log N) for feed, O(1) others", "space": "O(N)" },
      "insight": "Merge k sorted lists pattern for efficient news feed generation"
    },
    {
      "id": "design-3",
      "title": "Design Search Autocomplete System",
      "difficulty": "Hard",
      "tags": ["design", "trie", "heap"],
      "description": "Design autocomplete system with hot degree ranking.",
      "code": "class AutocompleteSystem {\n  constructor(sentences, times) {\n    this.root = {};\n    this.currentNode = this.root;\n    this.currentSentence = '';\n    \n    for (let i = 0; i < sentences.length; i++) {\n      this.addSentence(sentences[i], times[i]);\n    }\n  }\n  \n  addSentence(sentence, count) {\n    let node = this.root;\n    for (const char of sentence) {\n      if (!node[char]) node[char] = {};\n      node = node[char];\n      if (!node.sentences) node.sentences = new Map();\n      node.sentences.set(sentence, (node.sentences.get(sentence) || 0) + count);\n    }\n  }\n  \n  input(c) {\n    if (c === '#') {\n      this.addSentence(this.currentSentence, 1);\n      this.currentSentence = '';\n      this.currentNode = this.root;\n      return [];\n    }\n    \n    this.currentSentence += c;\n    if (!this.currentNode || !this.currentNode[c]) {\n      this.currentNode = null;\n      return [];\n    }\n    \n    this.currentNode = this.currentNode[c];\n    const candidates = Array.from(this.currentNode.sentences.entries());\n    candidates.sort((a, b) => {\n      if (a[1] !== b[1]) return b[1] - a[1];\n      return a[0].localeCompare(b[0]);\n    });\n    \n    return candidates.slice(0, 3).map(item => item[0]);\n  }\n}",
      "complexity": { "time": "O(p + q log q) per query", "space": "O(ALPHABET_SIZE * N)" },
      "insight": "Trie stores sentences at each prefix node for efficient retrieval"
    },
    {
      "id": "design-4",
      "title": "Design Hit Counter",
      "difficulty": "Hard",
      "tags": ["design", "sliding-window", "circular-buffer"],
      "description": "Design hit counter for last 300 seconds with O(1) operations.",
      "code": "class HitCounter {\n  constructor() {\n    this.times = new Array(300).fill(0);\n    this.hits = new Array(300).fill(0);\n  }\n  \n  hit(timestamp) {\n    const idx = timestamp % 300;\n    if (this.times[idx] !== timestamp) {\n      this.times[idx] = timestamp;\n      this.hits[idx] = 1;\n    } else {\n      this.hits[idx]++;\n    }\n  }\n  \n  getHits(timestamp) {\n    let totalHits = 0;\n    for (let i = 0; i < 300; i++) {\n      if (timestamp - this.times[i] < 300) {\n        totalHits += this.hits[i];\n      }\n    }\n    return totalHits;\n  }\n}",
      "complexity": { "time": "O(1) hit, O(300) getHits", "space": "O(300)" },
      "insight": "Circular buffer with timestamp validation for sliding window"
    },
    {
      "id": "design-5",
      "title": "Design Add and Search Words Data Structure",
      "difficulty": "Hard",
      "tags": ["design", "trie", "dfs", "wildcard"],
      "description": "Support adding words and searching with '.' wildcard.",
      "code": "class WordDictionary {\n  constructor() {\n    this.root = {};\n  }\n  \n  addWord(word) {\n    let node = this.root;\n    for (const char of word) {\n      if (!node[char]) node[char] = {};\n      node = node[char];\n    }\n    node.isEnd = true;\n  }\n  \n  search(word) {\n    return this.dfs(word, 0, this.root);\n  }\n  \n  dfs(word, index, node) {\n    if (index === word.length) {\n      return !!node.isEnd;\n    }\n    \n    const char = word[index];\n    if (char === '.') {\n      for (const key in node) {\n        if (key !== 'isEnd' && this.dfs(word, index + 1, node[key])) {\n          return true;\n        }\n      }\n      return false;\n    } else {\n      if (!node[char]) return false;\n      return this.dfs(word, index + 1, node[char]);\n    }\n  }\n}",
      "complexity": { "time": "O(M) add, O(N * 26^M) search worst case", "space": "O(ALPHABET_SIZE * N * M)" },
      "insight": "DFS with backtracking handles wildcard matching in trie"
    }
  ],
  "optimization": [
    {
      "id": "optimization-1",
      "title": "Sliding Window Maximum",
      "difficulty": "Hard",
      "tags": ["sliding-window", "deque", "monotonic"],
      "description": "Find maximum in each sliding window of size k efficiently.",
      "code": "function maxSlidingWindow(nums, k) {\n  const deque = [];\n  const result = [];\n  \n  for (let i = 0; i < nums.length; i++) {\n    while (deque.length && deque[0] <= i - k) {\n      deque.shift();\n    }\n    \n    while (deque.length && nums[deque[deque.length - 1]] <= nums[i]) {\n      deque.pop();\n    }\n    \n    deque.push(i);\n    \n    if (i >= k - 1) {\n      result.push(nums[deque[0]]);\n    }\n  }\n  \n  return result;\n}",
      "complexity": { "time": "O(N)", "space": "O(k)" },
      "insight": "Monotonic deque maintains candidates in decreasing order"
    },
    {
      "id": "optimization-2",
      "title": "Largest Rectangle in Histogram",
      "difficulty": "Hard",
      "tags": ["stack", "monotonic", "optimization"],
      "description": "Find largest rectangular area in histogram using monotonic stack.",
      "code": "function largestRectangleArea(heights) {\n  const stack = [];\n  let maxArea = 0;\n  heights.push(0);\n  \n  for (let i = 0; i < heights.length; i++) {\n    while (stack.length && heights[i] < heights[stack[stack.length - 1]]) {\n      const h = heights[stack.pop()];\n      const w = stack.length ? i - stack[stack.length - 1] - 1 : i;\n      maxArea = Math.max(maxArea, h * w);\n    }\n    stack.push(i);\n  }\n  \n  return maxArea;\n}",
      "complexity": { "time": "O(N)", "space": "O(N)" },
      "insight": "Monotonic stack finds previous/next smaller elements efficiently"
    },
    {
      "id": "optimization-3",
      "title": "Maximal Rectangle",
      "difficulty": "Hard",
      "tags": ["dp", "stack", "histogram"],
      "description": "Find largest rectangle containing only 1s in binary matrix.",
      "code": "function maximalRectangle(matrix) {\n  if (!matrix.length) return 0;\n  const m = matrix.length, n = matrix[0].length;\n  const heights = new Array(n).fill(0);\n  let maxArea = 0;\n  \n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      heights[j] = matrix[i][j] === '1' ? heights[j] + 1 : 0;\n    }\n    maxArea = Math.max(maxArea, largestRectangleArea([...heights]));\n  }\n  \n  return maxArea;\n}\n\nfunction largestRectangleArea(heights) {\n  const stack = [];\n  let maxArea = 0;\n  heights.push(0);\n  \n  for (let i = 0; i < heights.length; i++) {\n    while (stack.length && heights[i] < heights[stack[stack.length - 1]]) {\n      const h = heights[stack.pop()];\n      const w = stack.length ? i - stack[stack.length - 1] - 1 : i;\n      maxArea = Math.max(maxArea, h * w);\n    }\n    stack.push(i);\n  }\n  \n  return maxArea;\n}",
      "complexity": { "time": "O(mn)", "space": "O(n)" },
      "insight": "Reduce 2D problem to multiple 1D histogram problems"
    },
    {
      "id": "optimization-4",
      "title": "Minimum Window Substring",
      "difficulty": "Hard",
      "tags": ["sliding-window", "two-pointers", "hash-map"],
      "description": "Find minimum window in s that contains all characters of t.",
      "code": "function minWindow(s, t) {\n  const need = new Map();\n  for (const char of t) {\n    need.set(char, (need.get(char) || 0) + 1);\n  }\n  \n  let left = 0, right = 0;\n  let valid = 0;\n  let start = 0, len = Infinity;\n  const window = new Map();\n  \n  while (right < s.length) {\n    const c = s[right];\n    right++;\n    \n    if (need.has(c)) {\n      window.set(c, (window.get(c) || 0) + 1);\n      if (window.get(c) === need.get(c)) {\n        valid++;\n      }\n    }\n    \n    while (valid === need.size) {\n      if (right - left < len) {\n        start = left;\n        len = right - left;\n      }\n      \n      const d = s[left];\n      left++;\n      \n      if (need.has(d)) {\n        if (window.get(d) === need.get(d)) {\n          valid--;\n        }\n        window.set(d, window.get(d) - 1);\n      }\n    }\n  }\n  \n  return len === Infinity ? '' : s.substr(start, len);\n}",
      "complexity": { "time": "O(|s| + |t|)", "space": "O(|s| + |t|)" },
      "insight": "Sliding window with hash maps tracks character frequencies"
    },
    {
      "id": "optimization-5",
      "title": "Trapping Rain Water",
      "difficulty": "Hard",
      "tags": ["two-pointers", "optimization", "greedy"],
      "description": "Calculate trapped rainwater using two pointers optimization.",
      "code": "function trap(height) {\n  if (height.length < 3) return 0;\n  \n  let left = 0, right = height.length - 1;\n  let leftMax = 0, rightMax = 0;\n  let water = 0;\n  \n  while (left < right) {\n    if (height[left] < height[right]) {\n      if (height[left] >= leftMax) {\n        leftMax = height[left];\n      } else {\n        water += leftMax - height[left];\n      }\n      left++;\n    } else {\n      if (height[right] >= rightMax) {\n        rightMax = height[right];\n      } else {\n        water += rightMax - height[right];\n      }\n      right--;\n    }\n  }\n  \n  return water;\n}",
      "complexity": { "time": "O(N)", "space": "O(1)" },
      "insight": "Two pointers eliminate need for preprocessing left/right max arrays"
    }
  ]
}