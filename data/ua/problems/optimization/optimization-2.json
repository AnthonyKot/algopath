{
    "id": "optimization-2",
    "title": "Найбільший Прямокутник у Гістограмі",
    "difficulty": "Важкий",
    "leetcode_url": "https://leetcode.com/problems/largest-rectangle-in-histogram/",
    "related": [
        {
            "id": "optimization-3",
            "title": "Maximal Rectangle",
            "category": "optimization"
        },
        {
            "id": "optimization-5",
            "title": "Trapping Rain Water",
            "category": "optimization"
        }
    ],
    "tags": [
        "stack",
        "monotonic",
        "optimization"
    ],
    "follow_up": {
        "scenario": "Гістограма розподілена між 1000 машинами (MapReduce).",
        "trade_off": "Неможливо просто підсумувати локальні результати. Найбільший прямокутник може перетинати межі машин.",
        "strategy": "Кожна машина обчислює локальну максимальну площу ТА профіль 'горизонту' (ліві/праві зростаючі підпослідовності). Ред'юсер об'єднує ці 1000 стиснутих профілів.",
        "answering_guide": "Це класичний 'Розділяй і Володарюй' у масштабі. Поясніть, що результат - ЦЕ НЕ просто максимум локальних результатів; <strong>об'єднання меж</strong> є ключовим."
    },
    "content": {
        "problem_statement": "Дано масив цілих чисел `heights`, що представляє гістограму. Знайдіть площу найбільшого прямокутника, який можна побудувати в гістограмі.",
        "explanation": {
            "understanding_the_problem": "Для кожного стовпчика ми хочемо знати: як далеко вліво і вправо ми можемо розширити прямокутник з висотою цього стовпчика? <br> Межа - це перший стовпчик, **менший** за поточний.",
            "brute_force": "Для кожного стовпчика `i`, розширюватись вліво та вправо поки висота >= `heights[i]`.<br>Часова складність: `O(N^2)`. Занадто повільно.",
            "optimized_approach": "Нам потрібно ефективно знаходити *наступний менший елемент* та *попередній менший елемент*.<br>Використовуємо **Монотонно Зростаючий Стек**. Стек зберігає індекси стовпчиків зі зростаючою висотою. <br>Коли ми зустрічаємо стовпчик, менший за вершину стека, це означає, що ми знайшли **праву межу** для стовпчика на вершині стека. Ліва межа — це елемент, що знаходиться під ним у стеку.",
            "algorithm_steps": "1. Ініціювати стек. Додати 0 в кінець масиву `heights`.\n2. Ітерувати по `heights`.\n3. Поки `heights[i] < heights[stack.top()]`: обчислити площу для `stack.pop()`\n4. `stack.push(i)`."
        },
        "quizzes": [
            {
                "question": "Що зберігає стек?",
                "options": [
                    "Висоти",
                    "Індекси",
                    "Площі",
                    "Обернені Висоти"
                ],
                "correct": 1
            },
            {
                "question": "Яку властивість висот підтримує стек?",
                "options": [
                    "Спадання",
                    "Зростання",
                    "Випадковість",
                    "Константність"
                ],
                "correct": 1
            },
            {
                "question": "Що запускає обчислення?",
                "options": [
                    "Додавання вищого стовпчика",
                    "Додавання меншого стовпчика",
                    "Порожній стек",
                    "Кожен крок"
                ],
                "correct": 1
            },
            {
                "question": "Як обчислюється ширина?",
                "options": [
                    "right - left",
                    "right - left - 1",
                    "right + left",
                    "constant"
                ],
                "correct": 1
            },
            {
                "question": "Навіщо додавати 0 в кінці?",
                "options": [
                    "Щоб уникнути переповнення",
                    "Щоб очистити стек",
                    "Щоб почати індекс з 1",
                    "Заповнення"
                ],
                "correct": 1
            }
        ]
    },
    "complexity": {
        "time": "O(N)",
        "space": "O(N)",
        "explanation_time": "Кожен елемент додається і видаляється зі стеку лише один раз.",
        "explanation_space": "Стек може зберігати до N елементів у найгіршому випадку (зростаюча послідовність)."
    },
    "code": {
        "javascript": {
            "solution": "function largestRectangleArea(heights) {\n  const stack = [];\n  let maxArea = 0;\n  heights.push(0); // Dummy bar to flush stack at end\n\n  for (let i = 0; i < heights.length; i++) {\n    while (stack.length && heights[stack[stack.length - 1]] > heights[i]) {\n      const h = heights[stack.pop()];\n      const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n      maxArea = Math.max(maxArea, h * width);\n    }\n    stack.push(i);\n  }\n\n  return maxArea;\n}",
            "annotations": [
                {
                    "lines": [
                        4
                    ],
                    "text": "Вартовий: Додайте висоту 0 в кінці, щоб змусити обробити решту стовпців у стеку."
                },
                {
                    "lines": [
                        7
                    ],
                    "text": "Умова: Поточний стовпець коротший за верхівку стека? Верхівка стека — це 'висота' прямокутника."
                },
                {
                    "lines": [
                        9
                    ],
                    "text": "Обчислення ширини: i — це права межа (виключно), нова верхівка стека — ліва межа (виключно)."
                },
                {
                    "lines": [
                        10
                    ],
                    "text": "Площа: висота * ширина. Оновіть maxArea, якщо цей прямокутник більший."
                }
            ]
        }
    }
}