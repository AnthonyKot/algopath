{
    "id": "optimization-1",
    "title": "Максимум у Ковзному Вікні",
    "difficulty": "Hard",
    "leetcode_url": "https://leetcode.com/problems/sliding-window-maximum/",
    "related": [
        {
            "id": "optimization-2",
            "title": "Largest Rectangle in Histogram",
            "category": "optimization"
        },
        {
            "id": "design-4",
            "title": "Design Hit Counter",
            "category": "design"
        }
    ],
    "tags": [
        "sliding-window",
        "deque",
        "monotonic"
    ],
    "follow_up": {
        "scenario": "Вхідний потік нескінченний та високошвидкісний. K = 1 Мільйон.",
        "trade_off": "Зберігання 1М індексів у стандартному списку спричиняє тиск на GC та промахи кешу.",
        "strategy": "Використовуйте кільцевий буфер фіксованого розміру для Deque. Оптимізуйте пам'ять (Int32Array), щоб уникнути pointer chasing.",
        "answering_guide": "Вийдіть за межі алгоритму до <strong>'Локальності Пам'яті'</strong> та <strong>'Тиску на GC'</strong>. Згадка про <strong>'Типізовані Масиви'</strong> або <strong>'Кільцеві Буфери'</strong> демонструє системні знання."
    },
    "content": {
        "problem_statement": "Вам дано масив цілих чисел `nums`, є ковзне вікно розміру `k`, яке рухається з самого лівого краю масиву в самий правий. Ви можете бачити лише `k` чисел у вікні. Кожного разу ковзне вікно зсувається вправо на одну позицію.\n\nПоверніть *максимум ковзного вікна*.\n\n**Приклад 1:**\n```\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]\nExplanation: \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```",
        "explanation": {
            "understanding_the_problem": "Нам потрібно знайти максимальний елемент у вікні фіксованого розміру, яке ковзає по масиву. Для кожної позиції вікна створюється новий максимум.",
            "brute_force": "Для кожного з `N-k+1` можливих вікон ми могли б ітерувати через `k` елементів у ньому, щоб знайти максимум. Це матиме часову складність O(N*k), що занадто повільно, якщо N і k великі.",
            "bottleneck": "Повторне сканування `k` елементів для кожного вікна є дуже надлишковим. Максимум поточного вікна, ймовірно, буде максимумом наступного вікна, але ми не використовуємо цю інформацію.",
            "optimized_approach": "Оптимальне рішення O(N) використовує **монотонний deque** (двостороння черга). Цей deque буде зберігати *індекси* елементів з масиву, і він буде підтримуватися в строго спадному порядку на основі значень за цими індексами.\n\nПередня частина deque завжди буде містити індекс максимального елемента в цьому вікні. Коли ми зсуваємо вікно, ми додаємо нові елементи в кінець deque, але перед додаванням ми видаляємо будь-які елементи з кінця, які менші за новий елемент, таким чином зберігаючи монотонну властивість.",
            "algorithm_steps": "1. Ініціалізувати порожній deque та масив результатів.\n2. Ітерувати через `nums` зліва направо з індексом `i`:\n    a. **Очищення спереду:** Видаліть будь-які індекси з *переду* deque, які більше не знаходяться в поточному вікні (тобто index `<= i - k`).\n    b. **Очищення ззаду:** Поки deque не порожній і значення в *кінці* deque менше ніж `nums[i]`, видаляйте з кінця. Це ключовий крок для підтримки спадної монотонної властивості.\n    c. **Додати індекс:** Додайте поточний індекс `i` в кінець.\n    d. **Зберегти результат:** Якщо наше вікно заповнене (`i >= k - 1`), максимум для цього вікна - це значення за індексом у *переді* deque. Додайте це до результатів."
        },
        "quizzes": [
            {
                "question": "Яку властивість підтримує deque?",
                "options": [
                    "Зростаючі значення",
                    "Спадаючі значення",
                    "Відсортовані індекси",
                    "Випадковий порядок"
                ],
                "correct": 1
            },
            {
                "question": "Чому ми зберігаємо індекси замість значень?",
                "options": [
                    "Щоб заощадити пам'ять",
                    "Щоб перевіряти межі вікна (термін дії)",
                    "Швидше порівняння",
                    "Вимагається масивом"
                ],
                "correct": 1
            },
            {
                "question": "Коли ми видаляємо з кінця (back)?",
                "options": [
                    "Коли вікно зсувається",
                    "Коли новий елемент більший за останній",
                    "Коли deque заповнений",
                    "Ніколи"
                ],
                "correct": 1
            },
            {
                "question": "Коли ми видаляємо з початку (front)?",
                "options": [
                    "Коли елемент занадто малий",
                    "Коли елемент виходить за межі вікна",
                    "При пошуку максимуму",
                    "Випадково"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність?",
                "options": [
                    "O(N*k)",
                    "O(N log k)",
                    "O(N)",
                    "O(N²)",
                    "O(N)"
                ],
                "correct": 0
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function maxSlidingWindow(nums, k) {\n  const deque = [];\n  const result = [];\n  \n  for (let i = 0; i < nums.length; i++) {\n    while (deque.length && deque[0] <= i - k) {\n      deque.shift();\n    }\n    \n    while (deque.length && nums[deque[deque.length - 1]] <= nums[i]) {\n      deque.pop();\n    }\n    \n    deque.push(i);\n    \n    if (i >= k - 1) {\n      result.push(nums[deque[0]]);\n    }\n  }\n  \n  return result;\n}",
            "annotations": [
                {
                    "lines": [
                        2
                    ],
                    "text": "Deque зберігає індекси, а не значення. Він підтримує спадний порядок значень."
                },
                {
                    "lines": [
                        6
                    ],
                    "text": "Очищення спереду: Видаліть індекси, які випали з поточного вікна (i - k)."
                },
                {
                    "lines": [
                        10
                    ],
                    "text": "Очищення ззаду: Видаліть індекси, значення яких менші за current num. Вони більше не можуть бути максимумом."
                },
                {
                    "lines": [
                        16
                    ],
                    "text": "Результат: Передній елемент deque завжди містить індекс максимального значення для поточного вікна."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N)",
        "space": "O(k)",
        "explanation_time": "Кожен індекс з вхідного масиву додається і видаляється з deque не більше одного разу. Це дає амортизовану вартість O(1) для кожного з N елементів, що призводить до загальної лінійної часової складності.",
        "explanation_space": "Deque буде зберігати щонайбільше `k` індексів, тому просторова складність становить O(k)."
    }
}