{
    "id": "math-4",
    "title": "Китайська Теорема про Остачі",
    "difficulty": "Medium",
    "related": [
        {
            "id": "math-3",
            "title": "Extended Euclidean Algorithm",
            "category": "math"
        },
        {
            "id": "math-5",
            "title": "FFT",
            "category": "math"
        }
    ],
    "tags": [
        "crt",
        "modular",
        "number-theory"
    ],
    "content": {
        "problem_statement": "Розв'яжіть систему одночасних конгруенцій. Дано `x ≡ a_i (mod m_i)` для `i = 1...k`, знайти `x`. Стандартна версія припускає, що всі `m_i` є попарно взаємно простими.",
        "explanation": {
            "understanding_the_problem": "Ми шукаємо єдине число `x`, яке залишає певну остачу `a_i` при діленні на певне число `m_i` для цілого набору пар `(a_i, m_i)`.",
            "brute_force": "Можна почати з `a_1` і продовжувати додавати `m_1` (`x = a_1, a_1+m_1, a_1+2m_1, ...`) і для кожного отриманого числа перевіряти, чи задовольняє воно всі інші конгруенції. Це надзвичайно повільно.",
            "bottleneck": "Простір пошуку величезний. Нам потрібен конструктивний метод для побудови рішення.",
            "optimized_approach": "Теорема гарантує унікальне рішення для `x` за модулем `M` (де `M` — добуток усіх `m_i`). Практичний спосіб знайти це рішення — розв'язувати систему по одній конгруенції за раз і об'єднувати результати.\n\nПочніть з першої конгруенції, `x ≡ a_1 (mod m_1)`. Це говорить нам, що `x` має бути у формі `a_1 + k*m_1`. Ми підставляємо це у другу конгруенцію і розв'язуємо для `k`. Це дає нам нову, об'єднану конгруенцію `x ≡ a_new (mod m_1*m_2)`. Ми можемо повторювати цей процес, об'єднуючи по одній конгруенції за раз, поки не отримаємо остаточну відповідь.",
            "algorithm_steps": "1.  Почати з першого рішення `ans = a_1`, `mod = m_1`.\n2.  Для кожної наступної конгруенції `x ≡ a_i (mod m_i)`:\n    a. Нам потрібно знайти `k`, таке що `ans + k*mod ≡ a_i (mod m_i)`.\n    b. Це можна вирішити для `k`, використовуючи модульне обернене, яке ми знаходимо за допомогою розширеного алгоритму Евкліда.\n    c. Як тільки `k` знайдено, оновити відповідь: `ans = ans + k*mod`.\n    d. Оновити об'єднаний модуль: `mod = mod * m_i`.\n3. Повторити для всіх конгруенцій."
        },
        "quizzes": [
            {
                "question": "Що розв'язує КТП (CRT)?",
                "options": [
                    "Поліноміальні рівняння",
                    "Систему конгруенцій",
                    "Розклад на прості множники",
                    "Матричні рівняння"
                ],
                "correct": 1
            },
            {
                "question": "Яка умова необхідна для стандартної КТП?",
                "options": [
                    "Всі m_i рівні",
                    "Всі m_i попарно взаємно прості",
                    "Всі a_i прості",
                    "m_i впорядковані"
                ],
                "correct": 1
            },
            {
                "question": "Як працює ітеративний підхід?",
                "options": [
                    "Розв'язує все одразу",
                    "Об'єднує дві конгруенції за раз",
                    "Бінарний пошук",
                    "Випадкова вибірка"
                ],
                "correct": 1
            },
            {
                "question": "Який алгоритм використовується на етапі об'єднання?",
                "options": [
                    "Решето",
                    "Розширений Евклід",
                    "FFT",
                    "Бінарне піднесення до степеня"
                ],
                "correct": 1
            },
            {
                "question": "Чи є рішення унікальним?",
                "options": [
                    "Ні",
                    "Так, за модулем добутку всіх m_i",
                    "Тільки для простих чисел",
                    "Залежить від a_i"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function solveCRT(a, m) {\n  function merge(a1, m1, a2, m2) {\n    const [g, p, q] = extendedGCD(m1, m2);\n    if ((a2 - a1) % g !== 0) {\n      return [-1, 0];\n    }\n    const lcm = (m1 / g) * m2;\n    const x = (a1 + ((a2 - a1) / g * p % (m2 / g)) * m1) % lcm;\n    return [(x % lcm + lcm) % lcm, lcm];\n  }\n  let [ans, mod] = [a[0], m[0]];\n  for (let i = 1; i < a.length; i++) {\n    [ans, mod] = merge(ans, mod, a[i], m[i]);\n    if (ans === -1) return [-1, 0];\n  }\n  return ans;\n}",
            "annotations": [
                {
                    "lines": [
                        3
                    ],
                    "text": "Модульне Обернене: Розв'язати для 'p' у рівнянні Безу відносно модулів."
                },
                {
                    "lines": [
                        7
                    ],
                    "text": "Об'єднання: Об'єднати дві конгруенції в одну. Нове x задовольняє обидві."
                },
                {
                    "lines": [
                        12
                    ],
                    "text": "Ітеративне Об'єднання: Об'єднати поточну відповідь з наступною конгруенцією."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(k * log M)",
        "space": "O(k)",
        "explanation_time": "Де `k` — кількість рівнянь, а `M` — добуток модулів. Кожен з `k-1` кроків об'єднання включає виклик розширеного алгоритму Евкліда, який є логарифмічним відносно розміру модулів.",
        "explanation_space": "Вхідні дані зберігаються в масивах розміром k."
    }
}