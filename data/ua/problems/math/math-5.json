{
    "id": "math-5",
    "title": "Швидке Перетворення Фур'є (FFT)",
    "difficulty": "Medium",
    "related": [
        {
            "id": "math-4",
            "title": "Chinese Remainder Theorem",
            "category": "math"
        },
        {
            "id": "math-1",
            "title": "Modular Exponentiation",
            "category": "math"
        }
    ],
    "tags": [
        "fft",
        "polynomial-multiplication",
        "number-theory"
    ],
    "content": {
        "problem_statement": "Ефективно перемножити два многочлени степеня N.",
        "explanation": {
            "understanding_the_problem": "Множення двох многочленів A(x) і B(x) степеня N за допомогою стандартного методу 'множення у стовпчик' займає O(N²) часу. FFT — це дуже просунутий алгоритм, який може виконати це за час O(N log N).",
            "brute_force": "Метод шкільного підручника O(N²) є наївним підходом.",
            "bottleneck": "Складність O(N²) занадто повільна для задач, що включають множення великих многочленів, таких як знаходження всіх можливих сум двох великих наборів чисел (що можна змоделювати як множення многочленів).",
            "optimized_approach": "Ключова ідея FFT полягає у зміні представлення многочленів. Многочлен може бути представлений своїми коефіцієнтами або своїми значеннями у наборі точок (точково-значеннєва форма). Множення двох многочленів у точково-значеннєвій формі є тривіальним: ви просто перемножуєте їх значення в кожній точці, що займає O(N) часу.\n\n1. **Обчислення (Evaluation):** Алгоритм FFT обчислює многочлен у певному наборі з `2N` точок (комплексні 'корені з одиниці') за час O(N log N).\n2. **Поточкове Множення:** Помножити значення в кожній точці. O(N).\n3. **Інтерполяція:** Алгоритм оберненого FFT перетворює отримані точкові значення назад у представлення коефіцієнтів кінцевого многочлена, також за час O(N log N).",
            "algorithm_steps": "1.  Дано два многочлени A(x) і B(x), перетворити їх у точково-значеннєву форму, застосувавши FFT. Це рекурсивний алгоритм типу 'розділяй і володарюй'.\n2.  Виконати поточкове множення результатів.\n3.  Застосувати Обернене FFT до нових пар точкових значень, щоб отримати коефіцієнти результуючого многочлена C(x)."
        },
        "quizzes": [
            {
                "question": "Яку задачу ефективно вирішує FFT?",
                "options": [
                    "Сортування",
                    "Множення многочленів",
                    "Обхід графа",
                    "Зіставлення рядків"
                ],
                "correct": 1
            },
            {
                "question": "У чому ключова ідея FFT?",
                "options": [
                    "Сортувати коефіцієнти",
                    "Перетворити у точково-значеннєву форму",
                    "Використовувати хешування",
                    "Бінарний пошук"
                ],
                "correct": 1
            },
            {
                "question": "Що таке 'корені з одиниці'?",
                "options": [
                    "Прості числа",
                    "Комплексні числа, де z^n = 1",
                    "Квадратні корені",
                    "Числа Фібоначчі"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність FFT?",
                "options": [
                    "O(N²)",
                    "O(N)",
                    "O(N log N)",
                    "O(N³)"
                ],
                "correct": 2
            },
            {
                "question": "Чим відрізняється обернене FFT?",
                "options": [
                    "Інший алгоритм",
                    "Інвертувати кут і поділити на N",
                    "Тільки для цілих чисел",
                    "Використовує рекурсію"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function fft(a, invert = false) {\n  const n = a.length;\n  const rev = new Array(n).fill(0);\n  const bits = Math.log2(n);\n  for (let i = 0; i < n; i++) {\n    rev[i] = (rev[i >> 1] >> 1) | (i & 1) << (bits - 1);\n  }\n  for (let i = 0; i < n; i++) {\n    if (i < rev[i]) [a[i], a[rev[i]]] = [a[rev[i]], a[i]];\n  }\n  for (let len = 2; len <= n; len *= 2) {\n    const ang = 2 * Math.PI / len * (invert ? -1 : 1);\n    const wlen = [Math.cos(ang), Math.sin(ang)];\n    for (let i = 0; i < n; i += len) {\n      let u = [1, 0];\n      for (let j = 0; j < len/2; j++) {\n        const v = [a[i+j+len/2][0] * u[0] - a[i+j+len/2][1] * u[1],\n                 a[i+j+len/2][0] * u[1] + a[i+j+len/2][1] * u[0]];\n        [a[i+j], a[i+j+len/2]] = [[a[i+j][0] + v[0], a[i+j][1] + v[1]],\n                                         [a[i+j][0] - v[0], a[i+j][1] - v[1]]];\n        u = [u[0] * wlen[0] - u[1] * wlen[1],\n              u[0] * wlen[1] + u[1] * wlen[0]];\n      }\n    }\n  }\n  if (invert) {\n    for (let i = 0; i < n; i++) {\n      a[i] = [a[i][0] / n, a[i][1] / n];\n    }\n  }\n  return a;\n}",
            "annotations": [
                {
                    "lines": [
                        5
                    ],
                    "text": "Перестановка з Реверсуванням Бітів: Перевпорядкувати масив так, щоб рекурсію можна було виконати ітеративно."
                },
                {
                    "lines": [
                        10
                    ],
                    "text": "Корені з Одиниці: Обчислити комплексний кут для поточного рівня рекурсії."
                },
                {
                    "lines": [
                        15,
                        16
                    ],
                    "text": "Метелик: Оновити пари на місці, використовуючи 'поворотний множник' wlen."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N log N)",
        "space": "O(N)",
        "explanation_time": "Алгоритм FFT — це алгоритм типу 'розділяй і володарюй'. Рекурентне співвідношення T(N) = 2*T(N/2) + O(N), що дає розв'язок O(N log N).",
        "explanation_space": "Алгоритм вимагає місця для зберігання вхідних масивів і різних проміжних значень, пропорційно степеню многочленів, що призводить до простору O(N)."
    }
}