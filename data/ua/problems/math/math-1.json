{
    "id": "math-1",
    "title": "Модульна Експоненціація",
    "difficulty": "Medium",
    "leetcode_url": "https://leetcode.com/problems/powx-n/",
    "related": [
        {
            "id": "math-2",
            "title": "Sieve of Eratosthenes",
            "category": "math"
        },
        {
            "id": "math-3",
            "title": "Extended Euclidean Algorithm",
            "category": "math"
        }
    ],
    "tags": [
        "modular",
        "exponentiation",
        "fast-power"
    ],
    "content": {
        "problem_statement": "Ефективно обчисліть (a^b) mod m, де a, b та m можуть бути великими числами.",
        "explanation": {
            "understanding_the_problem": "Нам потрібно знайти остачу від ділення числа `a`, піднесеного до великого степеня `b`, на `m`. Стандартний цикл або `Math.pow` будуть занадто повільними, якщо `b` велике, а також призведуть до проблем з переповненням через величезні проміжні числа.",
            "brute_force": "Наївний підхід полягає у використанні циклу для множення `a` на себе `b` разів, беручи модуль на кожному кроці, щоб запобігти переповненню. Це має часову складність O(b), що неприпустимо для великих `b` (наприклад, 10^18).",
            "bottleneck": "Складність O(b) є вузьким місцем. Нам потрібен спосіб обчислювати степені набагато швидше.",
            "optimized_approach": "Рішенням є **Бінарне Піднесення до Степеня** (також відоме як піднесення до степеня квадратурами). Цей алгоритм O(log b) ґрунтується на принципі, що будь-який показник степеня `b` можна записати як суму степенів двійки. Наприклад, `a^13 = a^(8+4+1) = a^8 * a^4 * a^1`.\n\nМи можемо знайти члени `a^1, a^2, a^4, a^8, ...`, послідовно підносячи `a` до квадрата. Потім ми множимо лише ті члени, які відповідають встановленим бітам у двійковому представленні `b`.",
            "algorithm_steps": "1. Ініціалізувати `result = 1`.\n2. Зменшити `a = a % m`.\n3. Цикл, поки `b > 0`:\n    a. Якщо `b` непарне (тобто останній біт дорівнює 1), це означає, що поточний степінь `a` є частиною нашого добутку. Отже, помножити `result = (result * a) % m`.\n    b. У будь-якому випадку, нам потрібен наступний степінь `a`, тому ми підносимо його до квадрата: `a = (a * a) % m`.\n    c. Зсунути `b` праворуч на одиницю (`b = floor(b / 2)`), фактично переходячи до наступного біта."
        },
        "quizzes": [
            {
                "question": "Яка техніка дає O(log b) для a^b?",
                "options": [
                    "Лінійний цикл",
                    "Бінарне піднесення до степеня",
                    "Тільки рекурсія",
                    "Множення матриць"
                ],
                "correct": 1
            },
            {
                "question": "Навіщо підносити основу до квадрата на кожній ітерації?",
                "options": [
                    "Рандомізація",
                    "Перехід до наступного степеня двійки",
                    "Зменшення пам'яті",
                    "Обробка від'ємних чисел"
                ],
                "correct": 1
            },
            {
                "question": "Коли ми множимо результат на поточну основу?",
                "options": [
                    "Завжди",
                    "Коли b непарне (біт дорівнює 1)",
                    "Коли b парне",
                    "Ніколи"
                ],
                "correct": 1
            },
            {
                "question": "Навіщо брати модуль на кожному кроці?",
                "options": [
                    "Швидше",
                    "Запобігання переповненню",
                    "Вимагається алгоритмом",
                    "Покращує точність"
                ],
                "correct": 1
            },
            {
                "question": "Яка просторова складність?",
                "options": [
                    "O(N)",
                    "O(log b)",
                    "O(1)",
                    "O(b)"
                ],
                "correct": 2
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function modPow(a, b, mod) {\n  let result = 1;\n  a = a % mod;\n  while (b > 0) {\n    if (b % 2 === 1) {\n      result = (result * a) % mod;\n    }\n    a = (a * a) % mod;\n    b = Math.floor(b / 2);\n  }\n  return result;\n}",
            "annotations": [
                {
                    "lines": [
                        2,
                        3
                    ],
                    "text": "Операція Модуля: Зменшити 'a' негайно. 'result' ініціалізується як 1 (одиниця)."
                },
                {
                    "lines": [
                        5
                    ],
                    "text": "Встановлений Біт: Якщо поточний біт 1 (b непарне), помножити поточний степінь 'a' на результат."
                },
                {
                    "lines": [
                        8
                    ],
                    "text": "Квадратура: Перехід до наступного степеня двійки (a^2, a^4, і т.д.) шляхом піднесення основи до квадрата."
                },
                {
                    "lines": [
                        9
                    ],
                    "text": "Зсув: Перехід до наступного біта показника степеня (ділення на 2)."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(log b)",
        "space": "O(1)",
        "explanation_time": "Цикл виконується стільки разів, скільки бітів у показнику `b`, що становить приблизно log₂(b). Кожен крок всередині циклу є операцією за незмінний час.",
        "explanation_space": "Алгоритм використовує лише кілька змінних для зберігання свого стану, вимагаючи постійного простору O(1)."
    }
}