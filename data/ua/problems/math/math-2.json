{
    "id": "math-2",
    "title": "Решето Ератосфена",
    "difficulty": "Medium",
    "leetcode_url": "https://leetcode.com/problems/count-primes/",
    "related": [
        {
            "id": "math-1",
            "title": "Modular Exponentiation",
            "category": "math"
        },
        {
            "id": "math-3",
            "title": "Extended Euclidean Algorithm",
            "category": "math"
        }
    ],
    "tags": [
        "sieve",
        "primes",
        "factorization"
    ],
    "content": {
        "problem_statement": "Дано ціле число N, знайти всі прості числа до N.",
        "explanation": {
            "understanding_the_problem": "Нам потрібен ефективний спосіб генерації списку всіх простих чисел до заданої межі N.",
            "brute_force": "Простий метод полягає в переборі кожного числа `i` від 2 до N і перевірці, чи є воно простим. Тест на простоту для `i` включає перевірку дільників від 2 до `sqrt(i)`. Цей підхід має часову складність приблизно O(N * sqrt(N)), що занадто повільно для великих N.",
            "bottleneck": "Наївний підхід виконує зайві перевірки. Наприклад, він перевірить, що 12 ділиться на 2, 3, 4 і 6, хоча достатньо знайти, що воно ділиться на 2, щоб знати, що воно не просте.",
            "optimized_approach": " **Решето Ератосфена** — це високоефективний алгоритм, який працює шляхом ітеративного позначення кратних кожного простого числа як складених. Замість перевірки на множники, він відсіює кратні.\n\nКлючова ідея полягає в тому, що якщо ми знаходимо число `p`, яке ще не було позначено як складене, воно повинно бути простим. Тоді ми можемо позначити всі його кратні (`2p, 3p, 4p, ...`) як не прості. Ми можемо додатково оптимізувати це, починаючи позначати кратні з `p*p`, оскільки будь-яке менше кратне `k*p` (де `k < p`) вже було б позначено простим множником `k`.",
            "algorithm_steps": "1. Створити булевий масив `isPrime` розміром `N+1` і ініціалізувати всі записи від 2 до N як `true`.\n2. Ітерувати від `p = 2` до `sqrt(N)`.\n3. Якщо `isPrime[p]` дорівнює `true`, то `p` — просте число.\n4. Для цього простого числа `p` пройти через його кратні, починаючи з `p*p`, і позначити їх як не прості: `isPrime[j] = false` для `j = p*p, p*p+p, ...` до N.\n5. Нарешті, пройти через масив `isPrime` і зібрати всі індекси, які досі позначені як `true`."
        },
        "quizzes": [
            {
                "question": "Яка головна ідея Решета?",
                "options": [
                    "Перевірити кожне число",
                    "Позначити кратні простих чисел як складені",
                    "Факторизувати всі числа",
                    "Впорядкувати прості числа"
                ],
                "correct": 1
            },
            {
                "question": "Чому починати позначати кратні з p*p?",
                "options": [
                    "Швидше обчислювати",
                    "Менші кратні вже позначені",
                    "Запобігає переповненню",
                    "Математична вимога"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність?",
                "options": [
                    "O(N)",
                    "O(N log N)",
                    "O(N log log N)",
                    "O(N²)"
                ],
                "correct": 2
            },
            {
                "question": "Що означає isPrime[i] = true?",
                "options": [
                    "i складене",
                    "i просте (ще не позначене)",
                    "i парне",
                    "i непарне"
                ],
                "correct": 1
            },
            {
                "question": "Яка просторова складність?",
                "options": [
                    "O(1)",
                    "O(log N)",
                    "O(N)",
                    "O(N²)"
                ],
                "correct": 2
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function sieve(N) {\n  const isPrime = new Array(N + 1).fill(true);\n  isPrime[0] = isPrime[1] = false;\n  for (let p = 2; p * p <= N; p++) {\n    if (isPrime[p]) {\n      for (let multiple = p * p; multiple <= N; multiple += p) {\n        isPrime[multiple] = false;\n      }\n    }\n  }\n  const primes = [];\n  for (let i = 2; i <= N; i++) {\n    if (isPrime[i]) primes.push(i);\n  }\n  return primes;\n}",
            "annotations": [
                {
                    "lines": [
                        4
                    ],
                    "text": "Пропуск Складених: Якщо isPrime[p] хибне, ми вже обробили його множники."
                },
                {
                    "lines": [
                        5
                    ],
                    "text": "Оптимізація: Почати позначати кратні з p*p. Менші кратні (k*p де k < p) вже оброблені."
                },
                {
                    "lines": [
                        6
                    ],
                    "text": "Позначення: Встановити кратне як хибне (складене)."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N log log N)",
        "space": "O(N)",
        "explanation_time": "Часова складність є результатом гармонічного ряду обернених простих чисел. Для кожного простого числа p ми виконуємо N/p роботи. Сума по всіх простих числах дає O(N log log N), що дуже близько до лінійної.",
        "explanation_space": "Нам потрібен булевий масив розміром N для зберігання інформації про простоту для кожного числа."
    }
}