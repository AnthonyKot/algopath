{
    "id": "math-3",
    "title": "Розширений Алгоритм Евкліда",
    "difficulty": "Medium",
    "related": [
        {
            "id": "math-1",
            "title": "Modular Exponentiation",
            "category": "math"
        },
        {
            "id": "math-4",
            "title": "Chinese Remainder Theorem",
            "category": "math"
        }
    ],
    "tags": [
        "gcd",
        "modular-inverse",
        "number-theory"
    ],
    "content": {
        "problem_statement": "Дано два цілих числа `a` і `b`, знайти цілі числа `x` і `y` такі, що `ax + by = gcd(a, b)`. Це фундаментальний алгоритм, який часто використовується для знаходження модульного мультиплікативного оберненого елемента.",
        "explanation": {
            "understanding_the_problem": "Стандартний алгоритм Евкліда знаходить `gcd(a, b)` (НСД). Розширена версія робить це, а також знаходить цілі коефіцієнти `x` та `y`, які задовольняють тотожність Безу.",
            "brute_force": "Стандартний алгоритм Евкліда базується на рекурентності `gcd(a, b) = gcd(b, a % b)`. Розширена версія є доповненням цього процесу. Вона відстежує коефіцієнти на кожному рекурсивному кроці.",
            "bottleneck": "Тут немає 'грубої сили' в типовому розумінні. Сам алгоритм є ефективним рішенням.",
            "optimized_approach": "Алгоритм рекурсивний. Базовий випадок — коли `b = 0`, де `gcd(a, 0) = a`. Рівняння має вигляд `a*x + 0*y = a`, тому `x=1, y=0` є тривіальним розв'язком.\n\nДля рекурсивного кроку ми викликаємо функцію для `(b, a % b)`. Це дає нам `g, x1, y1`, такі що `b*x1 + (a % b)*y1 = g`. Потім ми підставляємо `a % b = a - floor(a/b) * b` назад у це рівняння і перегруповуємо члени, щоб знайти нові `x` та `y`, які відповідають `a` і `b`.",
            "algorithm_steps": "1. **Базовий Випадок:** Якщо `b` дорівнює 0, повернути `[a, 1, 0]`, що представляє `g, x, y`.\n2. **Рекурсивний Крок:** Викликати `extendedGCD(b, a % b)`, щоб отримати `[g, x1, y1]`.\n3. Новий `x` буде `y1`.\n4. Новий `y` буде `x1 - floor(a / b) * y1`.\n5. Повернути `[g, x, y]`.\n\n**Модульне Обернене:** Щоб знайти `a^-1 mod m`, ми розв'язуємо `ax + my = 1`. Значення `x`, повернуте `extendedGCD(a, m)`, є модульним оберненим числом (якщо НСД дорівнює 1)."
        },
        "quizzes": [
            {
                "question": "Яке рівняння розв'язує Розширений Евклід?",
                "options": [
                    "ax = b mod m",
                    "ax + by = gcd(a,b)",
                    "a^b mod m",
                    "ab = c"
                ],
                "correct": 1
            },
            {
                "question": "Який базовий випадок, коли b = 0?",
                "options": [
                    "x=0, y=1",
                    "x=1, y=0",
                    "x=a, y=b",
                    "Немає розв'язку"
                ],
                "correct": 1
            },
            {
                "question": "Як знаходиться модульне обернене?",
                "options": [
                    "Ділення",
                    "Розв'язати ax + my = 1 для x",
                    "Піднесення до степеня",
                    "Випадковий пошук"
                ],
                "correct": 1
            },
            {
                "question": "Коли існує модульне обернене?",
                "options": [
                    "Завжди",
                    "Коли gcd(a,m) = 1",
                    "Коли a > m",
                    "Коли m просте"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність?",
                "options": [
                    "O(N)",
                    "O(log(min(a,b)))",
                    "O(ab)",
                    "O(1)"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function extendedGCD(a, b) {\n  if (b === 0) {\n    return [a, 1, 0];\n  }\n  const [g, x1, y1] = extendedGCD(b, a % b);\n  return [g, y1, x1 - Math.floor(a / b) * y1];\n}\n\nfunction modInverse(a, mod) {\n  const [g, x, y] = extendedGCD(a, mod);\n  if (g !== 1) {\n    return -1;\n  }\n  return ((x % mod) + mod) % mod;\n}",
            "annotations": [
                {
                    "lines": [
                        2
                    ],
                    "text": "Базовий Випадок: gcd(a, 0) = a. Рішення: 1*a + 0*0 = a."
                },
                {
                    "lines": [
                        5
                    ],
                    "text": "Рекурсивний Виклик: Розв'язати для gcd(b, a % b). Повертає [g, x1, y1]."
                },
                {
                    "lines": [
                        6
                    ],
                    "text": "Оновлення Коефіцієнтів: x = y1, y = x1 - floor(a/b)*y1. (Основано на b*x1 + (a%b)*y1 = g)"
                }
            ]
        }
    },
    "complexity": {
        "time": "O(log(min(a,b)))",
        "space": "O(log(min(a,b)))",
        "explanation_time": "Кількість рекурсивних викликів така ж, як у стандартного алгоритму Евкліда, що є логарифмічним відносно розміру меншого вхідного числа.",
        "explanation_space": "Просторова складність визначається глибиною стека рекурсії, яка також є логарифмічною."
    }
}