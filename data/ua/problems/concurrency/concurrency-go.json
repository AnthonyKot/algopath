{
    "id": "concurrency-go",
    "title": "Розподілений Планувальник Задач",
    "difficulty": "Важкий",
    "leetcode_url": "https://gobyexample.com/worker-pools",
    "related": [
        {
            "id": "concurrency-js",
            "title": "Власний Пул Воркерів",
            "category": "concurrency"
        }
    ],
    "tags": [
        "go",
        "канали",
        "горутини",
        "select"
    ],
    "follow_up": {
        "scenario": "Задачі мають бути обмежені за частотою (наприклад, макс 10 запитів/с до зовнішнього API).",
        "trade_off": "Пул воркерів обмежує конкурентність (кількість воркерів), але не частоту (швидкість).",
        "strategy": "Вставте канал `time.Ticker` у цикл воркера. Читайте з тікера перед обробкою задачі.",
        "answering_guide": "Це хліб і масло Go. Згадайте **'Не спілкуйтеся через спільну пам'ять; діліться пам'яттю через спілкування'**. Використовуйте `Context` для скасування."
    },
    "content": {
        "problem_statement": "Реалізуйте конкурентний Планувальник Задач на Go, використовуючи патерн **Worker Pool**. \n\n**Вимоги:**\n1.  Приймати задачі з каналу `jobs`.\n2.  Обробляти задачі, використовуючи фіксовану кількість горутин (воркерів).\n3.  Надсилати результати в канал `results`.\n4.  Забезпечити коректне завершення роботи: дочекатися завершення всіх задач перед закриттям каналів.",
        "explanation": {
            "understanding_the_problem": "Ми хочемо, щоб декілька воркерів (Горутин) брали задачі з єдиного джерела істини (Каналу). Це автоматично забезпечує балансування навантаження: вільний воркер хапає наступний елемент з каналу.",
            "brute_force": "Запуск `go func()` для кожної задачі. У Go це насправді дешево (на відміну від потоків), але все ж небезпечно при великому масштабі (мільйони задач = виснаження пам'яті). Пул воркерів обмежує конкурентність.",
            "bottleneck": "Якщо споживачі (воркери) повільніші за виробників, канал заповнюється і блокує виробників. Розмір буфера має значення.",
            "optimized_approach": "1.  Створіть канал `jobs` (буферизований).\n2.  Створіть канал `results` (буферизований).\n3.  Запустіть `N` горутин-воркерів. Кожна робить `range jobs`.\n4.  Надішліть задачі в канал `jobs`.\n5.  Закрийте канал `jobs`, щоб подати сигнал 'більше немає роботи'.\n6.  Цикли воркерів завершуються, коли канал закрито.",
            "algorithm_steps": "1.  Функція `worker(id, jobs, results)`: `for j := range jobs { process(j); results <- result }`.\n2.  У `main`: створіть канали.\n3.  Цикл `1` до `N`: `go worker(...)`.\n4.  Цикл задач: `jobs <- task`.\n5.  `close(jobs)`.\n6.  Зберіть результати з каналу `results`."
        },
        "quizzes": [
            {
                "question": "Що станеться, якщо читати із закритого каналу?",
                "options": [
                    "Паніка",
                    "Повертає нульове значення негайно",
                    "Блокується назавжди",
                    "Викидає помилку"
                ],
                "correct": 1
            },
            {
                "question": "Що станеться, якщо писати в закритий канал?",
                "options": [
                    "Паніка",
                    "Ігнорується",
                    "Блокується",
                    "Повертає false"
                ],
                "correct": 0
            },
            {
                "question": "Навіщо використовувати Буферизовані Канали?",
                "options": [
                    "Обов'язково для рядків",
                    "Зменшує блокування між виробником/споживачем",
                    "Гарантує порядок",
                    "Швидше створення"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "go": {
            "solution": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int) {\n\tfor j := range jobs {\n\t\tfmt.Println(\"worker\", id, \"processing job\", j)\n\t\ttime.Sleep(time.Second) // Simulate expensive work\n\t\tresults <- j * 2\n\t}\n}\n\nfunc main() {\n\tconst numJobs = 5\n\tconst numWorkers = 3\n\n\tjobs := make(chan int, numJobs)\n\tresults := make(chan int, numJobs)\n\n\t// 1. Start workers\n\tfor w := 1; w <= numWorkers; w++ {\n\t\tgo worker(w, jobs, results)\n\t}\n\n\t// 2. Send jobs\n\tfor j := 1; j <= numJobs; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs) // Signal no more jobs\n\n\t// 3. Collect results\n\tfor a := 1; a <= numJobs; a++ {\n\t\t<-results\n\t}\n}",
            "annotations": [
                {
                    "lines": [
                        8,
                        12
                    ],
                    "text": "Правильний синтаксис: jobs <-chan int (Тільки для читання), results chan<- int (Тільки для запису)."
                },
                {
                    "lines": [
                        9
                    ],
                    "text": "'range jobs' крутиться, поки канал не закритий І порожній. Найкращий спосіб забезпечити коректне завершення."
                },
                {
                    "lines": [
                        29
                    ],
                    "text": "close(jobs) є критичним. Без нього воркери чекатимуть вічно, і станеться deadlock."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(J) загальної роботи",
        "space": "O(N) воркерів",
        "explanation_time": "Пропускна здатність зростає з N воркерів, але обмежена ядрами CPU.",
        "explanation_space": "Мінімальні накладні витрати на горутини (2КБ кожна)."
    }
}