{
    "id": "strings-1",
    "title": "Співставлення Шаблонів KMP",
    "difficulty": "Medium",
    "leetcode_url": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/",
    "related": [
        {
            "id": "strings-2",
            "title": "Rabin-Karp Rolling Hash",
            "category": "strings"
        },
        {
            "id": "strings-3",
            "title": "Z-Algorithm",
            "category": "strings"
        }
    ],
    "tags": [
        "kmp",
        "strings",
        "pattern-matching"
    ],
    "follow_up": {
        "scenario": "Система виявлення вторгнень (IDS), що фільтрує мережеві пакети за сигнатурами.",
        "trade_off": "Наївний пошук вразливий до атак алгоритмічної складності. Перевірка по одному занадто повільна.",
        "strategy": "Використовуйте Aho-Corasick для *множинного* співставлення шаблонів (розширення KMP). Він будує Trie шаблонів з failure links.",
        "answering_guide": "У безпеці/мережах чистий KMP рідко використовується сам по собі. Згадайте <strong>'Aho-Corasick'</strong> для *множинних* шаблонів (як вірусні сигнатури)."
    },
    "content": {
        "problem_statement": "Дано два рядки `text` та `pattern`, поверніть **всі** індекси в `text`, де починається `pattern`.\n\n**Приклад 1:**\n```\nInput: text = \"abxabcabcaby\", pattern = \"abcaby\"\nOutput: [6]\n```\n**Приклад 2:**\n```\nInput: text = \"aaaaa\", pattern = \"aa\"\nOutput: [0, 1, 2, 3]\n```",
        "explanation": {
            "understanding_the_problem": "Мета - ефективно знайти малий рядок-шаблон у більшому рядку-тексті. Наївне рішення перевіряло б збіг на кожній можливій початковій позиції в тексті, що повільно.",
            "brute_force": "Наївний підхід полягає в переміщенні шаблону над текстом на одну позицію за раз. На кожній позиції ви порівнюєте шаблон з відповідним підрядком тексту. Це має часову складність O((N-M+1) * M) ≈ O(N*M), де N - довжина тексту, а M - довжина шаблону.",
            "bottleneck": "Вузьким місцем є те, що при невідповідності наївний підхід зсуває шаблон лише на одну позицію. Ми маємо інформацію з часткового збігу, який ми щойно зробили, що може дозволити нам зсунути шаблон набагато далі.",
            "optimized_approach": "Алгоритм Кнута-Морріса-Пратта (KMP) досягає часу O(N+M) за допомогою попередньо обчисленого масиву 'Найдовший Власний Префікс, який також є Суфіксом' (LPS). Цей масив `lps` каже нам, після невідповідності, довжину найдовшого власного префікса шаблону, який вже було співставлено, і який також є суфіксом цієї співставленої частини. Це дозволяє нам 'ковзати' шаблоном вперед розумно, не перевіряючи повторно символи, які ми знаємо, що збігатимуться.",
            "algorithm_steps": "1.  **Попередня обробка (O(M)):** Побудуйте масив `lps` для `pattern`. `lps[i]` зберігає довжину найдовшого власного префікса `pattern[0...i]`, який також є суфіксом `pattern[0...i]`.\n2.  **Пошук (O(N)):** Ітеруйте через `text` з вказівником `i` та `pattern` з вказівником `j`. Якщо символи збігаються, збільшуйте обидва. Якщо вони не збігаються, замість того, щоб скидати `j` до 0, ми консультуємося з масивом `lps` (`j = lps[j-1]`), щоб знайти наступну найкращу позицію для продовження співставлення, уникаючи зайвих порівнянь."
        },
        "quizzes": [
            {
                "question": "Що означає LPS в KMP?",
                "options": [
                    "Longest Prefix String",
                    "Longest Proper Prefix also Suffix",
                    "Last Pattern Start",
                    "Linear Pattern Search"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність KMP?",
                "options": [
                    "O(N²)",
                    "O(N*M)",
                    "O(N+M)",
                    "O(N log N)"
                ],
                "correct": 2
            },
            {
                "question": "Що робить KMP швидшим за наївний пошук?",
                "options": [
                    "Сортування спочатку",
                    "Уникнення зайвих порівнянь за допомогою LPS",
                    "Паралельна обробка",
                    "Бінарний пошук"
                ],
                "correct": 1
            },
            {
                "question": "Що відбувається при невідповідності після часткового збігу?",
                "options": [
                    "Почати заново",
                    "Використати LPS щоб перестрибнути вперед",
                    "Перевернути рядок",
                    "Поміняти місцями символи"
                ],
                "correct": 1
            },
            {
                "question": "Чи будується масив LPS під час попередньої обробки?",
                "options": [
                    "Ні, під час пошуку",
                    "Так, O(M) часу",
                    "Не потрібен",
                    "Будується один раз на текст"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function buildLPS(pattern) {\n  const m = pattern.length;\n  const lps = new Array(m).fill(0);\n  let len = 0;\n  for (let i = 1; i < m; i++) {\n    while (len > 0 && pattern[i] !== pattern[len]) len = lps[len - 1];\n    if (pattern[i] === pattern[len]) len++;\n    lps[i] = len;\n  }\n  return lps;\n}\n\nfunction kmpSearch(text, pattern) {\n  const n = text.length, m = pattern.length;\n  const lps = buildLPS(pattern);\n  const result = [];\n  let i = 0, j = 0;\n  while (i < n) {\n    if (pattern[j] === text[i]) {\n      i++; j++;\n    }\n    if (j === m) {\n      result.push(i - j);\n      j = lps[j - 1];\n    } else if (i < n && pattern[j] !== text[i]) {\n      if (j !== 0) j = lps[j - 1];\n      else i++;\n    }\n  }\n  return result;\n}",
            "annotations": [
                {
                    "lines": [
                        6
                    ],
                    "text": "Випадок невідповідності LPS: повернення `len` за допомогою попередніх значень LPS."
                },
                {
                    "lines": [
                        7
                    ],
                    "text": "Випадок збігу: розширити поточну довжину префікса."
                },
                {
                    "lines": [
                        16
                    ],
                    "text": "Цикл пошуку: i сканує текст, j сканує шаблон."
                },
                {
                    "lines": [
                        19,
                        20
                    ],
                    "text": "Повний збіг знайдено! Запишіть індекс і використовуйте LPS для підготовки до наступного збігу."
                },
                {
                    "lines": [
                        22
                    ],
                    "text": "Невідповідність після деяких збігів: Розумний стрибок. Встановіть j на LPS[j-1]."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N + M)",
        "space": "O(M)",
        "explanation_time": "Алгоритм має дві частини: побудову масиву LPS, що займає O(M) часу, і пошук у тексті, що займає O(N) часу, оскільки вказівник тексту `i` ніколи не рухається назад. Це дає загальну лінійну часову складність.",
        "explanation_space": "Нам потрібно зберігати масив LPS, який має той самий розмір, що й шаблон, що призводить до O(M) простору."
    }
}