{
    "id": "strings-3",
    "title": "Z-Алгоритм для Пошуку Шаблонів",
    "difficulty": "Medium",
    "leetcode_url": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/",
    "related": [
        {
            "id": "strings-1",
            "title": "KMP Pattern Matching",
            "category": "strings"
        },
        {
            "id": "strings-4",
            "title": "Suffix Array Construction",
            "category": "strings"
        }
    ],
    "tags": [
        "z-algorithm",
        "strings",
        "prefix-function"
    ],
    "content": {
        "problem_statement": "Дано два рядки `text` та `pattern`, поверніть **всі** індекси в `text`, де починається `pattern`.\n\n**Приклад 1:**\n```\nInput: text = \"abxabcabcaby\", pattern = \"abcaby\"\nOutput: [6]\n```",
        "explanation": {
            "understanding_the_problem": "Z-Алгоритм - це ще один алгоритм пошуку шаблонів за лінійний час. Він базується на створенні 'Z-масиву' з об'єднаного рядка.",
            "brute_force": "Основою алгоритму є Z-масив. Для рядка `S`, `Z[i]` - це довжина найдовшого підрядка, що починається з `S[i]`, який також є префіксом `S`. Наївний спосіб обчислення цього масиву полягав би в ітерації `i` від 1 до N-1, і для кожного `i`, вручну порівнювати `S[i...]` з `S[0...]`, що зайняло б O(N²) часу.",
            "bottleneck": "Побудова Z-масиву за O(N²) є вузьким місцем. Потрібна розумна побудова за лінійний час.",
            "optimized_approach": "Щоб знайти `pattern` в `text`, ми будуємо новий рядок `S = pattern + '$' + text`, де `$` - це спеціальний символ, якого немає в жодному з рядків. Потім ми обчислюємо Z-масив для `S` за лінійний час.\n\nКлючовим є те, що якщо `Z[i]` для деякого індексу `i` в частині `text` рядка `S` дорівнює довжині `pattern`, це означає, що підрядок `S`, що починається з `i`, ідентичний префіксу `S` (який є `pattern`). Таким чином, ми знайшли збіг.\n\nСаме Z-масив може бути обчислений за час O(N+M), підтримуючи 'Z-box' `[l, r]`, який є інтервалом з найправішою кінцевою точкою, що відповідає префіксу. При обчисленні `Z[i]`, якщо `i` знаходиться всередині цього вікна, ми можемо використовувати попередньо обчислені Z-значення, щоб отримати фору, уникаючи зайвих порівнянь.",
            "algorithm_steps": "1.  Створіть об'єднаний рядок `S = pattern + '$' + text`.\n2.  Обчисліть Z-масив для `S`, використовуючи оптимізований алгоритм лінійного часу.\n3.  Ітеруйте через Z-масив. Якщо `Z[i]` дорівнює довжині шаблону, то збіг починається за індексом `i - pattern.length - 1` в оригінальному тексті."
        },
        "quizzes": [
            {
                "question": "Що представляє Z[i]?",
                "options": [
                    "Відстань до кінця",
                    "Найдовший префікс, що також є підрядком в i",
                    "Код символу",
                    "Кількість збігів"
                ],
                "correct": 1
            },
            {
                "question": "Як ми використовуємо Z-алгоритм для пошуку шаблонів?",
                "options": [
                    "Пряме порівняння",
                    "Об'єднати pattern+'$'+text",
                    "Сортувати рядки",
                    "Хеш-значення"
                ],
                "correct": 1
            },
            {
                "question": "Що таке 'Z-box'?",
                "options": [
                    "Спеціальний символ",
                    "Інтервал, що відповідає префіксу, для оптимізації",
                    "Структура даних",
                    "Вихідний масив"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність?",
                "options": [
                    "O(N²)",
                    "O(N*M)",
                    "O(N+M)",
                    "O(N log N)"
                ],
                "correct": 2
            },
            {
                "question": "Коли Z[i] = довжина шаблону?",
                "options": [
                    "Завжди",
                    "Коли шаблон збігається в позиції i",
                    "Ніколи",
                    "В кінці тексту"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function computeZ(s) {\n  const n = s.length;\n  const Z = new Array(n).fill(0);\n  Z[0] = 0;\n  let l = 0, r = 0;\n  for (let i = 1; i < n; i++) {\n    if (i <= r) {\n      Z[i] = Math.min(r - i + 1, Z[i - l]);\n    }\n    while (i + Z[i] < n && s[Z[i]] === s[i + Z[i]]) {\n      Z[i]++;\n    }\n    if (i + Z[i] - 1 > r) {\n      l = i;\n      r = i + Z[i] - 1;\n    }\n  }\n  return Z;\n}\n\nfunction zSearch(pattern, text, special = '$') {\n  const combined = pattern + special + text;\n  const Z = computeZ(combined);\n  const m = pattern.length;\n  const result = [];\n  for (let i = m + 1; i < combined.length; i++) {\n    if (Z[i] === m) {\n      result.push(i - m - 1);\n    }\n  }\n  return result;\n}",
            "annotations": [
                {
                    "lines": [
                        6
                    ],
                    "text": "Оптимізація: Всередині Z-box [l,r], використовуйте попередньо обчислене дзеркальне значення."
                },
                {
                    "lines": [
                        9
                    ],
                    "text": "Наївне розширення: Розширити збіг за межі відомого Z-box."
                },
                {
                    "lines": [
                        12
                    ],
                    "text": "Оновлення Z-box: Розширити межу [l, r], щоб покрити новий збіг."
                },
                {
                    "lines": [
                        20
                    ],
                    "text": "Перевірка Z-значення: Якщо довжина дорівнює довжині шаблону, знайдено точний збіг."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N + M)",
        "space": "O(N + M)",
        "explanation_time": "Алгоритм побудови Z-масиву розумно повторно використовує інформацію для досягнення одного проходу по об'єднаному рядку, забезпечуючи лінійну часову складність.",
        "explanation_space": "Нам потрібно зберігати об'єднаний рядок та Z-масив, обидва з яких мають розмір N + M + 1."
    }
}