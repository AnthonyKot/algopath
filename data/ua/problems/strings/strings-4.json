{
    "id": "strings-4",
    "title": "Побудова Суфіксного Масиву",
    "difficulty": "Medium",
    "related": [
        {
            "id": "strings-3",
            "title": "Z-Algorithm",
            "category": "strings"
        },
        {
            "id": "strings-5",
            "title": "Manacher's Algorithm",
            "category": "strings"
        }
    ],
    "tags": [
        "suffix-array",
        "strings",
        "sorting"
    ],
    "content": {
        "problem_statement": "Дано рядок `s`, поверніть **суфіксний масив** для `s`.\n\n**Суфіксний масив** - це відсортований масив усіх суфіксів `s`. Це масив цілих чисел, що представляють початкові індекси всіх суфіксів `s`, необхідні для перерахування їх у **лексикографічному порядку**.\n\n**Приклад 1:**\n```\nInput: s = \"banana\"\nOutput: [5, 3, 1, 0, 4, 2]\nExplanation: \nSuffixes: [\"a\", \"ana\", \"anana\", \"banana\", \"na\", \"nana\"]\nIndices: [5, 3, 1, 0, 4, 2]\n```",
        "explanation": {
            "understanding_the_problem": "Нам потрібно створити масив цілих чисел, що представляють початкові індекси всіх суфіксів рядка, так, що якщо ми перерахуємо суфікси в цьому порядку, вони будуть лексикографічно відсортовані.",
            "brute_force": "Найпростіший спосіб - це фактично згенерувати всі N суфіксів рядка, а потім використати стандартний алгоритм сортування. Генерація всіх суфіксів займає O(N²) часу та простору. Сортування їх потім займе O(N * N log N), оскільки кожне порівняння може зайняти до O(N) часу. Це занадто повільно.",
            "bottleneck": "Крок сортування є вузьким місцем, зокрема дорогі порівняння рядків O(N).",
            "optimized_approach": "Поширеним і набагато швидшим підходом є алгоритм **'Подвоєння'** або **'Подвоєння Префікса'**, який має складність O(N log² N). Замість того, щоб сортувати повні суфікси відразу, ми сортуємо їх на основі префіксів експоненціально зростаючої довжини (1, 2, 4, 8, ...).\n\nНа кожному кроці `k`, ми сортуємо суфікси на основі їх перших `2^k` символів. Головна хитрість полягає в тому, що префікс довжиною `2^k` можна розглядати як пару двох префіксів довжиною `2^(k-1)`, відносний порядок (ранг) яких ми вже обчислили на попередньому кроці. Це перетворює дороге порівняння рядків на просте порівняння пари цілих чисел, що набагато швидше.",
            "algorithm_steps": "1.  **Крок k=0:** Відсортуйте всі суфікси на основі їхнього першого символу. Призначте клас еквівалентності (ранг) кожному суфіксу.\n2.  **Ітерація:** Для `k` від 1 до `log N`:\n    a.  Створіть пари рангів для кожного суфікса, що представляють перші `2^k` символів: `(ранг перших 2^(k-1) символів, ранг других 2^(k-1) символів)`.\n    b.  Відсортуйте суфікси на основі цих пар.\n    c.  Перерахуйте класи еквівалентності (ранги) на основі нового відсортованого порядку.\n3.  **Результат:** Після `log N` ітерацій суфікси повністю відсортовані, і суфіксний масив побудовано."
        },
        "quizzes": [
            {
                "question": "Що таке суфіксний масив?",
                "options": [
                    "Частоти символів",
                    "Відсортовані індекси всіх суфіксів",
                    "Хеш-значення",
                    "Довжини префіксів"
                ],
                "correct": 1
            },
            {
                "question": "Яка головна ідея подвоєння префікса?",
                "options": [
                    "Сортувати за зростанням довжини префікса",
                    "Використовувати хеш-таблиці",
                    "Порівнювати всі пари",
                    "Рекурсивний поділ"
                ],
                "correct": 0
            },
            {
                "question": "Скільки ітерацій займає подвоєння?",
                "options": [
                    "N",
                    "N/2",
                    "log N",
                    "N²"
                ],
                "correct": 2
            },
            {
                "question": "Яка часова складність алгоритму подвоєння?",
                "options": [
                    "O(N)",
                    "O(N log N)",
                    "O(N log² N)",
                    "O(N²)"
                ],
                "correct": 2
            },
            {
                "question": "Для чого використовуються суфіксні масиви?",
                "options": [
                    "Тільки сортування",
                    "Пошук шаблонів, LCP, стиснення",
                    "Просто візуалізація",
                    "Виділення пам'яті"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function buildSuffixArray(s) {\n  const n = s.length;\n  const sa = Array.from({length: n}, (_, i) => i);\n  const rank = s.split('').map(c => c.charCodeAt(0));\n  const tmp = new Array(n).fill(0);\n  for (let k = 1; k < n; k *= 2) {\n    sa.sort((a, b) => {\n      const ra = rank[a], rb = rank[b];\n      if (ra === rb) {\n        const rak = rank[a+k] || -1, rbk = rank[b+k] || -1;\n        return rak - rbk;\n      }\n      return ra - rb;\n    });\n    tmp[sa[0]] = 0;\n    for (let i = 1; i < n; i++) {\n      const prev = sa[i-1], curr = sa[i];\n      const prevRank = rank[prev] + ',' + (rank[prev+k] || -1);\n      const currRank = rank[curr] + ',' + (rank[curr+k] || -1);\n      tmp[curr] = tmp[prev] + (prevRank < currRank ? 1 : 0);\n    }\n    [rank, tmp] = [tmp, rank];\n  }\n  return sa;\n}",
            "annotations": [
                {
                    "lines": [
                        1
                    ],
                    "text": "Визначення функції: Будує суфіксний масив за час O(N log² N)."
                },
                {
                    "lines": [
                        6
                    ],
                    "text": "Головний цикл: Логарифмічні кроки, подвоєння довжини префікса k кожного разу."
                },
                {
                    "lines": [
                        8
                    ],
                    "text": "Сортування: Порівнюйте суфікси, використовуючи пару (поточний ранг, наступний ранг)."
                },
                {
                    "lines": [
                        21
                    ],
                    "text": "Перерахунок рангів: Призначте нові класи еквівалентності на основі відсортованого порядку."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N log² N)",
        "space": "O(N)",
        "explanation_time": "Головний цикл виконується log(N) разів. Всередині циклу домінуючою операцією є сортування, яке займає O(N log N) часу. Це дає загальну часову складність O(N log² N). (Примітка: Існують більш просунуті алгоритми O(N), такі як SA-IS, але вони набагато складніші).",
        "explanation_space": "Нам потрібен простір для суфіксного масиву, плюс пара масивів для рангів, всі з яких мають розмір O(N)."
    }
}