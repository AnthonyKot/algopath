{
    "id": "strings-2",
    "title": "Рабін-Карп і Хеш, що Ковзає",
    "difficulty": "Середній",
    "leetcode_url": "https://leetcode.com/problems/repeated-dna-sequences/",
    "related": [
        {
            "id": "strings-1",
            "title": "KMP Pattern Matching",
            "category": "strings"
        },
        {
            "id": "strings-3",
            "title": "Z-Algorithm",
            "category": "strings"
        }
    ],
    "tags": [
        "hashing",
        "strings",
        "pattern-matching"
    ],
    "follow_up": {
        "scenario": "Виявлення плагіату у великих кодових базах або документах.",
        "trade_off": "Точне співставлення рядків є дорогим для масивних документів.",
        "strategy": "Content-Defined Chunking (CDC) з Rolling Hash для створення відбитків файлів. Порівнюйте відбитки замість повного тексту.",
        "answering_guide": "Зосередьтеся на <strong>'Створенні Відбитків (Fingerprinting)'</strong>. Хеш, що ковзає, є основою для 'rsync' та систем дедуплікації. Згадка <strong>'rsync'</strong> - це хід профі."
    },
    "content": {
        "problem_statement": "Дано два рядки `text` та `pattern`, поверніть **всі** індекси в `text`, де починається `pattern`.\n\n**Приклад 1:**\n```\nInput: text = \"abxabcabcaby\", pattern = \"abcaby\"\nOutput: [6]\n```",
        "explanation": {
            "understanding_the_problem": "Цей алгоритм забезпечує альтернативу KMP. Замість порівняння рядків символ за символом, він порівнює хеш-значення. Основна ідея полягає в обчисленні хешу для шаблону, а потім ефективному обчисленні хешів для всіх підрядків тексту, які мають ту саму довжину, що й шаблон.",
            "brute_force": "Наївний підхід хешування полягав би в обчисленні хешу шаблону, потім переборі всіх N-M+1 підрядків тексту, обчисленні хешу для кожного та порівнянні. Однак обчислення хешу для кожного підрядка з нуля зайняло б O(M) часу, що призвело б до тієї ж складності O(N*M), що й наївний пошук рядків.",
            "bottleneck": "Вузьким місцем є перерахунок хешу для кожного ковзного вікна з нуля.",
            "optimized_approach": "Алгоритм Рабіна-Карпа використовує **Хеш, що Ковзає (Rolling Hash)**. Функція хешу, що ковзає, дозволяє нам обчислити значенню хешу наступного вікна за час O(1), враховуючи хеш поточного вікна. Коли ми зсуваємо вікно на одну позицію праворуч, ми математично віднімаємо внесок символу, що залишає вікно, і додаємо внесок символу, що входить до нього.\n\nКоли хеш шаблону збігається з хешем поточного текстового вікна, це *потенційний* збіг. Потім ми повинні виконати посимвольне порівняння для підтвердження, оскільки різні рядки іноді можуть мати однаковий хеш ('колізія').",
            "algorithm_steps": "1.  Виберіть простий модуль та базу для поліноміального хешу, що ковзає.\n2.  Обчисліть хеш `pattern` та хеш першого вікна `text`.\n3.  Ітеруйте зліва направо по тексту. Якщо хеші збігаються, виконайте пряме порівняння рядків для підтвердження.\n4.  'Прокрутіть' хеш тестового вікна до наступної позиції за час O(1), видаливши внесок найлівішого символу та додавши найправішого."
        },
        "quizzes": [
            {
                "question": "Що таке 'хеш, що ковзає'?",
                "options": [
                    "Відсортований хеш",
                    "Хеш, що оновлюється за O(1) на зсув вікна",
                    "Кільцевий буфер",
                    "Зашифрований хеш"
                ],
                "correct": 1
            },
            {
                "question": "Що відбувається, коли хеші збігаються?",
                "options": [
                    "Гарантований збіг",
                    "Перевірити порівнянням рядків",
                    "Перейти до наступного",
                    "Повернути негайно"
                ],
                "correct": 1
            },
            {
                "question": "Чому ми можемо отримати хибні спрацьовування?",
                "options": [
                    "Баг у коді",
                    "Колізії хешів",
                    "Неправильна база",
                    "Шаблон занадто довгий"
                ],
                "correct": 1
            },
            {
                "question": "Яка середня часова складність?",
                "options": [
                    "O(N²)",
                    "O(N*M)",
                    "O(N+M)",
                    "O(log N)"
                ],
                "correct": 2
            },
            {
                "question": "Який найгірший випадок (багато колізій)?",
                "options": [
                    "O(N)",
                    "O(N+M)",
                    "O(N*M)",
                    "O(log N)"
                ],
                "correct": 2
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function rabinKarp(text, pattern, base=256, mod=10**9+7) {\n  const n = text.length, m = pattern.length;\n  if (m > n) return [];\n  let hashPattern = 0, hashText = 0;\n  let h = 1;\n  for (let i = 0; i < m; i++) {\n    hashPattern = (hashPattern * base + pattern.charCodeAt(i)) % mod;\n    hashText = (hashText * base + text.charCodeAt(i)) % mod;\n    if (i < m - 1) h = (h * base) % mod;\n  }\n  const result = [];\n  for (let i = 0; i <= n - m; i++) {\n    if (hashPattern === hashText) {\n      if (text.slice(i, i+m) === pattern) result.push(i);\n    }\n    if (i < n - m) {\n      hashText = ((hashText - text.charCodeAt(i) * h) * base + text.charCodeAt(i+m)) % mod;\n      if (hashText < 0) hashText += mod;\n    }\n  }\n  return result;\n}",
            "annotations": [
                {
                    "lines": [
                        8
                    ],
                    "text": "Початкове обчислення хешу вікна."
                },
                {
                    "lines": [
                        13
                    ],
                    "text": "Збіг хешу: Потенційна колізія, перевірте точним порівнянням рядків."
                },
                {
                    "lines": [
                        17
                    ],
                    "text": "Хеш, що ковзає: Видаліть провідний символ, додайте новий кінцевий символ за O(1)."
                },
                {
                    "lines": [
                        18
                    ],
                    "text": "Корекція: Обробіть негативний результат від оператора модуля JS."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N + M) в середньому",
        "space": "O(M)",
        "explanation_time": "В середньому, з хорошою хеш-функцією, колізії рідкісні. Алгоритм працює за O(N+M) часу. У найгіршому випадку (багато колізій хешів), складність може погіршитися до O(N*M) через повторні посимвольні перевірки.",
        "explanation_space": "Нам потрібно зберігати лише шаблон та кілька змінних для хешів, тому простір становить O(M)."
    }
}