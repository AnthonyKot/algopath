{
    "id": "strings-5",
    "title": "Алгоритм Манакера (Найдовший Паліндром)",
    "difficulty": "Medium",
    "leetcode_url": "https://leetcode.com/problems/longest-palindromic-substring/",
    "related": [
        {
            "id": "strings-4",
            "title": "Suffix Array Construction",
            "category": "strings"
        },
        {
            "id": "dp-1",
            "title": "Edit Distance",
            "category": "dp"
        }
    ],
    "tags": [
        "manacher",
        "palindrome",
        "strings"
    ],
    "content": {
        "problem_statement": "Дано рядок `s`, поверніть **найдовший паліндромний підрядок** в `s`.\n\n**Приклад 1:**\n```\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" також є допустимою відповіддю.\n```",
        "explanation": {
            "understanding_the_problem": "Нам потрібно знайти найдовший підрядок (безперервну частину рядка), який читається однаково вперед і назад.",
            "brute_force": "Поширеним підходом є 'Розширення від Центру'. Ми можемо ітерувати через кожен можливий центр паліндрома. Центром може бути один символ (для паліндромів непарної довжини) або проміжок між двома символами (для парної довжини). З кожного центру ми розширюємося назовні, поки символи збігаються. Це займає O(N²) часу.",
            "bottleneck": "Підхід 'Розширення від Центру' має складність O(N²), тому що він повторно сканує ті самі символи багато разів. Наприклад, при перевірці паліндрома 'abacaba', ми будемо повторно сканувати частину 'aba' кілька разів.",
            "optimized_approach": "Алгоритм Манакера - це розумне рішення з лінійним часом O(N). Він уникає зайвих порівнянь, використовуючи симетричну природу паліндромів. Алгоритм підтримує центр `C` і праву межу `R` знайденого на даний момент паліндрома, який сягає найдалі праворуч.\n\nКоли ми знаходимося на новій позиції `i`, якщо `i` знаходиться в межах поточного найправішого паліндрома `[L, R]`, ми можемо використовувати інформацію з його 'дзеркальної' позиції з іншого боку від `C`, щоб отримати початковий гарантований мінімальний радіус для паліндрома в `i`. Нам потрібно лише виконати порівняння символів, щоб спробувати розширитися *за межі* цього початкового радіуса.",
            "algorithm_steps": "1.  **Попередня обробка:** Перетворіть рядок, щоб обробляти паліндроми непарної та парної довжини однаково. Наприклад, `s = \"aba\"` стає `t = \"#a#b#a#\"`.\n2.  **Ініціалізація:** Створіть масив `P` того ж розміру, що й `t`, де `P[i]` зберігатиме радіус паліндрома з центром в `t[i]`. Ініціалізуйте `C` (центр) та `R` (права межа) значенням 0.\n3.  **Головний Цикл:** Ітеруйте `i` через перетворений рядок `t`.\n    a.  Якщо `i < R`, використовуйте властивість дзеркальності, щоб ініціалізувати `P[i]` мінімальним гарантованим значенням.\n    b.  Спробуйте розширити паліндром з центром в `i`, порівнюючи символи.\n    c.  Якщо паліндром в `i` розширюється за межі `R`, оновіть `C` та `R` до меж цього нового паліндрома.\n4.  **Результат:** Знайдіть максимальне значення в масиві `P`. Це відповідає радіусу найдовшого паліндромного підрядка. Перетворіть цей радіус назад у довжину в оригінальному рядку."
        },
        "quizzes": [
            {
                "question": "Як Манакер обробляє паліндроми непарної та парної довжини?",
                "options": [
                    "Окремі цикли",
                    "Перетворює рядок за допомогою #",
                    "Ігнорує парні",
                    "Бінарний пошук"
                ],
                "correct": 1
            },
            {
                "question": "Яка ключова оптимізація в Манакері?",
                "options": [
                    "Сортування",
                    "Використання властивості дзеркальності паліндрома",
                    "Хешування",
                    "Розділяй і володарюй"
                ],
                "correct": 1
            },
            {
                "question": "Що зберігає P[i]?",
                "options": [
                    "Код символу",
                    "Радіус паліндрома в i",
                    "Довжину рядка",
                    "Індекс дзеркала"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність Манакера?",
                "options": [
                    "O(N²)",
                    "O(N log N)",
                    "O(N)",
                    "O(2^N)"
                ],
                "correct": 2
            },
            {
                "question": "Що робить внутрішній цикл while O(N) загалом?",
                "options": [
                    "Фіксовані ітерації",
                    "Права межа R рухається тільки вперед",
                    "Раннє завершення",
                    "Хвостова рекурсія"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function manacher(s) {\n  const t = '#' + s.split('').join('#') + '#';\n  const n = t.length;\n  const P = new Array(n).fill(0);\n  let C = 0, R = 0;\n  for (let i = 1; i < n - 1; i++) {\n    const mirror = 2*C - i;\n    if (i < R) {\n      P[i] = Math.min(R - i, P[mirror]);\n    }\n    while (i + 1 + P[i] < n && i - 1 - P[i] >= 0 &&\n           t[i + 1 + P[i]] === t[i - 1 - P[i]]) {\n      P[i]++;\n    }\n    if (i + P[i] > R) {\n      C = i;\n      R = i + P[i];\n    }\n  }\n  let maxLen = 0, centerIndex = 0;\n  for (let i = 1; i < n - 1; i++) {\n    if (P[i] > maxLen) {\n      maxLen = P[i];\n      centerIndex = i;\n    }\n  }\n  const start = Math.floor((centerIndex - 1 - maxLen) / 2);\n  return s.slice(start, start + maxLen);\n}",
            "annotations": [
                {
                    "lines": [
                        2
                    ],
                    "text": "Перетворення рядка: 'aba' -> '#a#b#a#', щоб обробляти парні/непарні довжини."
                },
                {
                    "lines": [
                        7
                    ],
                    "text": "Властивість дзеркальності: Знайти індекс 'mirror', симетричний до 'i' відносно 'C'."
                },
                {
                    "lines": [
                        8
                    ],
                    "text": "Оптимізація: Використовувати значення P дзеркала, щоб пропустити відомий паліндромний регіон."
                },
                {
                    "lines": [
                        10
                    ],
                    "text": "Розширення: Перевіряти символи за межами відомого радіуса."
                },
                {
                    "lines": [
                        13
                    ],
                    "text": "Оновлення: Новий паліндром виходить за межі R, тому пересуваємо центр C."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N)",
        "space": "O(N)",
        "explanation_time": "Хоча всередині головного циклу `for` є цикл `while`, права межа `R` завжди рухається тільки вперед по рядку. Загальна кількість порівнянь символів, виконаних циклом розширення `while` протягом усього алгоритму, амортизується до O(N).",
        "explanation_space": "Нам потрібно зберігати перетворений рядок `t` та масив радіусів паліндромів `P`, обидва з яких пропорційні довжині оригінального рядка `s`."
    }
}