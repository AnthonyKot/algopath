{
    "id": "geometry-1",
    "title": "Опукла Оболонка (Монотонний Ланцюг)",
    "difficulty": "Hard",
    "leetcode_url": "https://leetcode.com/problems/erect-the-fence/",
    "tags": [
        "geometry",
        "math",
        "convex-hull"
    ],
    "content": {
        "problem_statement": "Вам дано масив `trees`, де `trees[i] = [xi, yi]` представляє розташування дерева в саду. Вас просять обгородити весь сад, використовуючи мінімальну довжину мотузки, оскільки вона дорога. Сад добре обгороджений лише в тому випадку, якщо **всі дерева огороджені**.\n\nПоверніть координати дерев, які точно розташовані на периметрі огорожі.",
        "explanation": {
            "understanding_the_problem": "Нам потрібно знайти найменший опуклий багатокутник, який містить усі задані точки. Це схоже на обертання гумової стрічки навколо набору цвяхів.",
            "brute_force": "Для кожної пари точок перевірте, чи всі інші точки лежать по одну сторону від лінії, що їх з'єднує. Якщо так, ця логічна лінія є частиною оболонки. O(N³).",
            "optimized_approach": "**Алгоритм Монотонного Ланцюга (Алгоритм Ендрю):**\n1. Відсортуйте точки за координатою x (і за координатою y у разі рівності).\n2. Побудуйте **нижню оболонку**: Ітеруйте через точки, додаючи їх до стека. Якщо нова точка робить 'правий поворот' (за годинниковою стрілкою) відносно двох останніх точок, видаляйте зі стека, поки поворот не стане лівим (проти годинникової стрілки).\n3. Побудуйте **верхню оболонку**: Схожий процес, ітеруючи справа наліво.\n4. Об'єднайте нижню та верхню оболонки.\n\nЧасова Складність: O(N log N), де домінує сортування.",
            "algorithm_steps": "1. Відсортуйте точки за x, потім за y.\n2. Ітеруйте через точки, щоб побудувати стек Нижньої Оболонки. Підтримуйте властивість 'повороту проти годинникової стрілки', використовуючи Векторний Добуток.\n3. Ітеруйте через точки конкретно для побудови стека Верхньої Оболонки.\n4. Видаліть дублікати початкових/кінцевих точок і поверніть унікальні точки."
        }
    },
    "code": {
        "javascript": {
            "solution": "function outerTrees(trees) {\n    trees.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n    \n    const crossProduct = (o, a, b) => \n        (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n        \n    const lower = [];\n    for (const p of trees) {\n        while (lower.length >= 2 && crossProduct(lower[lower.length-2], lower[lower.length-1], p) < 0) {\n            lower.pop();\n        }\n        lower.push(p);\n    }\n    \n    const upper = [];\n    for (let i = trees.length - 1; i >= 0; i--) {\n        const p = trees[i];\n        while (upper.length >= 2 && crossProduct(upper[upper.length-2], upper[upper.length-1], p) < 0) {\n            upper.pop();\n        }\n        upper.push(p);\n    }\n    \n    return [...new Set([...lower, ...upper])];\n}"
        }
    },
    "complexity": {
        "time": "O(N log N)",
        "space": "O(N)",
        "explanation_time": "Сортування займає O(N log N). Побудова оболонки є лінійною O(N).",
        "explanation_space": "Ми зберігаємо точки оболонки в стеку/списку, що займає O(N) простору."
    }
}