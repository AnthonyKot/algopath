{
    "id": "design-4",
    "title": "Лічильник Хітів",
    "difficulty": "Hard",
    "leetcode_url": "https://leetcode.com/problems/design-hit-counter/",
    "related": [
        {
            "id": "design-2",
            "title": "Design Twitter",
            "category": "design"
        },
        {
            "id": "design-1",
            "title": "LRU Cache",
            "category": "design"
        }
    ],
    "tags": [
        "design",
        "sliding-window",
        "circular-buffer"
    ],
    "follow_up": {
        "scenario": "У вас кілька серверів додатків. Хіти надходять на всі з них.",
        "trade_off": "Локальні лічильники швидкі, але не показують глобальний стан. Центральний Redis є вузьким місцем.",
        "strategy": "Агрегуйте локально протягом 1 секунди, потім надсилайте суму до центрального Redis/Service. Точність обмінюється на масштабованість (узгодженість у кінцевому рахунку).",
        "answering_guide": "Підкресліть компроміс між Узгодженістю та Доступністю (CAP). <strong>'Локальна Агрегація'</strong> (буферизація) тут є виграшною стратегією."
    },
    "content": {
        "problem_statement": "Проектуйте лічильник хітів, який підраховує кількість звернень (хітів), отриманих за останні `5` хвилин (тобто за останні `300` секунд).\n\nВаша система повинна приймати параметр `timestamp` (у секундах), і ви можете вважати, що виклики здійснюються до системи в хронологічному порядку (тобто `timestamp` монотонно зростає). Кілька хітів можуть надходити приблизно в один і той же час.\n\nРеалізуйте клас `HitCounter`:\n*   `HitCounter()` Ініціалізує об'єкт системи лічильника хітів.\n*   `void hit(int timestamp)` Записує хіт, що стався в момент `timestamp`.\n*   `int getHits(int timestamp)` Повертає кількість хітів за останні 5 хвилин від `timestamp` (тобто за останні `300` секунд).\n\n**Приклад 1:**\n```\nInput\n[\"HitCounter\", \"hit\", \"hit\", \"hit\", \"getHits\", \"hit\", \"getHits\", \"getHits\"]\n[[], [1], [2], [3], [4], [300], [300], [301]]\nOutput\n[null, null, null, null, 3, null, 4, 3]\n```",
        "explanation": {
            "understanding_the_problem": "Нам потрібно підраховувати події в межах змінного вікна часу. Ключовими обмеженнями є фіксований розмір вікна (300 секунд) і потенційно дуже велика кількість хітів, що робить недоцільним зберігання кожного окремого хіта.",
            "brute_force": "Просте, але немасштабоване рішення полягає в збереженні списку часових міток для кожного хіта. Коли викликається `getHits`, ми б перебирали список, видаляли часові мітки старіші за 300 секунд і повертали б розмір списку. Це було б повільно і споживало б необмежену пам'ять.",
            "bottleneck": "Зберігання кожної часової мітки хіта призводить до необмеженого використання пам'яті та повільних викликів `getHits`, якщо частота хітів висока.",
            "optimized_approach": "Підхід **Сегментування (Bucketing)** або **Циклічного Масиву** є ідеальним. Оскільки часове вікно фіксоване, ми можемо використати масив із 300 'кошиків', де кожен кошик рахує хіти для певної секунди. Ми використовуємо часову мітку за модулем 300, щоб зіставити час з індексом кошика.\n\nЩоб обробити той факт, що кошик `i` може представляти секунду `i`, `i+300`, `i+600` і т.д., нам потрібно зберігати часову мітку разом із кількістю. Коли ми звертаємося до кошика, ми перевіряємо, чи збігається його збережена часова мітка з поточною секундою. Якщо ні, це старий кошик, який ми можемо скинути.",
            "algorithm_steps": "1.  **Структури Даних:**\n    - `hits[300]`: Масив для зберігання кількості хітів.\n    - `timestamps[300]`: Паралельний масив для зберігання часової мітки, що відповідає кожному кошику.\n\n2.  **`hit(timestamp)`:**\n    a.  Обчисліть індекс кошика: `idx = timestamp % 300`.\n    b.  Якщо `timestamps[idx]` збігається з поточним `timestamp`, просто збільште `hits[idx]`.\n    c.  Якщо ні, це застарілий кошик. Скиньте його: `timestamps[idx] = timestamp` і `hits[idx] = 1`.\n\n3.  **`getHits(timestamp)`:**\n    a.  Ініціалізуйте `total = 0`.\n    b.  Проітеруйте через усі 300 кошиків.\n    c.  Для кожного кошика `i`, якщо `timestamp - timestamps[i] < 300`, додайте `hits[i]` до `total`.\n    d.  Поверніть `total`."
        },
        "quizzes": [
            {
                "question": "Яка оптимальна структура даних для цього?",
                "options": [
                    "LinkedList",
                    "Циклічний Буфер (Кошики)",
                    "Великий Масив",
                    "BST"
                ],
                "correct": 1
            },
            {
                "question": "Чому не зберігати кожну часову мітку?",
                "options": [
                    "Забагато пам'яті/повільний запит",
                    "Не точно",
                    "Важко реалізувати",
                    "Переповнення цілого числа"
                ],
                "correct": 0
            },
            {
                "question": "Який розмір масиву потрібен?",
                "options": [
                    "Необмежений",
                    "60",
                    "300",
                    "86400"
                ],
                "correct": 2
            },
            {
                "question": "Як ми обробляємо одночасні хіти?",
                "options": [
                    "Блокування/Атомарний інкремент",
                    "Ігнорувати стан гонки",
                    "Використовувати окремі масиви",
                    "Затримати запис"
                ],
                "correct": 0
            },
            {
                "question": "Як ми обробляємо застарілі кошики?",
                "options": [
                    "Видалити їх",
                    "Скинути значення при повторному використанні індексу",
                    "Зсунути весь масив",
                    "Використовувати збір сміття"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "class HitCounter {\n  constructor() {\n    this.times = new Array(300).fill(0);\n    this.hits = new Array(300).fill(0);\n  }\n  \n  hit(timestamp) {\n    const idx = timestamp % 300;\n    if (this.times[idx] !== timestamp) {\n      this.times[idx] = timestamp;\n      this.hits[idx] = 1;\n    } else {\n      this.hits[idx]++;\n    }\n  }\n  \n  getHits(timestamp) {\n    let totalHits = 0;\n    for (let i = 0; i < 300; i++) {\n      if (timestamp - this.times[i] < 300) {\n        totalHits += this.hits[i];\n      }\n    }\n    return totalHits;\n  }\n}",
            "annotations": [
                {
                    "lines": [
                        2,
                        3
                    ],
                    "text": "Циклічний Буфер: Фіксований розмір 300 для 5-хвилинного вікна. Економить місце порівняно зі зберіганням усіх часових міток."
                },
                {
                    "lines": [
                        7,
                        8
                    ],
                    "text": "Відображення індексу: Modulo 300 відображає невизначений час на фіксовані кошики."
                },
                {
                    "lines": [
                        9
                    ],
                    "text": "Скидання: Якщо часова мітка кошика стара, він належить до попереднього циклу. Перезаписати його."
                },
                {
                    "lines": [
                        18
                    ],
                    "text": "Сума: Агрегувати хіти лише з кошиків, що потрапляють у вікно останніх 300 с."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(1)",
        "space": "O(1)",
        "explanation_time": "`hit` виконується за O(1). `getHits` вимагає ітерації по масиву фіксованого розміру з 300 елементів, що є постійним обсягом роботи, тому це також O(1).",
        "explanation_space": "Ми використовуємо два масиви фіксованого розміру (300), що є постійним простором, O(1)."
    }
}