{
    "id": "design-3",
    "title": "Система Автозаповнення Пошуку",
    "difficulty": "Hard",
    "leetcode_url": "https://leetcode.com/problems/design-search-autocomplete-system/",
    "related": [
        {
            "id": "design-5",
            "title": "Design Add and Search Words",
            "category": "design"
        },
        {
            "id": "design-2",
            "title": "Design Twitter",
            "category": "design"
        }
    ],
    "tags": [
        "design",
        "trie",
        "heap"
    ],
    "follow_up": {
        "scenario": "Трай (Trie) занадто великий (100 ГБ), щоб поміститися в оперативну пам'ять однієї машини.",
        "trade_off": "Зберігання на диску додає затримку. Шардинг за префіксом ускладнює систему.",
        "strategy": "Шардинг за префіксом (наприклад, A-M на Сервері 1). Зберігайте лише топ-k гарячих запитів в оперативній пам'яті; тримайте повний хвіст на диску (SSD) або використовуйте розподілене сховище KV.",
        "answering_guide": "Зосередьтеся на розподілі даних. <strong>'Шардинг за префіксом'</strong> є ключовою фразою. Також згадайте про <strong>'Розділення гарячих і холодних (Hot vs. Cold) даних'</strong>, щоб показати розуміння оптимізації."
    },
    "content": {
        "problem_statement": "Проектуйте систему автозаповнення пошуку для пошукової системи. Користувачі можуть вводити речення (щонайменше одне слово і закінчуватися спеціальним символом `'#'`).\n\nДля кожного символу, який вони вводять, окрім `'#'`, ви повертаєте **топ 3 історично гарячих речень**, які мають префікс такий же, як частина речення, що вже введена. Ось конкретні правила:\n\n1.  Ступінь популярності (hot degree) для речення визначається як кількість разів, коли користувач вводив точно таке ж речення раніше.\n2.  Повернуті 3 найкращі гарячі речення повинні бути відсортовані за ступенем популярності (першим йде найгарячіше). Якщо кілька речень мають однаковий ступінь популярності, вам потрібно використовувати порядок ASCII-коду (менший з'являється першим).\n3.  Якщо існує менше 3 гарячих речень, поверніть стільки, скільки є.\n4.  Коли вхід є спеціальним символом, це означає, що речення закінчується, і в цьому випадку вам потрібно повернути порожній список.\n\n**Приклад 1:**\n```\nInput\n[\"AutocompleteSystem\", \"input\", \"input\", \"input\", \"input\"]\n[[[\"i love you\", \"island\", \"ironman\", \"i love leetcode\"], [5, 3, 2, 2]], [\"i\"], [\" \"], [\"a\"], [\"#\"]]\nOutput\n[null, [\"i love you\", \"island\", \"i love leetcode\"], [\"i love you\", \"i love leetcode\"], [], []]\n```",
        "explanation": {
            "understanding_the_problem": "Нам потрібно виконувати пошук на основі префіксів і повертати ранжований список результатів. Це класичне застосування **Бору (Trie/Prefix Tree)**.",
            "brute_force": "Наївний підхід полягав би в ітерації через усі відомі речення кожного разу, коли користувач вводить символ, перевірці, чи починається ежне речення з поточного префікса, а потім сортуванні всіх збігів, щоб знайти топ-3. Це було б надзвичайно повільно.",
            "bottleneck": "Сканування всього списку речень для кожного натискання клавіші є явним вузьким місцем.",
            "optimized_approach": "**Бор (Trie)** — ідеальна структура даних. Кожен вузол представляє символ, а шлях від кореня до вузла представляє префікс. Ключ у тому, що ми зберігаємо у вузлах.\n\nКожен вузол у нашому Борі буде зберігати карту або список усіх повних речень, які проходять через нього, разом з їхніми балами популярності. Коли користувач вводить префікс, ми проходимо по Бору до вузла, що відповідає цьому префіксу. Тоді нам потрібно лише відсортувати речення, що зберігаються в цьому конкретному вузлі, що є набагато меншим набором, ніж усі речення.",
            "algorithm_steps": "1.  **Структура Вузла Бору:** Кожен вузол містить вказівники `children` та карту `sentences` (`sentence -> hotness`).\n2.  **Конструктор:** Побудуйте початковий Бор із заданих речень. Для кожного речення пройдіть по Бору, створюючи вузли за потреби. На кожному вузлі вздовж шляху додайте речення та його бал популярності до карти `sentences` цього вузла.\n3.  **`input(c)`:**\n    a.  Якщо `c == '#'`, користувач закінчив введення. Додайте поточне речення до наших даних (і оновіть його популярність у всіх відповідних вузлах Бору). Скиньте стан.\n    b.  В іншому випадку додайте `c` до поточного префікса і перейдіть до наступного вузла в Борі.\n    c.  Отримайте карту `sentences` з поточного вузла.\n    d.  Відсортуйте елементи в карті на основі популярності (спадання) та лексикографічно (зростання).\n    e.  Поверніть топ-3."
        },
        "quizzes": [
            {
                "question": "Яка основна структура даних використовується?",
                "options": [
                    "Хеш-таблиця",
                    "Бор (Trie)",
                    "Двійкове дерево пошуку",
                    "Зв'язний список"
                ],
                "correct": 1
            },
            {
                "question": "Де ми зберігаємо 'гарячі' речення?",
                "options": [
                    "Тільки в листах",
                    "У кожному вузлі шляху",
                    "В окремій базі даних",
                    "Тільки в корені"
                ],
                "correct": 1
            },
            {
                "question": "Як ми обробляємо символ '#'?",
                "options": [
                    "Ігноруємо його",
                    "Він позначає кінець речення (commit)",
                    "Це символ підстановки",
                    "Він видаляє останній символ"
                ],
                "correct": 1
            },
            {
                "question": "Що оптимізує запит 'топ 3'?",
                "options": [
                    "Сортування всіх речень щоразу",
                    "Зберігання невеликого відсортованого списку в кожному вузлі",
                    "Використання глобальної купи",
                    "Бінарний пошук"
                ],
                "correct": 1
            },
            {
                "question": "Що відбувається, якщо два речення мають однакову популярність?",
                "options": [
                    "Випадковий порядок",
                    "Лексикографічний (ASCII) порядок",
                    "Найновіше першим",
                    "Найстаріше першим"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "class AutocompleteSystem {\n  constructor(sentences, times) {\n    this.root = {};\n    this.currentNode = this.root;\n    this.currentSentence = '';\n    \n    for (let i = 0; i < sentences.length; i++) {\n      this.addSentence(sentences[i], times[i]);\n    }\n  }\n  \n  addSentence(sentence, count) {\n    let node = this.root;\n    for (const char of sentence) {\n      if (!node[char]) node[char] = {};\n      node = node[char];\n      if (!node.sentences) node.sentences = new Map();\n      node.sentences.set(sentence, (node.sentences.get(sentence) || 0) + count);\n    }\n  }\n  \n  input(c) {\n    if (c === '#') {\n      this.addSentence(this.currentSentence, 1);\n      this.currentSentence = '';\n      this.currentNode = this.root;\n      return [];\n    }\n    \n    this.currentSentence += c;\n    if (!this.currentNode || !this.currentNode[c]) {\n      this.currentNode = null;\n      return [];\n    }\n    \n    this.currentNode = this.currentNode[c];\n    const candidates = Array.from(this.currentNode.sentences.entries());\n    candidates.sort((a, b) => {\n      if (a[1] !== b[1]) return b[1] - a[1];\n      return a[0].localeCompare(b[0]);\n    });\n    \n    return candidates.slice(0, 3).map(item => item[0]);\n  }\n}",
            "annotations": [
                {
                    "lines": [
                        2,
                        10
                    ],
                    "text": "Структура Trie: Кореневий вузол зберігає дочірні символи та карту повних речень, що проходять через нього."
                },
                {
                    "lines": [
                        13
                    ],
                    "text": "Карта Популярності: Кожен вузол зберігає {речення: частота} для всіх слів у його піддереві."
                },
                {
                    "lines": [
                        32
                    ],
                    "text": "Обхід: Слідуйте шляхом вниз по Trie на основі введених символів."
                },
                {
                    "lines": [
                        40
                    ],
                    "text": "Ранжування: Сортуйте кандидатів на рівні вузла з постійним часом доступу."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(S*L + P + C*logC)",
        "space": "O(S*L)",
        "explanation_time": "Нехай S — кількість речень, L — їх середня довжина, P — довжина префікса, а C — кількість кандидатів для префікса. Час побудови становить O(S*L). Кожен ввід займає O(P) для проходження по Trie, потім O(C log C) для сортування кандидатів.",
        "explanation_space": "Простір домінує Бор (Trie), який у найгіршому випадку зберігає кожен символ кожного речення, що призводить до простору O(S*L)."
    }
}