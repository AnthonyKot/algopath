{
    "id": "design-1",
    "title": "LRU Кеш",
    "difficulty": "Hard",
    "leetcode_url": "https://leetcode.com/problems/lru-cache/",
    "related": [
        {
            "id": "design-4",
            "title": "Design Hit Counter",
            "category": "design"
        },
        {
            "id": "design-5",
            "title": "Design Add and Search Words",
            "category": "design"
        }
    ],
    "tags": [
        "design",
        "hash-table",
        "doubly-linked-list"
    ],
    "follow_up": {
        "scenario": "Ваш кеш використовується 1000 одночасними потоками. Глобальне блокування є вузьким місцем.",
        "trade_off": "Шардинг кешу (сегменти) зменшує конкуренцію, але наближує точність LRU глобально (не ідеально).",
        "strategy": "Використовуйте `ConcurrentHashMap` з сегментованими блокуваннями (як у Java 7) або алгоритм годинника (Second Chance), щоб уникнути повного блокування.",
        "answering_guide": "Негайно визнайте проблему конкуренції за блокування. Пропозиція <strong>'сегментації' (шардингу)</strong> є стандартним ходом рівня L5. Згадка про <strong>'Алгоритм Годинника'</strong> демонструє глибину знань."
    },
    "content": {
        "problem_statement": "Проектуйте структуру даних, яка відповідає обмеженням **[Кешу Найменш Нещодавно Використаних (LRU)](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU)**.\n\nРеалізуйте клас `LRUCache`:\n*   `LRUCache(int capacity)` Ініціалізує LRU кеш з позитивним розміром `capacity`.\n*   `int get(int key)` Повертає значення `key`, якщо ключ існує, інакше повертає `-1`.\n*   `void put(int key, int value)` Оновлює значення `key`, якщо `key` існує. В іншому випадку додає пару `key-value` до кешу. Якщо кількість ключів перевищує `capacity` після цієї операції, **видаліть** найменш нещодавно використаний ключ.\n\nФункції `get` і `put` повинні виконуватися за `O(1)` середнього часу.\n\n**Приклад 1:**\n```\nInput\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n```",
        "explanation": {
            "understanding_the_problem": "Нам потрібна структура даних, яка може зберігати пари ключ-значення до певної місткості `capacity`. Коли ми отримуємо доступ до елемента або додаємо його, він стає 'найбільш нещодавно використаним'. Коли нам потрібно звільнити місце, ми видаляємо 'найменш нещодавно використаний' елемент. Всі операції повинні бути дуже швидкими (O(1)).",
            "brute_force": "Проста хеш-карта дає O(1) для `get` і `put`, але вона не відстежує порядок використання. Зв'язний список може відстежувати порядок (переміщуючи вузли на початок), але `get` займе O(N), щоб знайти елемент. Нам потрібно поєднати сильні сторони обох.",
            "bottleneck": "Жодна стандартна структура даних не забезпечує одночасно пошук за ключем O(1) і впорядкування O(1). Завдання полягає в тому, щоб пов'язати ці дві можливості.",
            "optimized_approach": "Оптимальне рішення поєднує **Хеш-карту** та **Двозв'язний список**.\n\n- **Хеш-карта** зберігає ключі та зіставляє їх з вузлами у зв'язному списку (`key -> Node`). Це дає нам пошук O(1).\n- **Двозв'язний список** зберігає фактичні пари ключ-значення у своїх вузлах і підтримує порядок використання. Голова списку - це найбільш нещодавно використаний елемент, а хвіст - найменш нещодавно використаний. Двозв'язний список є вирішальним, оскільки він дозволяє видалення будь-якого вузла за O(1), *якщо ми маємо прямий вказівник на нього* (який надає хеш-карта).",
            "algorithm_steps": "1.  **`get(key)`:**\n    a.  Пошук ключа в хеш-карті. Якщо його не існує, повернути -1.\n    b.  Якщо він існує, ми отримуємо прямий вказівник на вузол зв'язного списку. Перемістіть цей вузол на початок списку, щоб позначити його як найбільш нещодавно використаний.\n    c.  Поверніть значення вузла.\n\n2.  **`put(key, value)`:**\n    a.  Перевірте, чи існує ключ у карті.\n    b.  Якщо так, оновіть значення вузла та перемістіть його на початок списку.\n    c.  Якщо ні, створіть новий вузол. Якщо кеш переповнений, видаліть хвіст списку та видаліть його ключ із хеш-карти. Потім додайте новий вузол на початок списку та додайте його пару `(key, node)` до карти."
        },
        "quizzes": [
            {
                "question": "Яка комбінація структур даних є оптимальною?",
                "options": [
                    "Масив + Список",
                    "HashMap + Двозв'язний список",
                    "Стек + Черга",
                    "Дві купи"
                ],
                "correct": 1
            },
            {
                "question": "Чому потрібен двозв'язний список?",
                "options": [
                    "Для сортування ключів",
                    "O(1) видалення будь-якого вузла за вказівником",
                    "Менше пам'яті",
                    "Для обробки колізій"
                ],
                "correct": 1
            },
            {
                "question": "Який елемент видаляється при переповненні?",
                "options": [
                    "Голова (Most Recently Used)",
                    "Хвіст (Least Recently Used)",
                    "Випадковий",
                    "Середній"
                ],
                "correct": 1
            },
            {
                "question": "Яка складність put/get?",
                "options": [
                    "O(1)",
                    "O(log N)",
                    "O(N)",
                    "O(N log N)"
                ],
                "correct": 0
            },
            {
                "question": "Навіщо використовувати фіктивні (dummy) вузли голови/хвоста?",
                "options": [
                    "Вимога мови",
                    "Уникнення перевірок на null/граничних випадків",
                    "Зберігання метаданих",
                    "Збільшення місткості"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n    this.head = { key: 0, val: 0 };\n    this.tail = { key: 0, val: 0 };\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n  \n  addNode(node) {\n    node.prev = this.head;\n    node.next = this.head.next;\n    this.head.next.prev = node;\n    this.head.next = node;\n  }\n  \n  removeNode(node) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n  }\n  \n  moveToHead(node) {\n    this.removeNode(node);\n    this.addNode(node);\n  }\n  \n  popTail() {\n    const last = this.tail.prev;\n    this.removeNode(last);\n    return last;\n  }\n  \n  get(key) {\n    const node = this.cache.get(key);\n    if (node) {\n      this.moveToHead(node);\n      return node.val;\n    }\n    return -1;\n  }\n  \n  put(key, value) {\n    const node = this.cache.get(key);\n    if (node) {\n      node.val = value;\n      this.moveToHead(node);\n    } else {\n      const newNode = { key, val: value };\n      if (this.cache.size >= this.capacity) {\n        const tail = this.popTail();\n        this.cache.delete(tail.key);\n      }\n      this.cache.set(key, newNode);\n      this.addNode(newNode);\n    }\n  }\n}",
            "annotations": [
                {
                    "lines": [
                        6,
                        7
                    ],
                    "text": "Вартові вузли (Sentinel Nodes): Фіктивні голова і хвіст спрощують логіку додавання/видалення (без перевірок на null)."
                },
                {
                    "lines": [
                        11,
                        12
                    ],
                    "text": "Add Node: Завжди додавати на початок (відразу після голови). Найбільш нещодавно використаний."
                },
                {
                    "lines": [
                        23
                    ],
                    "text": "Pop Tail: Видалити з кінця (відразу перед хвостом). Найменш нещодавно використаний."
                },
                {
                    "lines": [
                        30
                    ],
                    "text": "Get: Якщо знайдено, перемістити на початок, щоб оновити статус 'нещодавно використаного'."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(1)",
        "space": "O(capacity)",
        "explanation_time": "Всі операції `get` та `put` включають пошук/вставку в хеш-карту (O(1)) та кілька перепризначень вказівників у двозв'язному списку (O(1)).",
        "explanation_space": "Хеш-карта та зв'язний список зберігають до `capacity` кількості елементів."
    }
}