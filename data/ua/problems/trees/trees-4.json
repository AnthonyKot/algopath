{
    "id": "trees-4",
    "title": "Додавання на Діапазоні, Сума Діапазону (Ліниве Поширення)",
    "difficulty": "Середній",
    "related": [
        {
            "id": "trees-1",
            "title": "Segment Tree",
            "category": "trees"
        },
        {
            "id": "trees-5",
            "title": "Fenwick Tree",
            "category": "trees"
        }
    ],
    "tags": [
        "segment-tree",
        "lazy-propagation"
    ],
    "follow_up": {
        "scenario": "Оновлення діапазону в реєстрі високочастотної торгівлі (мільйони рядків).",
        "trade_off": "Оновлення кожного листового вузла займає O(N), що занадто повільно для потоків у реальному часі.",
        "strategy": "Ліниве поширення. Відкладіть оновлення для дітей, поки це не стане абсолютно необхідним (під час запиту або подальшого оновлення).",
        "answering_guide": "Ключове слово - <strong>'Відкладене Виконання (Deferred Execution)'</strong>. Поясніть, що ми обмінюємо трохи складнішу логіку на масивний приріст <strong>'Швидкості Запису'</strong> шляхом кешування оновлень."
    },
    "content": {
        "problem_statement": "У вас є масив цілих чисел `nums`. Вам потрібно ефективно обробляти декілька запитів наступних типів:\n\n1.  **Range Add**: Додати значення `val` до всіх елементів `nums[i]`, де `left <= i <= right`.\n2.  **Range Sum**: Обчислити суму елементів `nums[i]`, де `left <= i <= right`.\n\nРеалізуйте клас `LazySegmentTree`:\n*   `LazySegmentTree(int[] nums)` Ініціалізує з `nums`.\n*   `void rangeAdd(int left, int right, int val)` Додає `val` до підмасиву `nums[left...right]`.\n*   `int rangeSum(int left, int right)` Повертає суму підмасиву `nums[left...right]`.\n\n**Приклад 1:**\n```\nInput\n[\"LazySegmentTree\", \"rangeAdd\", \"rangeSum\", \"rangeAdd\", \"rangeSum\"]\n[[[1, 1, 1, 1, 1]], [0, 4, 1], [0, 4], [2, 3, 10], [0, 4]]\nOutput\n[null, null, 10, null, 30]\nExplanation\n// nums починається як [1, 1, 1, 1, 1]\n// rangeAdd(0, 4, 1) -> nums стає [2, 2, 2, 2, 2]\n// rangeSum(0, 4) -> 10\n// rangeAdd(2, 3, 10) -> nums стає [2, 2, 12, 12, 2]\n// rangeSum(0, 4) -> 30\n```",
        "explanation": {
            "understanding_the_problem": "Стандартне дерево відрізків може обробляти точкові оновлення та запити діапазону за час O(log N). Однак, якщо ми спробуємо використати його для оновлення діапазону, нам доведеться оновити кожен лист у діапазоні, що може зайняти O(N log N) часу. Нам потрібен спосіб зробити оновлення діапазону ефективними.",
            "brute_force": "Вузьким місцем є застосування оновлень до великого діапазону. Ключовою ідеєю для вирішення цієї проблеми є **Ліниве Поширення (Lazy Propagation)**. Замість того, щоб негайно застосовувати оновлення до всіх уражених дітей у дереві, ми будемо 'лінивими'. Ми оновимо вузол високого рівня, який покриває велику частину діапазону, і залишимо 'примітку' (лінивий тег) на ньому. Ця примітка означає, що всі його діти потребують цього оновлення згодом.",
            "bottleneck": "Без лінивого поширення одне оновлення діапазону, що охоплює більшу частину масиву, було б еквівалентним виконанню N точкових оновлень, що зводить нанівець логарифмічну продуктивність дерева відрізків.",
            "optimized_approach": "Ми додаємо масив `lazy` паралельно нашому масиву `tree`. `lazy[node]` зберігає відкладене оновлення для інтервалу цього вузла.\n\n- **Під час `rangeAdd`:** Коли ми знаходимо вузол, що повністю міститься в діапазоні оновлення, ми оновлюємо його `sum` і додаємо до його `lazy` тегу. Ми не спускаємося до його дітей.\n- **Під час `rangeSum` (або будь-якого обходу):** Перш ніж отримати доступ до дітей вузла, ми повинні спочатку перевірити, чи має вузол лінивий тег. Якщо так, ми 'проштовхуємо' оновлення вниз до його дітей, оновлюючи їхні значення `sum` та `lazy`. Потім ми очищаємо лінивий тег поточного вузла.\n\nЦя операція `pushDown` гарантує, що оновлення поширюються правильно і лише тоді, коли це необхідно, підтримуючи продуктивність O(log N) для всіх операцій.",
            "algorithm_steps": "1.  **Структури Даних:** Розширте стандартне Дерево Відрізків масивом `lazy` того ж розміру, ініціалізованим нулями.\n\n2.  **Функція `pushDown(node, ...)`:** Це ядро техніки. Вона застосовує значення `lazy[node]` до полів `sum` та `lazy` двох своїх дітей, а потім скидає `lazy[node]` на 0.\n\n3.  **Функція `rangeAdd(l, r, val)`:**\n    a.  Слідує стандартному обходу дерева відрізків.\n    b.  Перш ніж рекурсувати до дітей, вона викликає `pushDown` на поточному вузлі.\n    c.  Якщо вузол повністю міститься в діапазоні оновлення, оновіть його `sum` та `lazy` тег і поверніться.\n    d.  На зворотному шляху рекурсії оновіть суми батьків на основі їхніх дітей.\n\n4.  **Функція `rangeSum(l, r)`:**\n    a.  Слідує стандартній логіці запиту дерева відрізків.\n    b.  Важливо: перед рекурсією до дітей, вона викликає `pushDown` на поточному вузлі, щоб переконатися, що його інформація актуальна."
        },
        "quizzes": [
            {
                "question": "Що таке 'ліниве поширення'?",
                "options": [
                    "Повільні оновлення",
                    "Відкладення оновлень для дітей, поки не знадобиться",
                    "Пропуск вузлів",
                    "Паралельна обробка"
                ],
                "correct": 1
            },
            {
                "question": "Коли ми 'проштовхуємо' (push down) ліниві значення?",
                "options": [
                    "Ніколи",
                    "Перед доступом до дітей",
                    "Після запиту",
                    "Тільки при оновленні"
                ],
                "correct": 1
            },
            {
                "question": "Навіщо використовувати ліниве поширення для оновлень діапазону?",
                "options": [
                    "Простіший код",
                    "Уникнення оновлення всіх N елементів",
                    "Краще кешування",
                    "Менше пам'яті"
                ],
                "correct": 1
            },
            {
                "question": "Що зберігає лінивий масив?",
                "options": [
                    "Фінальні значення",
                    "Очікувані додавання для дітей",
                    "Індекси вузлів",
                    "Хеш-коди"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність на операцію?",
                "options": [
                    "O(N)",
                    "O(1)",
                    "O(log N)",
                    "O(N log N)"
                ],
                "correct": 2
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "class LazySegmentTree {\n  constructor(arr) {\n    this.n = arr.length;\n    this.tree = new Array(4 * this.n).fill(0);\n    this.lazy = new Array(4 * this.n).fill(0);\n    this.build(1, 0, this.n - 1, arr);\n  }\n  build(node, l, r, arr) {\n    if (l === r) this.tree[node] = arr[l];\n    else {\n      const mid = Math.floor((l + r) / 2);\n      this.build(node*2, l, mid, arr);\n      this.build(node*2+1, mid+1, r, arr);\n      this.tree[node] = this.tree[node*2] + this.tree[node*2+1];\n    }\n  }\n  apply(node, l, r, val) {\n    this.tree[node] += val * (r - l + 1);\n    this.lazy[node] += val;\n  }\n  push(node, l, r) {\n    if (this.lazy[node] !== 0) {\n      const mid = Math.floor((l + r) / 2);\n      this.apply(node*2, l, mid, this.lazy[node]);\n      this.apply(node*2+1, mid+1, r, this.lazy[node]);\n      this.lazy[node] = 0;\n    }\n  }\n  rangeAdd(qL, qR, val, node=1, l=0, r=this.n-1) {\n    if (qL > r || qR < l) return;\n    if (qL <= l && r <= qR) {\n      this.apply(node, l, r, val);\n      return;\n    }\n    this.push(node, l, r);\n    const mid = Math.floor((l + r) / 2);\n    this.rangeAdd(qL, qR, val, node*2, l, mid);\n    this.rangeAdd(qL, qR, val, node*2+1, mid+1, r);\n    this.tree[node] = this.tree[node*2] + this.tree[node*2+1];\n  }\n  rangeSum(qL, qR, node=1, l=0, r=this.n-1) {\n    if (qL > r || qR < l) return 0;\n    if (qL <= l && r <= qR) return this.tree[node];\n    this.push(node, l, r);\n    const mid = Math.floor((l + r) / 2);\n    return this.rangeSum(qL, qR, node*2, l, mid) +\n           this.rangeSum(qL, qR, node*2+1, mid+1, r);\n  }\n}",
            "annotations": [
                {
                    "lines": [
                        5
                    ],
                    "text": "Лінивий масив: зберігає очікувані додавання для дітей."
                },
                {
                    "lines": [
                        17,
                        18
                    ],
                    "text": "Apply: Оновити суму вузла ТА додати до його лінивого тегу."
                },
                {
                    "lines": [
                        21
                    ],
                    "text": "Push: Поширити ліниве значення до дітей лише коли це необхідно."
                },
                {
                    "lines": [
                        23,
                        24
                    ],
                    "text": "Оновити дітей та скинути поточний лінивий тег на 0."
                },
                {
                    "lines": [
                        31
                    ],
                    "text": "Range Add: Якщо повністю покрито, оновити вузол та лінивий тег, потім СТОП. Не рекурсувати."
                },
                {
                    "lines": [
                        34
                    ],
                    "text": "Важливо: Проштовхнути очікувані оновлення перед рекурсією."
                },
                {
                    "lines": [
                        47
                    ],
                    "text": "Запит: Проштовхнути перед перевіркою дітей, щоб забезпечити свіжі дані."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(log N) на операцію",
        "space": "O(N)",
        "explanation_time": "Завдяки лінивому поширенню оновлення діапазону більше не потребують торкання кожного вузла в діапазоні. Обидві операції `rangeAdd` та `rangeSum` потребують лише проходження логарифмічної кількості вузлів вниз по дереву. Це дає їм амортизовану часову складність O(log N).",
        "explanation_space": "Нам потрібен масив для самого дерева (O(N)) та додатковий масив того ж розміру для лінивих тегів (O(N)). Це призводить до загальної просторової складності O(N)."
    }
}