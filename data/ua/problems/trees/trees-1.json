{
    "id": "trees-1",
    "title": "Запити Суми Діапазону (Дерево Відрізків)",
    "difficulty": "Середній",
    "leetcode_url": "https://leetcode.com/problems/range-sum-query-mutable/",
    "related": [
        {
            "id": "trees-4",
            "title": "Lazy Propagation",
            "category": "trees"
        },
        {
            "id": "trees-5",
            "title": "Fenwick Tree",
            "category": "trees"
        }
    ],
    "tags": [
        "segment-tree",
        "data-structures"
    ],
    "content": {
        "problem_statement": "Дано цілочисельний масив `nums`, обробіть декілька запитів наступних типів:\n\n1.  **Update**: Оновити значення елемента в `nums`.\n2.  **Sum Range**: Обчислити суму елементів `nums` між індексами `left` та `right` **включно**, де `left <= right`.\n\nРеалізуйте клас `SegmentTree`:\n*   `SegmentTree(int[] nums)` Ініціалізує об'єкт цілочисельним масивом `nums`.\n*   `void update(int index, int val)` Оновлює значення `nums[index]` на `val`.\n*   `int sumRange(int left, int right)` Повертає суму елементів `nums` між індексами `left` та `right` включно (тобто `nums[left] + nums[left + 1] + ... + nums[right]`).\n\n**Приклад 1:**\n```\nInput\n[\"SegmentTree\", \"sumRange\", \"update\", \"sumRange\"]\n[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]\nOutput\n[null, 9, null, 8]\n\nExplanation\nSegmentTree segmentTree = new SegmentTree([1, 3, 5]);\nsegmentTree.sumRange(0, 2); // return 1 + 3 + 5 = 9\nsegmentTree.update(1, 2);   // nums = [1, 2, 5]\nsegmentTree.sumRange(0, 2); // return 1 + 2 + 5 = 8\n```",
        "explanation": {
            "understanding_the_problem": "Наївний підхід з використанням простого масиву дав би нам O(1) для оновлень, але O(N) для запитів суми діапазону, що занадто повільно, якщо у нас багато запитів. Нам потрібна більш просунута структура даних, яка може збалансувати продуктивність обох операцій.",
            "brute_force": "Задача вимагає способу ефективно обробляти запити діапазону. Це ідеальний випадок для використання **Дерева Відрізків (Segment Tree)**. Дерево Відрізків - це бінарне дерево, де кожен вузол представляє інтервал (або відрізок) оригінального масиву.\n\n- **Корінь** представляє весь масив `[0, N-1]`.\n- Кожен **лист** представляє один елемент `[i, i]`.\n- Кожен **внутрішній вузол** зберігає агреговану інформацію (в даному випадку суму) для об'єднання інтервалів його дітей.",
            "bottleneck": "Ключовим є те, що запит для будь-якого діапазону може бути оброблений шляхом комбінування інформації з невеликої кількості попередньо обчислених вузлів у дереві. Аналогічно, оновлення одного елемента вимагає лише оновлення вузлів на шляху від цього листа до кореня.",
            "optimized_approach": "Зберігаючи попередньо обчислені суми у вузлах дерева, Дерево Відрізків дозволяє нам виконувати як точкові оновлення, так і запити суми діапазону за час O(log N).\n\n- **Запит `(l, r)`:** Ми проходимо дерево. Якщо інтервал вузла повністю знаходиться всередині нашого діапазону запиту, ми використовуємо його значення безпосередньо. Якщо він частково перекриваєтся, ми рекурсивно звертаємося до його дітей. Це покриває наш діапазон запиту логарифмічною кількістю вузлів.\n- **Оновлення `(pos, val)`:** Ми знаходимо лист, що відповідає `pos`, і оновлюємо його значення. Потім ми піднімаємося назад до кореня, оновлюючи суму кожного батьківського вузла по дорозі. Це один шлях довжиною O(log N).",
            "algorithm_steps": "1.  **Побудова Дерева:** Ми представляємо дерево за допомогою масиву (розмір `4N` є безпечним). Рекурсивна функція `build(node, start, end)` заповнює дерево. Якщо `start == end`, це лист. Інакше вона рекурсивно будує лівого та правого нащадків і встановлює своє власне значення як їхню суму.\n\n2.  **Операція Оновлення:** Рекурсивна функція `update(node, start, end, pos, val)` знаходить лист, що відповідає `pos`. Вона оновлює значення листа, а потім оновлює суми всіх батьківських вузлів на шляху рекурсії назад до кореня.\n\n3.  **Операція Запиту:** Рекурсивна функція `query(node, start, end, l, r)` знаходить відповідь для діапазону `[l, r]`. \n    - Якщо діапазон вузла знаходиться за межами `[l, r]`, повернути 0.\n    - Якщо діапазон вузла повністю всередині `[l, r]`, повернути значення вузла.\n    - Інакше діапазони частково перекриваються. Повернути суму рекурсивних викликів для лівого та правого нащадків."
        },
        "quizzes": [
            {
                "question": "Які операції ефективно підтримує Дерево Відрізків?",
                "options": [
                    "Тільки точкові запити",
                    "Запити діапазону та точкові оновлення",
                    "Тільки сортування",
                    "Тільки довільний доступ"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність для запиту та оновлення?",
                "options": [
                    "O(N)",
                    "O(1)",
                    "O(log N)",
                    "O(N²)"
                ],
                "correct": 2
            },
            {
                "question": "Що представляє кожен вузол у дереві?",
                "options": [
                    "Один елемент",
                    "Агрегат інтервалу",
                    "Вказівник на нащадка",
                    "Хеш-значення"
                ],
                "correct": 1
            },
            {
                "question": "Як ми обробляємо часткове перекриття під час запиту?",
                "options": [
                    "Пропускаємо вузол",
                    "Рекурсуємо на обох нащадків",
                    "Повертаємо 0",
                    "Використовуємо лінивий тег"
                ],
                "correct": 1
            },
            {
                "question": "Чому використовується розмір масиву 4N для дерева?",
                "options": [
                    "Для відступів",
                    "Безпечна верхня межа для повного бінарного дерева",
                    "Вирівнювання пам'яті",
                    "Швидший доступ"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "class SegmentTree {\n  constructor(arr) {\n    this.n = arr.length;\n    this.tree = new Array(4 * this.n);\n    this.build(1, 0, this.n - 1, arr);\n  }\n  build(node, l, r, arr) {\n    if (l === r) this.tree[node] = arr[l];\n    else {\n      const mid = Math.floor((l + r) / 2);\n      this.build(node * 2, l, mid, arr);\n      this.build(node * 2 + 1, mid + 1, r, arr);\n      this.tree[node] = this.tree[node * 2] + this.tree[node * 2 + 1];\n    }\n  }\n  update(pos, val, node = 1, l = 0, r = this.n - 1) {\n    if (l === r) this.tree[node] = val;\n    else {\n      const mid = Math.floor((l + r) / 2);\n      if (pos <= mid) this.update(pos, val, node * 2, l, mid);\n      else this.update(pos, val, node * 2 + 1, mid + 1, r);\n      this.tree[node] = this.tree[node * 2] + this.tree[node * 2 + 1];\n    }\n  }\n  query(qL, qR, node = 1, l = 0, r = this.n - 1) {\n    if (qL > r || qR < l) return 0;\n    if (qL <= l && r <= qR) return this.tree[node];\n    const mid = Math.floor((l + r) / 2);\n    return this.query(qL, qR, node * 2, l, mid) +\n           this.query(qL, qR, node * 2 + 1, mid + 1, r);\n  }\n}",
            "annotations": [
                {
                    "lines": [
                        4,
                        5
                    ],
                    "text": "Виділяємо масив розміром 4N. Це безпечна верхня межа для дерева відрізків."
                },
                {
                    "lines": [
                        7,
                        8
                    ],
                    "text": "Побудова: Листовий вузол (l == r) містить значення масиву."
                },
                {
                    "lines": [
                        12,
                        13
                    ],
                    "text": "Внутрішній вузол: сума лівого та правого нащадків. Це крок 'об'єднання'."
                },
                {
                    "lines": [
                        16,
                        21
                    ],
                    "text": "Оновлення: знайти лист, оновити його, потім оновити всіх батьків по дорозі вгору."
                },
                {
                    "lines": [
                        25
                    ],
                    "text": "Запит: Діапазон поза межами діапазону вузла -> повернути 0 (нейтральний елемент для суми)."
                },
                {
                    "lines": [
                        26
                    ],
                    "text": "Запит: Діапазон повністю покриває діапазон вузла -> повернути попередньо обчислену відповідь."
                },
                {
                    "lines": [
                        28,
                        29
                    ],
                    "text": "Запит: Часткове перекриття -> рекурсія на обидві сторони та сумування результатів."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(log N) на запит/оновлення",
        "space": "O(N)",
        "explanation_time": "Дерево збалансоване, тому його висота O(log N). Обидві операції `update` та `query` проходять дерево від кореня до листа або набору вузлів, займаючи O(log N) часу. Початкова побудова займає O(N) часу, оскільки вона відвідує кожен вузол один раз.",
        "explanation_space": "Ми використовуємо масив для представлення дерева. Щоб уникнути проблем виходу за межі при індексації, масиву розміром 4*N достатньо для збалансованого бінарного дерева з N листками. Це призводить до O(N) просторової складності."
    }
}