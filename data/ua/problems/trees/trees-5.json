{
    "id": "trees-5",
    "title": "Дерево Фенвіка (Двійкове Індексоване Дерево)",
    "difficulty": "Medium",
    "leetcode_url": "https://leetcode.com/problems/range-sum-query-mutable/",
    "related": [
        {
            "id": "trees-1",
            "title": "Segment Tree",
            "category": "trees"
        },
        {
            "id": "trees-4",
            "title": "Lazy Propagation",
            "category": "trees"
        }
    ],
    "tags": [
        "fenwick-tree",
        "bit",
        "data-structures"
    ],
    "follow_up": {
        "scenario": "Жива таблиця лідерів з мільйонами гравців та постійними оновленнями рахунків.",
        "trade_off": "Дерево відрізків використовує 4N простору (втрати пам'яті). Нам потрібно щось дружнє до кешу.",
        "strategy": "Дерево Фенвіка (BIT). Використовує O(N) простору та покладається на бітові маніпуляції для обходу O(log N). Неявні межі.",
        "answering_guide": "Підкресліть <strong>'Ефективність Простору'</strong> та <strong>'Бітові Маніпуляції'</strong>. Згадка про те, що BIT легше реалізувати (менше рядків коду), ніж Дерево Відрізків, часто вражає."
    },
    "content": {
        "problem_statement": "Дано цілочисельний масив `nums`, обробіть декілька запитів наступних типів:\n\n1.  **Update**: Додати значення `delta` до елемента за індексом `index`.\n2.  **Prefix Sum**: Обчислити суму елементів `nums` між індексами `0` та `index` **включно**.\n\nРеалізуйте клас `FenwickTree`:\n*   `FenwickTree(int n)` Ініціалізує дерево розміром `n+1`.\n*   `void update(int index, int delta)` Додає `delta` до `nums[index]`.\n*   `int query(int index)` Повертає префіксну суму до `index`.\n\n**Приклад 1:**\n```\nInput\n[\"FenwickTree\", \"update\", \"query\", \"update\", \"query\"]\n[[5], [2, 1], [4], [2, 3], [4]]\nOutput\n[null, null, 1, null, 4]\n```",
        "explanation": {
            "understanding_the_problem": "Ця задача вимагає ефективних точкових оновлень та запитів префіксних сум. Стандартне Дерево Відрізків може вирішити це за час O(log N), але Дерево Фенвіка (також відоме як Двійкове Індексоване Дерево або BIT) забезпечує таку ж часову складність, будучи значно простішим у реалізації та вимагаючи менше простору.",
            "brute_force": "Наївний масив дає O(1) для оновлень, але O(N) для префіксних сум. Попередньо обчислений масив префіксних сум дає O(1) для запитів, але O(N) для оновлень. Нам потрібно збалансувати їх, що і робить BIT.",
            "bottleneck": "Основна ідея Дерева Фенвіка полягає в тому, що будь-яку префіксну суму можна обчислити, підсумувавши кілька попередньо обчислених сум піддіапазонів, що не перекриваються. Геніальність структури даних полягає в тому, як вона відображає індекси на ці піддіапазони за допомогою бітових маніпуляцій.",
            "optimized_approach": "BIT використовує масив, де `tree[i]` зберігає суму певного діапазону елементів оригінального масиву. Діапазон, за який відповідає `tree[i]`, визначається молодшим значущим бітом (LSB) `i`.\n\n- **`update(index, delta)`:** Коли значення в `index` змінюється, нам потрібно лише оновити записи `tree`, які включають цей індекс у свій діапазон. Використовуючи бітові маніпуляції (`i += i & -i`), ми можемо 'стрибати' вгору до батьківських діапазонів, які зачіпаються, займаючи O(log N) часу.\n- **`query(index)`:** Щоб отримати префіксну суму, ми робимо навпаки. Ми починаємо з `tree[index]` і додаємо його значення. Потім ми стрибаємо до наступного відповідного піддіапазону (`i -= i & -i`) і додаємо його значення, і так далі. Це також займає O(log N) часу.",
            "algorithm_steps": "Примітка: Дерева Фенвіка зазвичай реалізуються з використанням індексації з 1.\n\n1.  **`update(index, delta)`:**\n    a.  Почніть з `i = index + 1`.\n    b.  Поки `i` знаходиться в межах масиву дерева, додайте `delta` до `tree[i]`.\n    c.  Перейдіть до наступного ураженого індексу, стрибнувши до батьківського діапазону: `i += i & -i`. Вираз `i & -i` виділяє молодший значущий біт.\n\n2.  **`query(index)`:**\n    a.  Почніть з `i = index + 1`.\n    b.  Ініціалізуйте `sum = 0`.\n    c.  Поки `i > 0`, додайте `tree[i]` до `sum`.\n    d.  Перейдіть до наступного піддіапазону, видаливши LSB: `i -= i & -i`.\n    e.  Поверніть `sum`."
        },
        "quizzes": [
            {
                "question": "Яка інша назва Дерева Фенвіка?",
                "options": [
                    "Segment Tree",
                    "Binary Indexed Tree",
                    "AVL Tree",
                    "Red-Black Tree"
                ],
                "correct": 1
            },
            {
                "question": "Яка бітова операція знаходить LSB?",
                "options": [
                    "i | -i",
                    "i ^ -i",
                    "i & -i",
                    "i >> 1"
                ],
                "correct": 2
            },
            {
                "question": "Чому Дерево Фенвіка має індексацію з 1?",
                "options": [
                    "Конвенція",
                    "Трюк з LSB працює правильно",
                    "Швидший доступ",
                    "Менше пам'яті"
                ],
                "correct": 1
            },
            {
                "question": "Яка перевага перед Деревом Відрізків?",
                "options": [
                    "Швидші запити",
                    "Простіший код і менше простору",
                    "Більше операцій",
                    "Краще для рядків"
                ],
                "correct": 1
            },
            {
                "question": "Як отримати суму діапазону [L, R]?",
                "options": [
                    "query(R) + query(L)",
                    "query(R) - query(L-1)",
                    "query(L+R)",
                    "query(R) * query(L)"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "class FenwickTree {\n  constructor(n) {\n    this.n = n;\n    this.tree = new Array(n + 1).fill(0);\n  }\n  update(i, delta) {\n    for (++i; i <= this.n; i += i & -i) {\n      this.tree[i] += delta;\n    }\n  }\n  query(i) {\n    let sum = 0;\n    for (++i; i > 0; i -= i & -i) {\n      sum += this.tree[i];\n    }\n    return sum;\n  }\n  rangeQuery(l, r) {\n    return this.query(r) - (l > 0 ? this.query(l - 1) : 0);\n  }\n}",
            "annotations": [
                {
                    "lines": [
                        4
                    ],
                    "text": "Масив дерева має індексацію з 1 для магії бітових маніпуляцій."
                },
                {
                    "lines": [
                        7
                    ],
                    "text": "Оновлення: Почати з index+1. Цикл до кінця масиву."
                },
                {
                    "lines": [
                        8
                    ],
                    "text": "i += i & -i: Стрибає до наступного батьківського діапазону покриття."
                },
                {
                    "lines": [
                        13
                    ],
                    "text": "Запит: Почати з index+1. Цикл назад до 0."
                },
                {
                    "lines": [
                        14
                    ],
                    "text": "i -= i & -i: Стрибає до попереднього піддіапазону, що не перекривається."
                },
                {
                    "lines": [
                        19
                    ],
                    "text": "Сума Діапазону [L, R] = PrefixSum(R) - PrefixSum(L-1)."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(log N) на операцію",
        "space": "O(N)",
        "explanation_time": "Обидві операції `update` та `query` включають цикл, який 'стрибає' через масив дерева. Кількість стрибків визначається кількістю встановлених бітів в індексі, що становить максимум O(log N).",
        "explanation_space": "Дерево Фенвіка вимагає одного масиву розміром N+1 для зберігання свого стану, що призводить до просторової складності O(N). Це більш ефективно з точки зору простору, ніж стандартне Дерево Відрізків, яке зазвичай вимагає 4N простору."
    }
}