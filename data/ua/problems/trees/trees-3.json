{
    "id": "trees-3",
    "title": "Діаметр Дерева",
    "difficulty": "Medium",
    "leetcode_url": "https://leetcode.com/problems/tree-diameter/",
    "related": [
        {
            "id": "trees-2",
            "title": "LCA Binary Lifting",
            "category": "trees"
        },
        {
            "id": "graphs-3",
            "title": "Network Delay Time",
            "category": "graphs"
        }
    ],
    "tags": [
        "tree-dp",
        "dfs",
        "diameter"
    ],
    "content": {
        "problem_statement": "Дано `root` бінарного дерева (або загального дерева, представленого ребрами), поверніть *довжину **діаметра** дерева*.\n\n**Діаметр** дерева - це довжина найдовшого шляху між будь-якими двома вузлами в дереві. Цей шлях може проходити, а може й не проходити через корінь.\n\nДовжина шляху між двома вузлами представлена кількістю ребер між ними.\n\n**Приклад 1:**\n```\nInput: edges = [[0,1],[0,2],[1,4],[1,5]]\nOutput: 3\nExplanation: 3 - це довжина шляху [4,1,0,2] або [5,1,0,2].\n```",
        "explanation": {
            "understanding_the_problem": "Нам потрібно знайти два вузли в дереві, які знаходяться найдалі один від одного, і повернути кількість ребер між ними. Оскільки це дерево, існує лише один унікальний шлях між будь-якими двома вузлами.",
            "brute_force": "Наївний підхід полягав би в запуску обходу графа (наприклад, BFS або DFS), починаючи з кожного окремого вузла в дереві. Для кожного початкового вузла `u` ми знаходили б вузол `v`, найвіддаленіший від нього, і записували б цю відстань. Остаточною відповіддю була б максимальна відстань, знайдена серед усіх початкових вузлів. Це вимагало б N обходів, кожен з яких займав би O(N) часу, що становить O(N²), що є неефективним.",
            "bottleneck": "Підхід O(N²) повільний, тому що він повторно обчислює багато однакових довжин шляхів. Існує два набагато ефективніші рішення O(N).",
            "optimized_approach": "**Метод 1: Два Обходи (BFS/DFS)**\nЦей метод спирається на цікаву властивість: однією з кінцевих точок будь-якого діаметра дерева завжди буде вузол, який є найвіддаленішим від довільного початкового вузла.\n1. Виберіть будь-який вузол `s` і знайдіть вузол `u`, найвіддаленіший від нього.\n2. Почніть з `u` і знайдіть вузол `v`, найвіддаленіший від нього.\n3. Відстань між `u` та `v` є діаметром.\n\n**Метод 2: DP на Деревах (як у коді)**\nЦе підхід DFS з одним проходом. Для будь-якого вузла `u`, найдовший шлях, що проходить через `u`, є сумою двох найдовших 'спадних' шляхів, що починаються з `u` в його піддерева. Ми можемо використовувати DFS для обчислення цього.\n\nФункція `dfs(node)` поверне довжину найдовшого спадного шляху, що починається в `node`. Роблячи це, вона також обчислює два найдовші спадні шляхи для кожного вузла (`max1`, `max2`) і використовує їх суму (`max1 + max2`), щоб оновити глобальну змінну `diameter`.",
            "algorithm_steps": "Наданий код використовує метод DP на Деревах:\n\n1.  **Ініціалізація:**\n    a.  Побудуйте список суміжності для дерева.\n    b.  Ініціалізуйте глобальну змінну `diameter` на 0.\n\n2.  **Визначте функцію DFS `dfs(currentNode, parentNode)`:**\n    a.  Ця функція поверне найдовший одиничний спадний шлях від `currentNode`.\n    b.  Всередині, ініціалізуйте `max1 = 0` та `max2 = 0`.\n    c.  Для кожного `neighbor` вузла `currentNode` (який не є його батьком), рекурсивно викличте `dfs(neighbor, currentNode)`. Це дає найдовший шлях від сусіда вниз. Додайте 1 до нього, щоб отримати довжину шляху від `currentNode`.\n    d.  Використовуйте цей результат, щоб оновити `max1` та `max2`.\n    e.  В кінці циклу сусідів, потенційний діаметр, що проходить через `currentNode`, дорівнює `max1 + max2`. Оновіть глобальний `diameter = max(diameter, max1 + max2)`.\n    f.  Поверніть `max1`, щоб його використало обчислення батька.\n\n3.  **Виконання:** Викличте `dfs` на довільному корені (наприклад, вузол 0) та поверніть фінальний `diameter`."
        },
        "quizzes": [
            {
                "question": "Що таке діаметр дерева?",
                "options": [
                    "Кількість вузлів",
                    "Найдовший шлях між будь-якими двома вузлами",
                    "Висота дерева",
                    "Сума ваг ребер"
                ],
                "correct": 1
            },
            {
                "question": "Що таке метод двох BFS/DFS?",
                "options": [
                    "Сортувати вузли",
                    "Знайти найвіддаленіший від будь-якого вузла, потім найвіддаленіший від того",
                    "Бінарний пошук",
                    "Хешувати вузли"
                ],
                "correct": 1
            },
            {
                "question": "У методі DP, що відстежують max1 та max2?",
                "options": [
                    "Мінімальні шляхи",
                    "Два найдовші спадні шляхи",
                    "Значення вузлів",
                    "Ваги ребер"
                ],
                "correct": 1
            },
            {
                "question": "Як оновлюється діаметр на кожному вузлі?",
                "options": [
                    "max1 * max2",
                    "max1 + max2",
                    "max(max1, max2)",
                    "min(max1, max2)"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність?",
                "options": [
                    "O(N²)",
                    "O(N log N)",
                    "O(N)",
                    "O(2^N)"
                ],
                "correct": 2
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function treeDiameter(n, edges) {\n  const adj = Array(n).fill().map(() => []);\n  for (let [u,v] of edges) {\n    adj[u].push(v); adj[v].push(u);\n  }\n  let diameter = 0;\n  function dfs(u, p) {\n    let max1 = 0, max2 = 0;\n    for (let v of adj[u]) if (v !== p) {\n      const h = dfs(v, u) + 1;\n      if (h > max1) { max2 = max1; max1 = h; }\n      else if (h > max2) max2 = h;\n    }\n    diameter = Math.max(diameter, max1 + max2);\n    return max1;\n  }\n  dfs(0, -1);\n  return diameter;\n}",
            "annotations": [
                {
                    "lines": [
                        2,
                        3,
                        4
                    ],
                    "text": "Побудувати список суміжності для неорієнтованого дерева."
                },
                {
                    "lines": [
                        6
                    ],
                    "text": "DFS: повертає довжину найдовшого шляху, ЩО ПОЧИНАЄТЬСЯ в 'u' і йде ВНИЗ."
                },
                {
                    "lines": [
                        9
                    ],
                    "text": "Рекурсивно вирішити для сусіда. Додати 1 для ребра u->v."
                },
                {
                    "lines": [
                        10,
                        11
                    ],
                    "text": "Відстежувати топ-2 найдовші шляхи, що розгалужуються від поточного вузла."
                },
                {
                    "lines": [
                        14
                    ],
                    "text": "Глобальне оновлення діаметра: Найдовший шлях ЧЕРЕЗ u є max1 + max2."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N)",
        "space": "O(N)",
        "explanation_time": "Метод двох обходів і метод DP на Деревах працюють за час O(N). Вони базуються на DFS або BFS, які відвідують кожен вузол і ребро в дереві рівно один раз.",
        "explanation_space": "Нам потрібен O(N) простір для списку суміжності. Стек рекурсії для DFS також буде O(H), де H - висота дерева. У найгіршому випадку викривленого дерева H може бути N, тому просторова складність становить O(N)."
    },
    "diagram": "graph TD\n    0((0)) --- 1((1))\n    0 --- 2((2))\n    1 --- 4((4))\n    1 --- 5((5))\n    \n    classDef default fill:#fff,stroke:#333,stroke-width:2px;\n    classDef path fill:#fca5a5,stroke:#b91c1c,stroke-width:2px;\n    \n    class 4,1,0,2 path;\n    linkStyle 0,1,2 stroke:#ef4444,stroke-width:4px;"
}