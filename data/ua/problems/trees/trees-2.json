{
    "id": "trees-2",
    "title": "Запити Відстані (LCA з Двійковим Підйомом)",
    "difficulty": "Medium",
    "related": [
        {
            "id": "trees-1",
            "title": "Segment Tree",
            "category": "trees"
        },
        {
            "id": "trees-3",
            "title": "Tree Diameter",
            "category": "trees"
        }
    ],
    "tags": [
        "lca",
        "binary-lifting",
        "trees"
    ],
    "content": {
        "problem_statement": "Вам дано дерево з `n` вузлами, пронумерованими від `0` до `n - 1`, та масив `edges`, де `edges[i] = [ai, bi]` вказує на те, що існує неорієнтоване ребро між двома вузлами `ai` та `bi` в дереві.\n\nВам також дано масив `queries`, де `queries[i] = [u, v]`. Для кожного запиту знайдіть **відстань** між вузлом `u` та вузлом `v`.\n\n**Відстань** між двома вузлами - це кількість ребер на єдиному простому шляху між ними.\n\n**Приклад 1:**\n```\nInput: n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], queries = [[3,5],[4,5]]\nOutput: [3, 3]\nExplanation: \nВідстань між 3 та 5 дорівнює 3 (3 -> 1 -> 0 -> 2 -> 5).\nВідстань між 4 та 5 дорівнює 3 (4 -> 1 -> 0 -> 2 -> 5).\n```",
        "explanation": {
            "understanding_the_problem": "Наївний підхід запуску окремого BFS/DFS для кожного запиту, щоб знайти довжину шляху, був би занадто повільним, якщо є багато запитів. Більш ефективний метод ґрунтується на пошуку **Найменшого Спільного Пращура (LCA)** двох вузлів.\n\nШлях від вузла `u` до `v` можна розглядати як шлях від `u` вгору до `lca(u,v)`, а потім вниз до `v`. Це дає нам формулу для відстані: `dist(u,v) = depth(u) + depth(v) - 2 * depth(lca(u,v))`. Проблема тепер стає такою: як ефективно знайти LCA?",
            "brute_force": "Щоб знайти LCA для `u` та `v`, ми могли б спершу привести їх до однієї глибини, переміщуючи глибший вузол вгору на одного батька за раз. Потім ми переміщуємо обидва вузли вгору на одного батька за раз, поки вони не зустрінуться. Це просто, але може зайняти O(N) часу на запит у найгіршому випадку (для високого, вузького дерева).",
            "bottleneck": "O(N) часу на запит є вузьким місцем. Нам потрібен спосіб переміщувати вузли вгору по дереву набагато швидше, ніж один крок за раз. Тут на допомогу приходить Двійковий Підйом.",
            "optimized_approach": "**Двійковий Підйом (Binary Lifting)** - це техніка, яка дозволяє нам відповідати на запити LCA за час O(log N) після кроку попередньої обробки O(N log N). Основна ідея полягає в попередньому обчисленні для кожного вузла його предка на різних відстанях ступеня двійки (1-й батько, 2-й, 4-й, 8-й і т.д.).\n\nМи будуємо таблицю `up[k][u]`, яка зберігає `2^k`-го предка вузла `u`. Цю таблицю можна побудувати за допомогою рекурентності: `up[k][u] = up[k-1][up[k-1][u]]` (2^k-й предок є 2^(k-1)-м предком 2^(k-1)-го предка).\n\nЗ цією таблицею ми можемо стрибати вгору по дереву на великі відстані (будь-яку відстань `d` можна представити як суму ступенів 2), що дозволяє нам знаходити LCA дуже швидко.",
            "algorithm_steps": "1.  **Попередня обробка (O(N log N)):**\n    a.  Запустіть DFS від кореня, щоб обчислити `depth[u]` та прямого батька `up[0][u]` для кожного вузла.\n    b.  Заповніть таблицю `up`, використовуючи рекурентність двійкового підйому, описану вище.\n\n2.  **Запит LCA (O(log N)):**\n    a.  **Вирівнювання Глибин:** Підніміть глибший вузол вгору, поки він не опиниться на тій же глибині, що й інший вузол. Це робиться за O(log N), стрибаючи вгору по ступенях 2.\n    b.  **Перевірка на Предка:** Якщо вузли тепер однакові, один був предком іншого, тому ми знайшли LCA.\n    c.  **Одночасний Підйом:** Якщо ні, піднімайте обидва вузли вгору одночасно по ступенях 2, від найбільшого до найменшого (`k = logN...0`). Ми робимо стрибок `up[k]`, тільки якщо їхні предки **не** є однаковими. Це гарантує, що вони приземляться трохи нижче LCA.\n    d.  LCA тоді є прямим батьком будь-якого з поточних вузлів.\n\n3.  **Запит Відстані:** Як тільки LCA знайдено, застосуйте формулу відстані."
        },
        "quizzes": [
            {
                "question": "Що означає LCA?",
                "options": [
                    "Last Common Ancestor",
                    "Lowest Common Ancestor",
                    "Linear Chain Analysis",
                    "Longest Connected Arc"
                ],
                "correct": 1
            },
            {
                "question": "Як обчислюється відстань за допомогою LCA?",
                "options": [
                    "depth(u) * depth(v)",
                    "depth(u) + depth(v) - 2*depth(lca)",
                    "depth(lca)",
                    "max(depth(u), depth(v))"
                ],
                "correct": 1
            },
            {
                "question": "Що зберігає up[k][u]?",
                "options": [
                    "k-ту дитину",
                    "2^k-го предка u",
                    "k предків",
                    "Відстань до кореня"
                ],
                "correct": 1
            },
            {
                "question": "Яка головна ідея двійкового підйому?",
                "options": [
                    "Сортувати вузли",
                    "Стрибати по ступенях 2",
                    "Хешувати предків",
                    "Розділити дерево"
                ],
                "correct": 1
            },
            {
                "question": "Яка складність попередньої обробки?",
                "options": [
                    "O(N)",
                    "O(N log N)",
                    "O(N²)",
                    "O(log N)"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "class LCA {\n  constructor(n, edges, root = 0) {\n    this.log = Math.ceil(Math.log2(n)) + 1;\n    this.parent = Array.from({length: this.log}, () => new Array(n).fill(-1));\n    this.depth = new Array(n).fill(0);\n    this.adj = Array(n).fill().map(() => []);\n    for (let [u,v] of edges) {\n      this.adj[u].push(v); this.adj[v].push(u);\n    }\n    this.dfs(root, -1);\n    this.preprocess();\n  }\n  dfs(u, p) {\n    this.parent[0][u] = p;\n    for (let v of this.adj[u]) if (v !== p) {\n      this.depth[v] = this.depth[u] + 1;\n      this.dfs(v, u);\n    }\n  }\n  preprocess() {\n    for (let k=1; k<this.log; k++)\n      for (let v=0; v<this.parent[0].length; v++)\n        if (this.parent[k-1][v] !== -1)\n          this.parent[k][v] = this.parent[k-1][this.parent[k-1][v]];\n  }\n  getLCA(u, v) {\n    if (this.depth[u] < this.depth[v]) [u,v] = [v,u];\n    let diff = this.depth[u] - this.depth[v];\n    for (let k=0; k<this.log; k++)\n      if (diff & (1<<k)) u = this.parent[k][u];\n    if (u === v) return u;\n    for (let k=this.log-1; k>=0; k--)\n      if (this.parent[k][u] !== this.parent[k][v]) {\n        u = this.parent[k][u]; v = this.parent[k][v];\n      }\n    return this.parent[0][u];\n  }\n  getDistance(u, v) {\n    const lca = this.getLCA(u, v);\n    return this.depth[u] + this.depth[v] - 2 * this.depth[lca];\n  }\n}",
            "annotations": [
                {
                    "lines": [
                        2
                    ],
                    "text": "Обчислити максимальну висоту (log N) для таблиці двійкового підйому."
                },
                {
                    "lines": [
                        3
                    ],
                    "text": "Таблиця Up: parent[k][u] - це 2^k-й предок u."
                },
                {
                    "lines": [
                        10,
                        15
                    ],
                    "text": "DFS: Обчислити глибини та заповнити 0-х предків (прямих батьків)."
                },
                {
                    "lines": [
                        17,
                        18
                    ],
                    "text": "Попередня обробка: Побудувати таблицю. 2^k-й предок є (2^(k-1))-м для (2^(k-1))-го."
                },
                {
                    "lines": [
                        21
                    ],
                    "text": "Запит LCA: Переконайтеся, що 'u' глибше, ніж 'v'."
                },
                {
                    "lines": [
                        23,
                        24
                    ],
                    "text": "Підніміть 'u' на ту саму глибину, що й 'v', використовуючи двійкові стрибки."
                },
                {
                    "lines": [
                        27,
                        28,
                        29
                    ],
                    "text": "Підніміть обох вгору одночасно на найбільші ступені 2, поки предки відрізняються."
                },
                {
                    "lines": [
                        31
                    ],
                    "text": "Після циклу вони знаходяться прямо під LCA, тому поверніть батька."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N log N) попередня обробка, O(log N) на запит",
        "space": "O(N log N)",
        "explanation_time": "Початковий DFS для обчислення глибин та батьків займає O(N). Побудова таблиці двійкового підйому `up` займає O(N log N). Кожен запит LCA потім займає O(log N), оскільки він включає кілька циклів, які ітеруються до log N разів.",
        "explanation_space": "Список суміжності, масив глибини тощо займають O(N) простору. Домінуючим фактором є таблиця `up`, яка має розміри приблизно (log N) x N, що призводить до O(N log N) просторової складності."
    },
    "diagram": "graph TD\n    0((0))\n    1((1))\n    2((2))\n    3((3))\n    4((4))\n    5((5))\n    \n    0 --- 1\n    0 --- 2\n    1 --- 3\n    1 --- 4\n    2 --- 5\n    \n    %% Binary Lifting Paths (Example for nodes 3 and 5)\n    3 -.->|2^0| 1\n    3 -.->|2^1| 0\n    5 -.->|2^0| 2\n    5 -.->|2^1| 0\n    \n    classDef default fill:#fff,stroke:#333,stroke-width:2px;"
}