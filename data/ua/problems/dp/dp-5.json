{
    "id": "dp-5",
    "title": "Співставлення Регулярних Виразів",
    "difficulty": "Medium",
    "tags": [
        "dp",
        "regex",
        "strings"
    ],
    "content": {
        "problem_statement": "Дано вхідний рядок `s` і шаблон `p`. Реалізуйте співставлення (matching) регулярних виразів з підтримкою `'.'` і `'*'`, де:\n\n*   `'.'` Відповідає будь-якому окремому символу.​​​​\n*   `'*'` Відповідає нулю або більше попереднього елемента.\n\nСпівставлення має охоплювати **весь** вхідний рядок (не частково).\n\n**Приклад 1:**\n```\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" не відповідає всьому рядку \"aa\".\n```\n\n**Приклад 2:**\n```\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" означає \"нуль або більше (*) будь-якого символу (.)\".\n```",
        "explanation": {
            "understanding_the_problem": "Це складна задача співставлення через спеціальні правила для '.' і особливо '*'. Здатність символу '*' відповідати 'нулю або більше' разів є сильним індикатором того, що нам потрібно досліджувати кілька можливостей, що робить це чудовим варіантом для динамічного програмування.",
            "brute_force": "Ми можемо визначити функцію `isMatch(s_idx, p_idx)`, яка перевіряє, чи підрядок `s`, що починається з `s_idx`, відповідає підшаблону `p`, що починається з `p_idx`. Це призводить до рекурсивної структури.\n\n- Якщо `p[p_idx+1]` дорівнює `'*'`, у нас є два варіанти: або ми співставляємо нуль екземплярів `p[p_idx]` і перевіряємо `isMatch(s_idx, p_idx+2)`, або ми співставляємо один екземпляр (якщо `s[s_idx]` відповідає `p[p_idx]`) і перевіряємо `isMatch(s_idx+1, p_idx)`.\n- В іншому випадку ми перевіряємо, чи збігаються поточні символи, і рекурсивно викликаємо `isMatch(s_idx+1, p_idx+1)`.",
            "bottleneck": "Чисто рекурсивне рішення буде дуже повільним через повторне обчислення тих самих підзадач (наприклад, `isMatch(5, 6)`) через різні шляхи рекурсії. Це класична проблема 'підзадач, що перекриваються', яку вирішує DP.",
            "optimized_approach": "Ми використовуємо 2D таблицю DP. Нехай `dp[i][j]` — це булеве значення, яке дорівнює `true`, якщо перші `i` символів рядка `s` можуть бути співставлені з першими `j` символами шаблону `p`.\n\nНаша мета — обчислити `dp[s.length][p.length]`. Ми заповнюємо таблицю на основі символу `p[j-1]`:\n\n- **Якщо `p[j-1]` не є `'*'`:** Збіг відбувається лише тоді, коли поточні символи збігаються (`s[i-1] == p[j-1]` або `p[j-1] == '.'`) ТА попередні префікси збігалися (`dp[i-1][j-1]` було true).\n\n- **Якщо `p[j-1]` є `'*'`:** Це складний випадок. `*` та його попередній символ `p[j-2]` можна розглядати двома способами:\n    1.  **Він відповідає нулю елементів:** У цьому випадку ми фактично ігноруємо `p[j-2]*`. Результатом є просто `dp[i][j-2]`.\n    2.  **Він відповідає одному або більше елементів:** Це можливо лише тоді, коли поточний символ рядка `s[i-1]` відповідає символу шаблону `p[j-2]`. Якщо це так, ми по суті розширюємо збіг для `*`, тому результат залежить від `dp[i-1][j]` (ми споживаємо символ з `s`, але залишаємося на тій самій позиції шаблону `j`, щоб дозволити більше збігів за допомогою `*`).\n\n`dp[i][j]` є істиною (true), якщо виконується будь-яка з цих умов.",
            "algorithm_steps": "1.  **Ініціалізація:**\n    a.  Створіть таблицю `dp` розміром `(s.length + 1) x (p.length + 1)`.\n    b.  `dp[0][0] = true` (порожній рядок відповідає порожньому шаблону).\n    c.  Ініціалізуйте перший рядок: `dp[0][j]` є істиною лише якщо `p` може утворити порожній рядок. Це відбувається для шаблонів типу `a*`, `a*b*`, і т.д. Отже, якщо `p[j-1] == '*'`, то `dp[0][j] = dp[0][j-2]`.\n\n2.  **Основний цикл:**\n    a.  Ітеруйте `i` від 1 до `s.length`.\n    b.  Ітеруйте `j` від 1 до `p.length`.\n    c.  Застосуйте логіку переходу стану, описану вище, для випадків, коли `p[j-1]` є `'*'` або ні.\n\n3.  **Результат:** Поверніть `dp[s.length][p.length]`."
        },
        "quizzes": [
            {
                "question": "Що представляє dp[i][j]?",
                "options": [
                    "Кількість збігів",
                    "s[0..i-1] відповідає p[0..j-1]?",
                    "Довжина шаблону",
                    "Індекс рядка"
                ],
                "correct": 1
            },
            {
                "question": "Як працює '*' у шаблонах?",
                "options": [
                    "Збігається з будь-яким символом",
                    "Збігається з нулем або більше попереднього",
                    "Збігається з одним символом",
                    "Кінець шаблону"
                ],
                "correct": 1
            },
            {
                "question": "З чим збігається '.'?",
                "options": [
                    "Тільки крапка",
                    "Будь-який окремий символ",
                    "Нуль символів",
                    "Пробіл"
                ],
                "correct": 1
            },
            {
                "question": "Коли шаблон a* може збігатися з порожнім рядком?",
                "options": [
                    "Ніколи",
                    "Коли * відповідає нулю елементів",
                    "Тільки якщо a існує",
                    "Завжди"
                ],
                "correct": 1
            },
            {
                "question": "Яка складність цього рішення DP?",
                "options": [
                    "O(N)",
                    "O(N²)",
                    "O(M × N)",
                    "O(2^N)"
                ],
                "correct": 2
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function isMatch(s, p) {\n  const m = s.length, n = p.length;\n  const dp = Array(m+1).fill().map(() => Array(n+1).fill(false));\n  dp[0][0] = true;\n  for (let j = 1; j <= n; j++) if (p[j-1] === '*') dp[0][j] = dp[0][j-2];\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (p[j-1] === '*') {\n        dp[i][j] = dp[i][j-2] || (matches(p[j-2], s[i-1]) && (dp[i-1][j] || dp[i][j-1]));\n      } else {\n        dp[i][j] = matches(p[j-1], s[i-1]) && dp[i-1][j-1];\n      }\n    }\n  }\n  return dp[m][n];\n}\nfunction matches(c1, c2) { return c1 === '.' || c1 === c2; }",
            "annotations": [
                {
                    "lines": [
                        2,
                        3
                    ],
                    "text": "Створити 2D булеву таблицю DP: dp[i][j] = true, якщо s[0..i-1] відповідає p[0..j-1]"
                },
                {
                    "lines": [
                        4
                    ],
                    "text": "Базовий випадок: порожній рядок відповідає порожньому шаблону"
                },
                {
                    "lines": [
                        5
                    ],
                    "text": "Ініціалізувати перший рядок: обробити шаблони типу a*, a*b*, які можуть збігатися з порожнім рядком (через * збіг з нулем елементів)"
                },
                {
                    "lines": [
                        6,
                        7
                    ],
                    "text": "Основні цикли DP: заповнити таблицю для всіх комбінацій (i, j)"
                },
                {
                    "lines": [
                        8,
                        9
                    ],
                    "text": "Випадок 1 - Зірочка: збіг з нулем (dp[i][j-2]) АБО з одним+ якщо символ збігається (dp[i-1][j])"
                },
                {
                    "lines": [
                        10,
                        11
                    ],
                    "text": "Випадок 2 - Без зірочки: простий збіг. Поточні символи повинні збігатися І попередні префікси повинні збігатися"
                },
                {
                    "lines": [
                        15
                    ],
                    "text": "Повернути, чи збігається весь рядок з усім шаблоном"
                },
                {
                    "lines": [
                        17
                    ],
                    "text": "Допоміжна функція: '.' збігається з будь-яким символом, в іншому випадку повинен бути точний збіг"
                }
            ]
        }
    },
    "complexity": {
        "time": "O(M * N)",
        "space": "O(M * N)",
        "explanation_time": "Нехай M — довжина рядка, а N — довжина шаблону. Ми заповнюємо 2D таблицю DP розміром M x N. Обчислення значення для кожної клітинки займає постійний час. Це призводить до часової складності O(M * N).",
        "explanation_space": "Ми використовуємо 2D таблицю DP розміром (M+1) x (N+1) для зберігання результатів усіх підзадач. Це вимагає O(M * N) простору."
    }
}