{
    "id": "dp-2",
    "title": "Найдовша Зростаюча Підпослідовність (LIS)",
    "difficulty": "Medium",
    "leetcode_url": "https://leetcode.com/problems/longest-increasing-subsequence/",
    "related": [
        {
            "id": "dp-4",
            "title": "Burst Balloons",
            "category": "dp"
        },
        {
            "id": "trees-1",
            "title": "Range Sum Queries",
            "category": "trees"
        }
    ],
    "tags": [
        "dp",
        "binary-search",
        "lis"
    ],
    "content": {
        "problem_statement": "Дано цілочисельний масив `nums`, поверніть довжину найдовшої строго зростаючої підпослідовності.\n\n**Приклад 1:**\n```\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: Найдовша зростаюча підпослідовність - це [2,3,7,101], тому довжина дорівнює 4.\n```\n\n**Приклад 2:**\n```\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\n```",
        "explanation": {
            "understanding_the_problem": "Нам потрібно знайти довжину найдовшої підпослідовності, де кожен елемент строго більший за попередній. Елементи не обов'язково мають бути суміжними. Наприклад, у `[10, 9, 2, 5, 3, 7, 101]`, найдовша зростаюча підпослідовність - це `[2, 3, 7, 101]`, отже, відповідь 4.",
            "brute_force": "Це класична задача динамічного програмування (DP). Поширений підхід DP полягає у визначенні масиву `dp`, де `dp[i]` представляє довжину найдовшої зростаючої підпослідовності, що **закінчується індексом `i`**.\n\nЩоб обчислити `dp[i]`, ми розглядаємо всі попередні індекси `j < i`. Якщо `nums[j] < nums[i]`, це означає, що ми потенційно можемо розширити зростаючу підпослідовність, яка закінчувалася на `j`. Ми беремо найдовшу таку підпослідовність (`dp[j]`) і додаємо 1. Ми перевіряємо це для всіх допустимих `j` і беремо максимум.\n\nОстаточна відповідь - це максимальне значення у всьому масиві `dp`, оскільки LIS може закінчуватися на будь-якому індексі.",
            "bottleneck": "Описаний вище підхід DP вимагає двох вкладених циклів. Зовнішній цикл ітерується від `i = 0 до N-1`, а внутрішній цикл ітерується від `j = 0 до i-1`. Це призводить до часової складності O(N²), що добре, але може бути занадто повільно для більших обмежень.",
            "optimized_approach": "Більш просунуте та ефективне рішення використовує хитре поєднання терпіння та бінарного пошуку, досягаючи часу O(N log N). Основна ідея полягає в тому, щоб підтримувати масив (назвемо його `tails`), який зберігає найменший хвіст усіх зростаючих підпослідовностей довжиною `i+1` в `tails[i]`.\n\nНаприклад, якщо `tails` дорівнює `[2, 5, 7]`, це означає, що ми знайшли LIS довжиною 1, що закінчується на 2, LIS довжиною 2, що закінчується на 5, і LIS довжиною 3, що закінчується на 7. Цей масив `tails` завжди буде відсортований.\n\nКоли ми обробляємо нове число `num`:\n- Якщо `num` більше за останній елемент `tails`, ми можемо розширити найдовшу знайдену досі підпослідовність. Ми додаємо `num` до `tails`.\n- Якщо `num` не більше, воно може розпочати нову, коротшу підпослідовність з більш перспективним (меншим) хвостом. Ми знаходимо позицію найменшого елемента в `tails`, який більше або дорівнює `num`, і замінюємо його. Цей пошук можна виконати за допомогою бінарного пошуку.",
            "algorithm_steps": "Тут ми описуємо підхід DP O(N²), з якого інтуїтивно зрозуміліше починати:\n\n1.  **Ініціалізація:** Створіть масив `dp` того ж розміру, що й `nums`, і заповніть його одиницями (`1`). Це відображає базовий випадок, коли кожен елемент сам по собі є зростаючою підпослідовністю довжини 1.\n2.  **Основний цикл:**\n    a.  Ітеруйте `i` від 1 до `N-1` (для кожного елемента).\n    b.  Вкладіть цикл з `j` від 0 до `i-1` (щоб перевірити всі попередні елементи).\n    c.  Якщо `nums[j] < nums[i]`, можна розширити підпослідовність, що закінчується на `j`. Оновіть `dp[i]` як `max(dp[i], dp[j] + 1)`.\n3.  **Результат:** Після циклів відповіддю буде максимальне значення, знайдене в масиві `dp`."
        },
        "quizzes": [
            {
                "question": "Що представляє dp[i] у розв'язку LIS?",
                "options": [
                    "Всього підпослідовностей",
                    "LIS, що закінчується індексом i",
                    "LIS, що починається з i",
                    "Довжина масиву"
                ],
                "correct": 1
            },
            {
                "question": "Що є вузьким місцем O(N²) DP для LIS?",
                "options": [
                    "Використання пам'яті",
                    "Вкладені цикли перевіряють усі пари",
                    "Глибина рекурсії",
                    "Операції з рядками"
                ],
                "correct": 1
            },
            {
                "question": "Як ми можемо оптимізувати LIS до O(N log N)?",
                "options": [
                    "Хеш-таблиця",
                    "Бінарний пошук у масиві tails",
                    "Сортування спочатку",
                    "Розділяй і володарюй"
                ],
                "correct": 1
            },
            {
                "question": "Чому ми ініціалізуємо dp[i] = 1?",
                "options": [
                    "Індексація масиву",
                    "Кожен елемент є LIS довжини 1",
                    "Запобігання переповненню",
                    "Відповідність розміру масиву"
                ],
                "correct": 1
            },
            {
                "question": "Як отримати остаточну відповідь?",
                "options": [
                    "dp[0]",
                    "dp[n-1]",
                    "Максимум з усіх значень dp",
                    "Сума значень dp"
                ],
                "correct": 2
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function lengthOfLIS(nums) {\n  const n = nums.length;\n  const dp = new Array(n).fill(1);\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1);\n    }\n  }\n  return Math.max(...dp);\n}",
            "annotations": [
                {
                    "lines": [
                        2,
                        3
                    ],
                    "text": "Ініціалізувати масив dp: dp[i] = 1 означає, що кожен елемент сам по собі є LIS довжиною 1"
                },
                {
                    "lines": [
                        4
                    ],
                    "text": "Зовнішній цикл: для кожної позиції i знайти найдовшу зростаючу підпослідовність, що закінчується на i"
                },
                {
                    "lines": [
                        5
                    ],
                    "text": "Внутрішній цикл: перевірити всі попередні елементи j < i, щоб знайти допустимих попередників"
                },
                {
                    "lines": [
                        6
                    ],
                    "text": "Основна рекурентність: якщо nums[j] < nums[i], ми можемо розширити LIS, що закінчується на j. Взяти максимум"
                },
                {
                    "lines": [
                        9
                    ],
                    "text": "Відповідь - це максимум з усіх значень dp, оскільки LIS може закінчуватися на будь-якому індексі"
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N²)",
        "space": "O(N)",
        "explanation_time": "Наданий код використовує прямий підхід DP. Є два вкладених цикли. Зовнішній цикл виконується N разів, а внутрішній цикл виконується до N разів. Це дає часову складність O(N²).",
        "explanation_space": "Ми використовуємо додатковий масив `dp` того ж розміру, що й вхідний масив `nums`. Це вимагає O(N) простору."
    }
}