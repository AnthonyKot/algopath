{
    "id": "dp-3",
    "title": "Решта Монетами (Мін. Монет)",
    "difficulty": "Середній",
    "leetcode_url": "https://leetcode.com/problems/coin-change/",
    "related": [
        {
            "id": "dp-2",
            "title": "Longest Increasing Subsequence",
            "category": "dp"
        }
    ],
    "tags": [
        "dp",
        "knapsack",
        "greedy"
    ],
    "content": {
        "problem_statement": "Вам надано масив цілих чисел `coins`, що представляє монети різних номіналів, і ціле число `amount`, що представляє загальну суму грошей.\n\nПоверніть найменшу кількість монет, необхідну для складання цієї суми. Якщо цю суму грошей неможливо скласти жодною комбінацією монет, поверніть -1.\n\nВи можете вважати, що у вас є нескінченна кількість монет кожного виду.\n\n**Приклад 1:**\n```\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\n```",
        "explanation": {
            "understanding_the_problem": "Нам потрібно сформувати цільову суму `amount`, використовуючи найменшу можливу кількість монет із заданого набору. Ми можемо використовувати кожен номінал монети стільки разів, скільки захочемо. Це класична задача оптимізації, яка вписується в патерн динамічного програмування, а саме варіацію, відому як задача про **Необмежений Рюкзак (Unbounded Knapsack)**.",
            "brute_force": "Рекурсивний підхід полягав би в спробі розв'язати задачу для `amount`, взявши одну монету, а потім рекурсивно розв'язати для `amount - coin`. Ми б зробили це для кожної монети в нашому наборі і взяли б мінімальний результат. Наприклад, `minCoins(amount) = 1 + min(minCoins(amount - c1), minCoins(amount - c2), ...)`.",
            "bottleneck": "Чисто рекурсивне рішення є дуже повільним, оскільки воно багаторазово перераховує одні й ті ж підзадачі. Наприклад, щоб розрахувати монети для суми 10, ми можемо дослідити `10 -> 5 -> 2` а також `10 -> 8 -> 5 -> 2`. Розв'язок для суми 5 і 2 буде обчислено кілька разів.",
            "optimized_approach": "Ми можемо використовувати підхід динамічного програмування 'знизу-вгору', щоб ефективно розв'язати цю задачу. Ми створимо масив `dp`, де `dp[i]` зберігає мінімальну кількість монет, необхідну для складання суми `i`.\n\nМи будуємо цей масив від `dp[0]` до `dp[amount]`. Щоб обчислити `dp[i]`, ми розглядаємо кожен номінал монети. Якщо ми використовуємо `coin`, загальна кількість монет буде `1 + dp[i - coin]`. Ми просто беремо мінімальне значення з усіх можливих монет, які ми можемо використати.",
            "algorithm_steps": "1.  **Ініціалізація:**\n    a.  Створіть масив `dp` розміром `amount + 1`.\n    b.  Ініціалізуйте всі значення заповнювачем для нескінченності (наприклад, `amount + 1`). Це означає, що сума ще не досяжна.\n    c.  Встановіть базовий випадок: `dp[0] = 0`. Для складання суми 0 потрібно 0 монет.\n\n2.  **Основний цикл (Знизу-Вгору):**\n    a.  Ітеруйте `i` від 1 до `amount`. Для кожного `i` ми розв'язуємо задачу мінімальної кількості монет для суми `i`.\n    b.  Всередині пройдіть циклом через кожну `coin` у нашому масиві `coins`.\n    c.  Якщо `i >= coin`, можна використати цю монету. Ми оновлюємо нашу відповідь для `dp[i]` мінімумом з його поточного значення та `1 + dp[i - coin]`.\n\n3.  **Результат:**\n    a.  Після циклів, якщо `dp[amount]` все ще дорівнює нашому заповнювачу нескінченності, це означає, що сума була недосяжною. Поверніть -1.\n    b.  В іншому випадку `dp[amount]` містить відповідь."
        },
        "quizzes": [
            {
                "question": "Якому патерну DP слідує задача про Решту Монет?",
                "options": [
                    "Рюкзак 0/1",
                    "Необмежений Рюкзак",
                    "LCS",
                    "Ланцюг Матриць"
                ],
                "correct": 1
            },
            {
                "question": "Чому наївна рекурсія повільна для цієї задачі?",
                "options": [
                    "Переповнення стека",
                    "Повторювані підзадачі",
                    "Забагато монет",
                    "Великі суми"
                ],
                "correct": 1
            },
            {
                "question": "Що зберігає dp[i]?",
                "options": [
                    "Кількість способів",
                    "Мін. монет для суми i",
                    "Макс. монет",
                    "Вартість монет"
                ],
                "correct": 1
            },
            {
                "question": "Чому ми ініціалізуємо dp нескінченністю (Infinity)?",
                "options": [
                    "Запобігання переповненню",
                    "Позначення недосяжних сум",
                    "Швидше порівняння",
                    "Ефективність пам'яті"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність?",
                "options": [
                    "O(N)",
                    "O(N²)",
                    "O(Amount × Coins)",
                    "O(2^N)"
                ],
                "correct": 2
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function coinChange(coins, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let coin of coins) {\n    for (let x = coin; x <= amount; x++) {\n      dp[x] = Math.min(dp[x], dp[x - coin] + 1);\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}",
            "annotations": [
                {
                    "lines": [
                        2
                    ],
                    "text": "Створити dp масив розміром amount+1, ініціалізувати Infinity (недосяжне)"
                },
                {
                    "lines": [
                        3
                    ],
                    "text": "Базовий випадок: 0 монет потрібно для суми 0"
                },
                {
                    "lines": [
                        4
                    ],
                    "text": "Зовнішній цикл: ітерація по кожному номіналу монети"
                },
                {
                    "lines": [
                        5
                    ],
                    "text": "Внутрішній цикл: для кожної суми >= coin, перевірити, чи покращує використання цієї монети результат"
                },
                {
                    "lines": [
                        6
                    ],
                    "text": "Основна рекурентність: dp[x] = min(dp[x], 1 + dp[x-coin]) - використати монету, якщо це дає менше монет"
                },
                {
                    "lines": [
                        9
                    ],
                    "text": "Повернути відповідь або -1, якщо сума все ще недосяжна (Infinity)"
                }
            ]
        }
    },
    "complexity": {
        "time": "O(A * C)",
        "space": "O(A)",
        "explanation_time": "Нехай A — цільова сума, а C — кількість номіналів монет. У нас є два вкладених цикли. Зовнішній цикл ітерується по монетах (C разів у наданому коді, хоча їх можна поміняти місцями), а внутрішній цикл ітерується до суми (A разів). Це дає загальну часову складність O(A * C).",
        "explanation_space": "Ми використовуємо масив `dp` розміром `amount + 1` для зберігання проміжних рішень для всіх сум від 0 до `amount`. Це вимагає O(A) простору."
    }
}