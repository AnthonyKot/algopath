{
    "id": "dp-1",
    "title": "Відстань Редагування (Левенштейн)",
    "difficulty": "Середня",
    "leetcode_url": "https://leetcode.com/problems/edit-distance/",
    "related": [
        {
            "id": "dp-5",
            "title": "Зіставлення Регулярних Виразів",
            "category": "dp"
        },
        {
            "id": "graphs-1",
            "title": "Сходинки Слів",
            "category": "graphs"
        }
    ],
    "tags": [
        "dp",
        "strings",
        "edit-distance"
    ],
    "follow_up": {
        "scenario": "Перевірка орфографії для пошукової системи. Потрібна мілісекундна відповідь для 'Можливо, ви мали на увазі?'.",
        "trade_off": "O(N²) DP занадто повільне для корекції запитів у реальному часі на мільйонах термінів.",
        "strategy": "Використовуйте Автомат Левенштейна або BK-Дерева для пошуку. Для точної відстані між довгими рядками використовуйте Бітовий Паралелізм.",
        "answering_guide": "Магічна фраза — <strong>'нечіткий пошук'</strong>. Якщо згадаєте <strong>'Автомат Lucene'</strong> або <strong>'Бітовий Паралелізм'</strong>, ви перемагаєте миттєво."
    },
    "content": {
        "problem_statement": "Дано два рядки `word1` та `word2`, поверніть мінімальну кількість операцій, необхідних для перетворення `word1` у `word2`.\n\nВам дозволено виконувати такі три операції над словом:\n1. Вставити символ\n2. Видалити символ\n3. Замінити символ\n\n**Приклад 1:**\n```\nВхід: word1 = \"horse\", word2 = \"ros\"\nВихід: 3\nПояснення: \nhorse -> rorse (замінити 'h' на 'r')\nrorse -> rose (видалити 'r')\nrose -> ros (видалити 'e')\n```\n\n**Приклад 2:**\n```\nВхід: word1 = \"intention\", word2 = \"execution\"\nВихід: 5\nПояснення: \nintention -> inention (видалити 't')\ninention -> enention (замінити 'i' на 'e')\nenention -> exention (замінити 'n' на 'x')\nexention -> exection (замінити 'n' на 'c')\nexection -> execution (вставити 'u')\n```",
        "explanation": {
            "understanding_the_problem": "Нам потрібно знайти *мінімальну* кількість редагувань (вставка, видалення, заміна) для перетворення одного рядка в інший. Вимога 'мінімуму' — це сильний натяк на те, що це задача оптимізації, і оскільки вона стосується послідовностей (рядків), це класичний кандидат для Динамічного Програмування.\n\nОсновна ідея DP — розв'язувати складну задачу, розбиваючи її на простіші підзадачі, що перетинаються. Відстань редагування між `word1` та `word2` залежить від відстаней редагування їхніх префіксів.",
            "brute_force": "Ми можемо визначити функцію `dp(i, j)`, яка дає відстань редагування між першими `i` символами `word1` та першими `j` символами `word2`. Наша мета — знайти `dp(m, n)`, де `m` та `n` — довжини слів.\n\nДля обчислення `dp(i, j)` ми дивимось на останні символи, `word1[i-1]` та `word2[j-1]`.\n\n- **Якщо символи збігаються:** Операція не потрібна. Вартість — просто результат підзадачі для префіксів без цих символів: `dp(i-1, j-1)`.\n- **Якщо символи не збігаються:** Ми повинні виконати операцію. Обираємо ту, що має мінімальну вартість:\n    - **Заміна:** `1 + dp(i-1, j-1)` (вартість заміни + вартість меншої підзадачі)\n    - **Видалення:** `1 + dp(i-1, j)` (вартість видалення + вартість зіставлення префікса `word1` з `word2`)\n    - **Вставка:** `1 + dp(i, j-1)` (вартість вставки + вартість зіставлення `word1` з префіксом `word2`)",
            "bottleneck": "Чисто рекурсивне рішення було б надзвичайно повільним, оскільки воно повторно обчислювало б одні й ті самі підзадачі (наприклад, `dp(3, 4)`) багато разів. Це властивість 'підзадач, що перетинаються', для розв'язання якої призначено DP.",
            "optimized_approach": "Ми можемо використовувати 2D-таблицю (масив масивів) для зберігання результатів підзадач — техніка, яка називається мемоізація або табуляція. Нехай `dp[i][j]` — мінімальна відстань редагування між `word1.slice(0, i)` та `word2.slice(0, j)`.\n\nМи заповнюємо цю таблицю знизу вгору, починаючи з базових випадків (як відстань від порожнього рядка до префікса), і використовуємо логіку переходу станів, описану вище, для заповнення всієї таблиці. Остаточна відповідь — значення в нижньому правому куті, `dp[m][n]`.",
            "algorithm_steps": "1.  **Ініціалізація:**\n    a.  Створюємо таблицю `dp` розміром `(m+1) x (n+1)`.\n    b.  `dp[0][0] = 0` (відстань між двома порожніми рядками — 0).\n    c.  Заповнюємо перший рядок: `dp[0][j] = j`. Це вартість створення префікса `word2` з порожнього рядка (j вставок).\n    d.  Заповнюємо перший стовпець: `dp[i][0] = i`. Це вартість зведення префікса `word1` до порожнього рядка (i видалень).\n\n2.  **Основний цикл:**\n    a.  Ітеруємо з `i` від 1 до `m` та `j` від 1 до `n`.\n    b.  Якщо `word1[i-1] == word2[j-1]`, тоді `dp[i][j] = dp[i-1][j-1]`.\n    c.  Інакше, `dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])`.\n\n3.  **Результат:** Повертаємо `dp[m][n]`.\n\n**Оптимізація простору:** Зауважте, що для обчислення комірки `dp[i][j]` нам потрібні лише значення з попереднього рядка та поточного рядка. Це означає, що ми можемо оптимізувати простір з O(mn) до O(n), зберігаючи лише один або два рядки одночасно. Надане рішення використовує розумний підхід з одним масивом для цього."
        },
        "quizzes": [
            {
                "question": "Яка техніка найкраще підходить для задачі з підзадачами, що перетинаються?",
                "options": [
                    "Жадібний алгоритм",
                    "Розділяй і володарюй",
                    "Динамічне програмування",
                    "Пошук з поверненням"
                ],
                "correct": 2
            },
            {
                "question": "Яке основне вузьке місце наївної рекурсії тут?",
                "options": [
                    "Переповнення стеку",
                    "Повторювані підзадачі",
                    "Виділення пам'яті",
                    "Копіювання рядків"
                ],
                "correct": 1
            },
            {
                "question": "Як уникнути повторного обчислення тих самих підзадач?",
                "options": [
                    "Сортування",
                    "Хешування",
                    "Мемоізація",
                    "Паралелізм"
                ],
                "correct": 2
            },
            {
                "question": "Що представляє dp[i][j] у цьому рішенні?",
                "options": [
                    "Максимальні редагування",
                    "Мінімальні редагування для префіксів",
                    "Кількість символів",
                    "Довжина рядка"
                ],
                "correct": 1
            },
            {
                "question": "Яка просторова складність після оптимізації?",
                "options": [
                    "O(m*n)",
                    "O(m+n)",
                    "O(min(m,n))",
                    "O(1)"
                ],
                "correct": 2
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function editDistance(s1, s2) {\n  let [m, n] = [s1.length, s2.length];\n  if (m < n) { [s1, s2] = [s2, s1]; [m, n] = [n, m]; }\n  const dp = Array(n+1).fill(0);\n  for (let j = 0; j <= n; j++) dp[j] = j;\n  for (let i = 1; i <= m; i++) {\n    let prev = i;\n    for (let j = 1; j <= n; j++) {\n      let temp = dp[j];\n      dp[j] = s1[i-1] === s2[j-1] ? dp[j-1] : 1 + Math.min(dp[j-1], prev, dp[j]);\n      prev = temp;\n    }\n  }\n  return dp[n];\n}",
            "annotations": [
                {
                    "lines": [
                        3
                    ],
                    "text": "Міняємо місцями, щоб s2 був коротшим — масив dp менший для оптимізації простору"
                },
                {
                    "lines": [
                        4,
                        5
                    ],
                    "text": "Базовий випадок: dp[j] = j означає j вставок для перетворення порожнього рядка в s2[0..j]"
                },
                {
                    "lines": [
                        7
                    ],
                    "text": "'prev' зберігає dp[i-1][j-1] з 2D-таблиці — діагональне значення, яке нам потрібне"
                },
                {
                    "lines": [
                        9
                    ],
                    "text": "'temp' зберігає dp[j] перед перезаписом, стає 'prev' для наступного стовпця"
                },
                {
                    "lines": [
                        10
                    ],
                    "text": "Основна рекурентність: якщо символи збігаються — використовуємо діагональ, інакше 1 + min(заміна, вставка, видалення)"
                },
                {
                    "lines": [
                        14
                    ],
                    "text": "Фінальна відповідь: мін. редагувань для перетворення s1[0..m] у s2[0..n]"
                }
            ]
        }
    },
    "complexity": {
        "time": "O(m*n)",
        "space": "O(min(m,n))",
        "explanation_time": "Нам потрібно обчислити значення для кожної з m*n комірок у нашій концептуальній DP-таблиці. Кожне обчислення займає константний час. Тому часова складність становить O(m*n), де m та n — довжини двох рядків.",
        "explanation_space": "Стандартний підхід з 2D DP-таблицею вимагає O(m*n) простору. Однак надане рішення оптимізоване за простором. Воно зберігає лише один рядок DP-таблиці за раз, зменшуючи просторову складність до O(n), де n — довжина коротшого рядка (завдяки початковому обміну)."
    }
}