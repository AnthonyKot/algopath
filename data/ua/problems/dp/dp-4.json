{
    "id": "dp-4",
    "title": "Вибух Кульок",
    "difficulty": "Середній",
    "leetcode_url": "https://leetcode.com/problems/burst-balloons/",
    "tags": [
        "dp",
        "interval-dp",
        "optimization"
    ],
    "content": {
        "problem_statement": "Вам надано `n` кульок, проіндексованих від `0` до `n - 1`. Кожна кулька розфарбована числом, представленим масивом `nums`.\n\nВам потрібно лопнути всі кульки. Якщо ви лопнете `i-ту` кульку, ви отримаєте `nums[i-1] * nums[i] * nums[i+1]` монет. Якщо `i-1` або `i+1` виходять за межі масиву, то вважайте, що там є кулька з числом `1`.\n\nПоверніть максимальну кількість монет, яку ви можете зібрати, лопаючи кульки розумно.\n\n**Приклад 1:**\n```\nInput: nums = [3,1,5,8]\nOutput: 167\nExplanation:\nnums = [3,1,5,8] -> [3,5,8] -> [3,8] -> [8] -> []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\n```",
        "explanation": {
            "understanding_the_problem": "Нам потрібно знайти оптимальний порядок лопання кульок, щоб максимізувати наш рахунок. Основна складність полягає в тому, що лопання кульки впливає на рахунок майбутніх вибухів, оскільки 'суміжні' кульки змінюються. Ця динамічна залежність робить простий жадібний підхід малоймовірним для роботи.",
            "brute_force": "Стандартним підходом DP може бути визначення `dp(balloons_left)` як максимального рахунку. Однак підзадачі не є незалежними. Рахунок за лопання кульки в підмасиві залежить від меж, які, можливо, вже були лопнуті. Це робить стан важким для визначення.\n\nКлючова ідея полягає в тому, щоб змінити нашу перспективу: замість того, щоб думати 'яку кульку лопнути першою?', ми повинні думати **'яку кульку лопнути останньою?'**",
            "bottleneck": "Стандартне мислення 'лопнути першою' призводить до пов'язаних підзадач. Якщо ми лопнемо `nums[i]`, підзадачі `(0, i-1)` та `(i+1, n-1)` не є незалежними, оскільки майбутній вибух у лівій частині може потребувати межі з правої частини.",
            "optimized_approach": "Давайте зосередимося на **останній** кульці, яку потрібно лопнути в інтервалі `(i, j)`. Припустимо, що ця остання кулька - `k`. Коли ми лопаємо `k`, всі інші кульки між `i` та `j` вже зникли. Це означає, що її сусідами повинні бути `i` та `j`. Монети, отримані від цього останнього вибуху, складають `nums[i] * nums[k] * nums[j]`.\n\nТоді загальний рахунок дорівнює `(макс. бал з інтервалу (i, k)) + (макс. бал з інтервалу (k, j)) + nums[i] * nums[k] * nums[j]`. Підзадачі `(i, k)` та `(k, j)` тепер незалежні! Це патерн, відомий як **Інтервальне DP (Interval DP)**.",
            "algorithm_steps": "1.  **Попередня обробка:** Доповніть масив `nums` одиницею `1` з обох кінців. Це елегантно обробляє граничні випадки. Нехай нова довжина буде `n`.\n2.  **Ініціалізація:** Створіть 2D таблицю `dp` розміром `n x n`, де `dp[i][j]` буде зберігати макс. монет від лопання кульок у відкритому інтервалі `(i, j)`.\n3.  **Основний цикл (Interval DP):**\n    a.  Ітеруйте довжину інтервалу `len`, від 2 до `n-1`.\n    b.  Ітеруйте початковий індекс `i`, від 0 до `n - 1 - len`.\n    c.  Кінцевий індекс `j` буде `i + len`.\n    d.  Для нашого інтервалу `(i, j)` ітеруйте через кожну можливу останню кульку `k`, де `i < k < j`.\n    e.  Застосуйте перехід: `dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])`.\n\n4.  **Результат:** Відповідь для всього діапазону `(0, n-1)` буде збережена в `dp[0][n-1]`."
        },
        "quizzes": [
            {
                "question": "Який патерн DP використовує задача Вибух Кульок?",
                "options": [
                    "Лінійне DP",
                    "Інтервальне DP",
                    "DP на деревах",
                    "DP по цифрах"
                ],
                "correct": 1
            },
            {
                "question": "Яка ключова ідея для цієї задачі?",
                "options": [
                    "Лопати найменші першими",
                    "Думати про те, яку лопати ОСТАННЬОЮ",
                    "Використовувати жадібний підхід",
                    "Сортувати кульки"
                ],
                "correct": 1
            },
            {
                "question": "Чому думати про 'останню кульку' краще, ніж про 'першу'?",
                "options": [
                    "Швидше виконання",
                    "Підзадачі стають незалежними",
                    "Легше кодувати",
                    "Менше пам'яті"
                ],
                "correct": 1
            },
            {
                "question": "Що представляє dp[i][j]?",
                "options": [
                    "Мін. монет",
                    "Макс. монет в інтервалі (i,j)",
                    "Кількість кульок",
                    "Порядок вибухів"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність?",
                "options": [
                    "O(N)",
                    "O(N²)",
                    "O(N³)",
                    "O(2^N)"
                ],
                "correct": 2
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function maxCoins(nums) {\n  const n = nums.length;\n  nums = [1, ...nums, 1];\n  const dp = Array(n+2).fill().map(() => Array(n+2).fill(0));\n  for (let len = 1; len <= n; len++) {\n    for (let i = 1; i + len - 1 <= n; i++) {\n      const j = i + len - 1;\n      for (let k = i; k <= j; k++) {\n        dp[i][j] = Math.max(dp[i][j], nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j]);\n      }\n    }\n  }\n  return dp[1][n];\n}",
            "annotations": [
                {
                    "lines": [
                        2,
                        3
                    ],
                    "text": "Доповнити масив одиницями з обох кінців для обробки граничних випадків. Оригінальні індекси кульок стають від 1 до n"
                },
                {
                    "lines": [
                        4
                    ],
                    "text": "Створити 2D таблицю DP: dp[i][j] = макс монет від лопання кульок у діапазоні [i, j]"
                },
                {
                    "lines": [
                        5
                    ],
                    "text": "Зовнішній цикл: ітерація за довжиною інтервалу (менші інтервали спочатку - знизу-вгору)"
                },
                {
                    "lines": [
                        6,
                        7
                    ],
                    "text": "Середній цикл: ітерація по всіх можливих початкових позиціях для поточної довжини інтервалу"
                },
                {
                    "lines": [
                        8,
                        9
                    ],
                    "text": "Внутрішній цикл: спробувати кожну кульку k як ОСТАННЮ для вибуху в інтервалі. Ключова ідея: коли k остання, її сусідами є i-1 та j+1"
                },
                {
                    "lines": [
                        13
                    ],
                    "text": "Відповідь: макс монет від лопання всіх кульок (діапазон від 1 до n)"
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N³)",
        "space": "O(N²)",
        "explanation_time": "Нехай N — кількість кульок в оригінальному масиві. У нас є три вкладених цикли для заповнення таблиці DP: один для довжини інтервалу, один для початкової позиції та один для 'останньої кульки' `k`. Кожен з цих циклів виконується приблизно N разів, що призводить до кубічної часової складності O(N³).",
        "explanation_space": "Ми використовуємо 2D таблицю DP розміром приблизно (N+2) x (N+2) для зберігання результатів підзадач. Це вимагає O(N²) простору."
    }
}