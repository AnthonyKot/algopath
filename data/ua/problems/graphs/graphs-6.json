{
    "id": "graphs-6",
    "title": "Критичні З'єднання в Мережі",
    "difficulty": "Важкий",
    "leetcode_url": "https://leetcode.com/problems/critical-connections-in-a-network/",
    "related": [
        {
            "id": "graphs-1",
            "title": "Word Ladder",
            "category": "graphs"
        }
    ],
    "tags": [
        "dfs",
        "tarjan",
        "bridges"
    ],
    "content": {
        "problem_statement": "Існує `n` серверів, пронумерованих від `0` до `n - 1`, з'єднаних неорієнтованими з'єднаннями сервер-сервер `connections`, що утворюють мережу, де `connections[i] = [ai, bi]` представляє з'єднання між серверами `ai` та `bi`. Будь-який сервер може досягти інших серверів безпосередньо або опосередковано через мережу.\n\n**Критичне з'єднання** — це з'єднання, яке, якщо його видалити, призведе до того, що деякі сервери не зможуть досягти інших серверів.\n\nПоверніть усі критичні з'єднання в мережі в будь-якому порядку.\n\n**Приклад 1:**\n```\nInput: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]\nOutput: [[1,3]]\nExplanation: [[3,1]] також приймається.\n```",
        "explanation": {
            "understanding_the_problem": "Нам потрібно знайти ребра в графі, видалення яких збільшило б кількість складових зв'язності. У теорії графів ці ребра називаються **Мостами (Bridges)**.\n\nУ прикладі вузли 0, 1 і 2 утворюють цикл (сильно зв'язану компоненту). Вузол 3 приєднаний лише до вузла 1. Якщо ми розріжемо ребро `1-3`, вузол 3 стане ізольованим. Таким чином, `1-3` є критичним з'єднанням.",
            "brute_force": "Наївний підхід полягає в переборі кожного ребра, тимчасовому видаленні його та запуску DFS/BFS, щоб перевірити, чи граф все ще зв'язаний. Якщо він незв'язаний, це ребро є критичним.\n\nЧасова складність: O(E * (V + E)), що занадто повільно для великих графів.",
            "bottleneck": "Багаторазовий обхід графа є неефективним. Нам потрібен спосіб ідентифікувати мости за один прохід.",
            "optimized_approach": "Ми можемо використовувати **Алгоритм Тар'яна для пошуку мостів** (або варіацію з використанням часу відкриття DFS та значення low-link).\n\n1.  **Ранг (Час Відкриття):** Порядок, у якому вузол відвідується під час DFS.\n2.  **Low-Link Value:** Найнижчий ранг, досяжний з поточного вузла в дереві DFS (можливо, використовуючи зворотне ребро, але не пряме ребро до батька).\n\n**Логіка:** Ребро `u-v` є мостом тоді і тільки тоді, коли `low[v] > rank[u]`. Це означає, що немає зворотного ребра від `v` або будь-якого з його нащадків до `u` або будь-якого з предків `u`. `v` 'застряг', потребуючи `u`, щоб дістатися до решти графа.",
            "algorithm_steps": "1. Ініціалізуйте масиви `rank` та `low` значенням -1. Час починається з 0.\n2. Почніть DFS з вузла 0 (або будь-якого вузла).\n3. В DFS(u, parent):\n    a. Встановіть `rank[u] = low[u] = time++`.\n    b. Ітеруйте сусідів `v`.\n    c. Якщо `v` - це батько, продовжуйте.\n    d. Якщо `v` відвіданий, оновіть `low[u] = min(low[u], rank[v])`.\n    e. Якщо `v` невідвіданий:\n        i. `DFS(v, u)`\n        ii. `low[u] = min(low[u], low[v])`\n        iii. Якщо `low[v] > rank[u]`, додайте `[u, v]` до результатів."
        },
        "quizzes": []
    },
    "code": {
        "javascript": {
            "solution": "var criticalConnections = function(n, connections) {\n    const adj = Array.from({length: n}, () => []);\n    for (const [u, v] of connections) {\n        adj[u].push(v);\n        adj[v].push(u);\n    }\n    \n    const rank = new Array(n).fill(-1);\n    const low = new Array(n).fill(-1);\n    const result = [];\n    let time = 0;\n    \n    const dfs = (u, p) => {\n        rank[u] = low[u] = time++;\n        for (const v of adj[u]) {\n            if (v === p) continue;\n            if (rank[v] !== -1) {\n                low[u] = Math.min(low[u], rank[v]);\n            } else {\n                dfs(v, u);\n                low[u] = Math.min(low[u], low[v]);\n                if (low[v] > rank[u]) {\n                    result.push([u, v]);\n                }\n            }\n        }\n    };\n    \n    dfs(0, -1);\n    return result;\n};",
            "annotations": []
        }
    },
    "complexity": {
        "time": "O(V + E)",
        "space": "O(V + E)",
        "explanation_time": "Ми виконуємо єдиний стандартний обхід DFS графа. Ми відвідуємо кожен вузол і кожне ребро рівно один раз.",
        "explanation_space": "Список суміжності займає O(V+E). Стек рекурсії та масиви займають O(V)."
    }
}