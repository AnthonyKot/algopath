{
    "id": "graphs-2",
    "title": "Розклад Курсів II (Топологічне Сортування)",
    "difficulty": "Medium",
    "leetcode_url": "https://leetcode.com/problems/course-schedule-ii/",
    "related": [
        {
            "id": "graphs-1",
            "title": "Word Ladder",
            "category": "graphs"
        },
        {
            "id": "graphs-3",
            "title": "Network Delay Time",
            "category": "graphs"
        }
    ],
    "tags": [
        "topological-sort",
        "bfs",
        "dag"
    ],
    "follow_up": {
        "scenario": "Ви будуєте розподілену систему збірки (наприклад, Bazel) з тисячами цілей.",
        "trade_off": "Послідовне виконання занадто повільне. Знаходження допустимого порядку недостатньо; потрібна швидкість.",
        "strategy": "Паралельне топологічне сортування (Алгоритм Кана з пулом потоків). Обробляйте всі вузли з `in-degree 0` паралельно. Коли завдання завершуються, зменшуйте лічильники сусідів.",
        "answering_guide": "Пов'яжіть це з <strong>'Системами Збірки (Build Systems)'</strong>. Це показує, що ви розумієте практичне застосування DAG за межами просто абстрактних графів."
    },
    "content": {
        "problem_statement": "Всього вам потрібно пройти `numCourses` курсів, позначених від `0` до `numCourses - 1`. Вам надано масив `prerequisites`, де `prerequisites[i] = [ai, bi]` вказує, що ви **повинні** пройти курс `bi` першим, якщо хочете пройти курс `ai`.\n\nПоверніть порядок курсів, який ви повинні пройти, щоб закінчити всі курси. Якщо є багато допустимих відповідей, поверніть **будь-яку** з них. Якщо неможливо закінчити всі курси, поверніть **порожній масив**.\n\n**Приклад 1:**\n```\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: Всього потрібно пройти 4 курси. Щоб пройти курс 3, ви повинні закінчити курси 1 та 2. Обидва курси 1 та 2 слід пройти після закінчення курсу 0.\nОтже, один правильний порядок курсів - [0,1,2,3]. Інший правильний порядок - [0,2,1,3].\n```",
        "explanation": {
            "understanding_the_problem": "Це класична задача планування. У нас є набір завдань (курсів) і залежностей (пререквізитів). Правило `[a, b]` означає, що `b` має бути завершено перед `a`. Нам потрібно знайти лінійну послідовність усіх курсів, яка відповідає цим правилам.\n\nЦя задача еквівалентна знаходженню **Топологічного Сортування** орієнтованого графа. Цикл у пререквізитах (наприклад, вам потрібен курс 1 для курсу 2, і курс 2 для курсу 1) робить завершення неможливим.",
            "brute_force": "Задачу можна змоделювати як граф, де курси є вузлами, а пререквізити - орієнтованими ребрами. Для пререквізиту `[a, b]`, ми малюємо ребро `b -> a`.\n\nТопологічне сортування - це лінійне впорядкування вузлів, де для кожного ребра `u -> v`, вузол `u` йде перед вузлом `v`. Основна ідея полягає в тому, щоб завжди знаходити вузол без вхідних ребер — це курс без пререквізитів. Ми можемо помістити цей курс у наш розклад.\n\nЯк тільки ми 'проходимо' цей курс, ми можемо видалити його та його вихідні ребра з графа. Це може створити нові вузли, які тепер мають нуль вхідних ребер. Ми повторюємо цей процес, поки всі курси не будуть пройдені.",
            "bottleneck": "Хоча концепція правильна, постійне сканування графа для пошуку нового вузла з нульовим вхідним ступенем після кожного видалення є неефективним. Ми можемо зробити краще, відстежуючи вхідні ступені (in-degrees), коли вони змінюються.",
            "optimized_approach": "Більш ефективним методом є **Алгоритм Кана**, який використовує підхід, схожий на BFS. Він працює, відстежуючи 'вхідний ступінь' кожного вузла (кількість пререквізитів, які він має). Алгоритм обробляє вузли з вхідним ступенем 0, і коли він 'завершує' їх, він зменшує вхідний ступінь усіх наступних курсів, додаючи нові курси з нульовим вхідним ступенем в чергу для обробки.",
            "algorithm_steps": "1.  **Побудова Графа та Вхідних Ступенів:**\n    a.  Створіть список суміжності для представлення залежностей курсів (`graph`).\n    b.  Створіть масив `in_degree`, ініціалізований нулями, для підрахунку пререквізитів для кожного курсу.\n    c.  Для кожного пререквізиту `[course, prereq]`, додайте ребро `prereq -> course` до графа та збільште `in_degree[course]`.\n\n2.  **Ініціалізація Черги:**\n    a.  Створіть чергу.\n    b.  Додайте всі курси з вхідним ступенем 0 в чергу. Це курси без пререквізитів.\n\n3.  **Обробка Курсів:**\n    a.  Ініціалізуйте порожній список `topological_order` для збереження результату.\n    b.  Поки черга не порожня, вийміть курс `u`.\n    c.  Додайте `u` до `topological_order`.\n    d.  Для кожного сусіда `v` курсу `u` (тобто для кожного курсу, який залежить від `u`):\n        i.  Зменште `in_degree[v]`.\n        ii. Якщо `in_degree[v]` стає 0, додайте `v` в чергу.\n\n4.  **Перевірка на Цикли:**\n    a.  Якщо `topological_order` містить `numCourses` елементів, знайдено допустимий порядок. Поверніть його.\n    b.  В іншому випадку граф мав цикл, і не всі курси могли бути оброблені. Поверніть порожній масив."
        },
        "quizzes": [
            {
                "question": "Який алгоритм вирішує планування завдань із залежностями?",
                "options": [
                    "BFS",
                    "Топологічне Сортування",
                    "Дейкстра",
                    "Бінарний Пошук"
                ],
                "correct": 1
            },
            {
                "question": "Що означає 'вхідний ступінь' (in-degree) вузла?",
                "options": [
                    "Вихідні ребра",
                    "Кількість пререквізитів",
                    "Вага вузла",
                    "Відстань від джерела"
                ],
                "correct": 1
            },
            {
                "question": "Яку структуру даних використовує алгоритм Кана?",
                "options": [
                    "Стек",
                    "Черга",
                    "Купа (Heap)",
                    "Дерево"
                ],
                "correct": 1
            },
            {
                "question": "Як ми виявляємо цикл у цьому підході?",
                "options": [
                    "DFS рекурсія",
                    "Довжина результату < numCourses",
                    "Переповнення стека",
                    "Від'ємні ребра"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність?",
                "options": [
                    "O(N)",
                    "O(N²)",
                    "O(V + E)",
                    "O(N log N)"
                ],
                "correct": 2
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function findOrder(numCourses, prerequisites) {\n  const graph = Array(numCourses).fill().map(() => []);\n  const indegree = new Array(numCourses).fill(0);\n  for (let [course, pre] of prerequisites) {\n    graph[pre].push(course);\n    indegree[course]++;\n  }\n  const queue = [];\n  for (let i = 0; i < numCourses; i++) if (!indegree[i]) queue.push(i);\n  const res = [];\n  while (queue.length) {\n    const course = queue.shift();\n    res.push(course);\n    for (let nei of graph[course]) {\n      if (--indegree[nei] === 0) queue.push(nei);\n    }\n  }\n  return res.length === numCourses ? res : [];\n}",
            "annotations": [
                {
                    "lines": [
                        2,
                        3
                    ],
                    "text": "Створити список суміжності для представлення графа (залежності курсів)."
                },
                {
                    "lines": [
                        3,
                        4
                    ],
                    "text": "Створити масив In-degree: рахує, скільки пререквізитів має кожен курс."
                },
                {
                    "lines": [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    "text": "Побудувати граф: Pre -> Course. Збільшити вхідний ступінь для залежного курсу."
                },
                {
                    "lines": [
                        9,
                        10
                    ],
                    "text": "Алгоритм Кана: Ініціалізувати чергу курсами, що мають 0 пререквізитів (готові до проходження)."
                },
                {
                    "lines": [
                        11,
                        12
                    ],
                    "text": "Обробити курси в черзі (підхід, схожий на BFS)."
                },
                {
                    "lines": [
                        14,
                        15
                    ],
                    "text": "Зменшити вхідний ступінь сусідів. Якщо 0, всі пререквізити виконані -> додати в чергу."
                },
                {
                    "lines": [
                        17,
                        18
                    ],
                    "text": "Якщо довжина результату дорівнює numCourses, ми знайшли допустимий порядок. Інакше є цикл."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(V + E)",
        "space": "O(V + E)",
        "explanation_time": "Нехай V - кількість курсів, а E - кількість пререквізитів. Побудова графа і карти вхідних ступенів займає O(E) часу. Початкове сканування вузлів з нульовим вхідним ступенем займає O(V). Основний цикл BFS обробляє кожну вершину і кожне ребро рівно один раз, що займає O(V + E). Таким чином, загальна часова складність становить O(V + E).",
        "explanation_space": "Простір визначається використовуваними структурами даних. Список суміжності (`graph`) вимагає O(V + E) простору. Масив `indegree` і `queue` вимагають O(V) простору. Отже, загальна просторова складність становить O(V + E)."
    },
    "diagram": "graph TD\n    0((Course 0)) --> 1((Course 1))\n    0 --> 2((Course 2))\n    1 --> 3((Course 3))\n    2 --> 3\n    \n    classDef default fill:#fff,stroke:#333,stroke-width:2px;\n    classDef source fill:#dcfce7,stroke:#166534,stroke-width:2px; \n    classDef sink fill:#fee2e2,stroke:#991b1b,stroke-width:2px;\n    \n    class 0 source;\n    class 3 sink;"
}