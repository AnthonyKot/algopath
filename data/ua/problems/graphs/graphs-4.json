{
    "id": "graphs-4",
    "title": "Мінімальна Вартість З'єднання Точок (Алгоритм Прима)",
    "difficulty": "Medium",
    "leetcode_url": "https://leetcode.com/problems/min-cost-to-connect-all-points/",
    "related": [
        {
            "id": "graphs-3",
            "title": "Network Delay Time",
            "category": "graphs"
        },
        {
            "id": "graphs-5",
            "title": "Pacific Atlantic Water Flow",
            "category": "graphs"
        }
    ],
    "tags": [
        "mst",
        "prim",
        "greedy"
    ],
    "content": {
        "problem_statement": "Вам надано масив `points`, що представляє цілочисельні координати деяких точок на 2D-площині, де `points[i] = [xi, yi]`.\n\nВартість з'єднання двох точок `[xi, yi]` та `[xj, yj]` дорівнює **Манхеттенській відстані** між ними: `|xi - xj| + |yi - yj|`.\n\nПоверніть мінімальну вартість, щоб з'єднати всі точки. Всі точки з'єднані, якщо існує рівно один простий шлях між будь-якими двома точками.\n\n**Приклад 1:**\n```\nInput: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20\n```",
        "explanation": {
            "understanding_the_problem": "Нам дано набір точок, і нас просять з'єднати їх усі з мінімально можливою загальною вартістю. Правило, що 'існує рівно один простий шлях між будь-якими двома точками', є визначенням **дерева**.\n\nОтже, завдання просить нас знайти **Мінімальне Кістякове Дерево (MST)**. Ми можемо уявити це як повний граф, де кожна точка є вузлом, а ребро існує між кожною парою точок, зважене їх Манхеттенською відстанню.",
            "brute_force": "Існує два основні жадібні алгоритми для пошуку MST: Прима та Крускала.\n\n- **Алгоритм Крускала:** Сортує всі можливі ребра за вагою та додає найменші, які не утворюють циклу. Це чудово підходить для розріджених графів.\n- **Алгоритм Прима:** Вирощує MST з одного початкового вузла, на кожному кроці додаючи найдешевше ребро, яке з'єднує вузол в MST з вузлом поза ним.\n\nОскільки наш граф **щільний** (повний граф, де кожна точка з'єднана з кожною іншою), алгоритм Прима є дуже природним і ефективним вибором.",
            "bottleneck": "Наївна реалізація Прима може включати складні структури даних. Однак, проста версія є досить елегантною і легкою в реалізації, особливо коли граф щільний, що робить її чудовим підходом для цієї задачі.",
            "optimized_approach": "Ми будемо використовувати алгоритм Прима. Основна ідея полягає в тому, щоб підтримувати набір відвіданих вузлів (частина нашого зростаючого MST) і для кожного невідвіданого вузла відстежувати мінімальну вартість з'єднання його з *будь-яким* вузлом у відвіданому наборі. На кожному кроці ми жадібно вибираємо невідвіданий вузол з найменшою вартістю з'єднання, додаємо його до нашого MST, а потім оновлюємо вартості з'єднання для всіх решти невідвіданих вузлів.",
            "algorithm_steps": "1.  **Ініціалізація:**\n    a.  Створіть масив `min_dist` розміром N (кількість точок), ініціалізований `Infinity`. Це зберігає мінімальну вартість з'єднання кожної точки зі зростаючим MST. Виберіть початкову точку (наприклад, вузол 0) і встановіть її відстань на 0.\n    b.  Створіть набір `visited` для відстеження точок, вже включених до MST.\n    c.  Ініціалізуйте `total_cost = 0`.\n\n2.  **Основний Цикл:** Повторіть N разів:\n    a.  **Вибір Наступного Вузла:** Знайдіть невідвіданий вузол `u`, який має найменше значення в масиві `min_dist`. Це найдешевша точка для додавання до нашого MST.\n    b.  **Додати до MST:** Якщо такий вузол не знайдено (або його відстань нескінченність), зупиніться. В іншому випадку, позначте `u` як відвідане і додайте його значення `min_dist` до `total_cost`.\n    c.  **Оновлення Відстаней:** Для кожного іншого невідвіданого вузла `v` обчисліть Манхеттенську відстань від `u` до `v`. Оновіть `min_dist[v]`, щоб воно було мінімумом з його поточного значення та цієї нової відстані.\n\n3.  **Повернути Результат:** Після завершення циклу, `total_cost` міститиме вагу MST."
        },
        "quizzes": [
            {
                "question": "Яку задачу розв'язує MST?",
                "options": [
                    "Найкоротший шлях",
                    "Мінімальна вартість з'єднання всіх вузлів",
                    "Максимальний потік",
                    "Виявлення цикли"
                ],
                "correct": 1
            },
            {
                "question": "Який алгоритм вирощує MST з одного вузла?",
                "options": [
                    "Крускала",
                    "Прима",
                    "Дейкстри",
                    "Беллмана-Форда"
                ],
                "correct": 1
            },
            {
                "question": "Який жадібний вибір робить алгоритм Прима?",
                "options": [
                    "Найдовше ребро",
                    "Найдешевше ребро до невідвіданого вузла",
                    "Випадкове ребро",
                    "Найбільш зв'язаний вузол"
                ],
                "correct": 1
            },
            {
                "question": "Що таке Манхеттенська відстань?",
                "options": [
                    "|x₁-x₂| + |y₁-y₂|",
                    "√((x₁-x₂)² + (y₁-y₂)²)",
                    "max(|x₁-x₂|, |y₁-y₂|)",
                    "min(|x₁-x₂|, |y₁-y₂|)"
                ],
                "correct": 0
            },
            {
                "question": "Яка часова складність алгоритму Прима для щільних графів?",
                "options": [
                    "O(N)",
                    "O(N log N)",
                    "O(N²)",
                    "O(N³)"
                ],
                "correct": 2
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function minCostConnectPoints(points) {\n  const n = points.length;\n  const visited = new Set();\n  let minCost = 0;\n  const dist = (a,b) => Math.abs(a[0]-b[0]) + Math.abs(a[1]-b[1]);\n  const minDist = new Array(n).fill(Infinity);\n  minDist[0] = 0;\n  for (let i = 0; i < n; i++) {\n    let u = -1;\n    for (let j = 0; j < n; j++) {\n      if (!visited.has(j) && (u === -1 || minDist[j] < minDist[u])) {\n        u = j;\n      }\n    }\n    visited.add(u);\n    minCost += minDist[u];\n    for (let j = 0; j < n; j++) {\n      if (!visited.has(j)) {\n        const d = dist(points[u], points[j]);\n        minDist[j] = Math.min(minDist[j], d);\n      }\n    }\n  }\n  return minCost;\n}",
            "annotations": [
                {
                    "lines": [
                        4
                    ],
                    "text": "Допоміжна функція для обчислення Манхеттенської відстані між двома точками."
                },
                {
                    "lines": [
                        5,
                        6
                    ],
                    "text": "Алгоритм Прима: Відстежуйте мін. вартість з'єднання кожного вузла з MST. Почніть з вузла 0 (вартість 0)."
                },
                {
                    "lines": [
                        7
                    ],
                    "text": "Основний цикл: додати N точок до MST одну за одною."
                },
                {
                    "lines": [
                        12
                    ],
                    "text": "Жадібний крок: Знайти невідвіданий вузол 'u' з найменшою вартістю з'єднання з поточним MST."
                },
                {
                    "lines": [
                        14,
                        15
                    ],
                    "text": "Додати 'u' до MST і додати його вартість до загальної."
                },
                {
                    "lines": [
                        16,
                        17,
                        18
                    ],
                    "text": "Крок оновлення: Оновити вартості з'єднання для всіх решти невідвіданих сусідів вузла 'u'."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N²)",
        "space": "O(N)",
        "explanation_time": "Нехай N — кількість точок. Основний цикл виконується N разів. Усередині цього циклу ми маємо два вкладених цикли: один для пошуку невідвіданого вузла з мінімальною відстанню (що займає O(N) часу) та інший для оновлення відстаней до всіх інших невідвіданих вузлів (також O(N)). Це призводить до загальної часової складності O(N * N) = O(N²).",
        "explanation_space": "Ми використовуємо масив `minDist` розміром N і набір `visited`, який може зрости до розміру N. Обидва вимагають O(N) простору. Тому загальна просторова складність становить O(N)."
    },
    "diagram": "graph TD\n    0(\"[0,0]\") ---|4| 1(\"[2,2]\")\n    1 ---|3| 3(\"[5,2]\")\n    3 ---|4| 4(\"[7,0]\")\n    1 ---|9| 2(\"[3,10]\")\n    \n    classDef default fill:#fff,stroke:#333,stroke-width:2px;\n    classDef mst fill:#dcfce7,stroke:#166534,stroke-width:2px;\n    \n    class 0,1,2,3,4 mst;"
}