{
    "id": "graphs-3",
    "title": "Час Затримки Мережі (Дейкстра)",
    "difficulty": "Середній",
    "leetcode_url": "https://leetcode.com/problems/network-delay-time/",
    "related": [
        {
            "id": "graphs-2",
            "title": "Course Schedule II",
            "category": "graphs"
        },
        {
            "id": "graphs-4",
            "title": "Min Cost to Connect Points",
            "category": "graphs"
        }
    ],
    "tags": [
        "dijkstra",
        "shortest-path",
        "priority-queue"
    ],
    "content": {
        "problem_statement": "Вам надано мережу з `n` вузлів, позначених від `1` до `n`. Вам також надано `times`, список часу подорожі як орієнтованих ребер `times[i] = [u, v, w]`, де `u` - це вихідний вузол, `v` - цільовий вузол, а `w` - час, необхідний для подорожі сигналу від джерела до цілі.\n\nМи надішлемо сигнал з даного вузла `k`. Поверніть час, необхідний для того, щоб усі `n` вузлів отримали сигнал. Якщо неможливо, щоб усі `n` вузлів отримали сигнал, поверніть `-1`.\n\n**Приклад 1:**\n```\nInput: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\nOutput: 2\n```",
        "explanation": {
            "understanding_the_problem": "У нас є мережа вузлів зі зваженими орієнтованими зв'язками (час подорожі). Сигнал починається у вихідному вузлі `K` і поширюється через мережу. Час, за який сигнал досягне будь-якого даного вузла, є часом найкоротшого шляху від `K` до цього вузла.\n\nЗавдання запитує час, необхідний для того, щоб *вся мережа* отримала сигнал. Це означає, що ми повинні знайти найкоротший шлях від `K` до всіх інших вузлів, і відповіддю буде *найдовший* з цих найкоротших шляхів. Якщо будь-який вузол недосяжний, час його найкоротшого шляху буде нескінченністю, і неможливо попередити всю мережу.",
            "brute_force": "Це класична задача **найкоротшого шляху з єдиним джерелом** на зваженому орієнтованому графі. Вузли - це вузли мережі, ребра - це час подорожі, а джерело - `K`.\n\nОскільки ваги ребер (час) невід'ємні, це ідеальний сценарій для **Алгоритму Дейкстри**. Алгоритм Дейкстри - це жадібний алгоритм, який знаходить найкоротші шляхи від одного джерела до всіх інших вузлів у графі.",
            "bottleneck": "Наївна реалізація Дейкстри може багаторазово сканувати всі вузли, щоб знайти невідвіданий вузол з найменшою поточною відстанню. Це було б повільно, близько O(V²). Ключем до ефективної реалізації є використання структури даних, яка може швидко надати вузол з мінімальною відстанню.",
            "optimized_approach": "Стандартний та ефективний спосіб реалізації Дейкстри - використання **Черги з Пріоритетом (Min-Priority Queue)**. Черга з пріоритетом зберігатиме пари `[time, node]`, завжди впорядковані за найменшим часом. Це дозволяє нам жадібно та ефективно вибирати наступний вузол для відвідування — той, що найближчий до джерела серед усіх вузлів, яких ми досягли, але ще не фіналізували.",
            "algorithm_steps": "1.  **Побудова Графа:** Створіть список суміжності, де `graph[u]` зберігає список його сусідів і відповідний час подорожі, наприклад `[v, w]`.\n2.  **Ініціалізація:**\n    a.  Створіть масив `distances` для зберігання найкоротшого часу від `K` до кожного вузла. Ініціалізуйте всі значення як `Infinity` і встановіть `distances[K] = 0`.\n    b.  Помістіть початковий стан `[0, K]` (що представляє `[time, node]`) у чергу з мінімальним пріоритетом.\n3.  **Обробка Вузлів (Цикл Дейкстри):**\n    a.  Поки черга з пріоритетом не порожня, витягніть стан з найменшим часом: `[currentTime, currentNode]`.\n    b.  Якщо `currentTime` вже більший за `distances[currentNode]`, це застарілий, довший шлях. Ігноруйте його і продовжуйте.\n    c.  Для кожного сусіда `[neighborNode, travelTime]` вузла `currentNode`:\n        i.  Якщо `currentTime + travelTime < distances[neighborNode]`, ми знайшли коротший шлях.\n        ii. Оновіть `distances[neighborNode]` на цей новий, коротший час і додайте `[newTime, neighborNode]` до черги з пріоритетом.\n4.  **Знаходження Результату:**\n    a.  Після циклу знайдіть максимальне значення в масиві `distances`.\n    b.  Якщо це максимальне значення дорівнює `Infinity`, принаймні один вузол був недосяжним, тому поверніть -1. В іншому випадку поверніть максимальне значення."
        },
        "quizzes": [
            {
                "question": "Який алгоритм знаходить найкоротші шляхи з єдиним джерелом з невід'ємними вагами?",
                "options": [
                    "BFS",
                    "DFS",
                    "Дейкстра",
                    "Беллман-Форд"
                ],
                "correct": 2
            },
            {
                "question": "Яка структура даних робить Дейкстру ефективним?",
                "options": [
                    "Стек",
                    "Масив",
                    "Min-Priority Queue",
                    "Хеш-таблиця"
                ],
                "correct": 2
            },
            {
                "question": "Чому Дейкстра не може обробляти від'ємні ваги ребер?",
                "options": [
                    "Переповнення пам'яті",
                    "Жадібне припущення ламається",
                    "Занадто повільно",
                    "Не може їх представити"
                ],
                "correct": 1
            },
            {
                "question": "Що таке 'релаксація' в алгоритмі Дейкстри?",
                "options": [
                    "Видалення ребер",
                    "Оновлення коротшої відстані шляху",
                    "Додавання вузлів",
                    "Сортування ребер"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність з купою?",
                "options": [
                    "O(V)",
                    "O(V²)",
                    "O(E log V)",
                    "O(V³)"
                ],
                "correct": 2
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function networkDelayTime(times, N, K) {\n  const adj = Array(N+1).fill().map(() => []);\n  for (let [u,v,w] of times) {\n    adj[u].push([v,w]);\n  }\n  const dist = new Array(N+1).fill(Infinity);\n  dist[K] = 0;\n  const pq = [[0, K]];\n  while (pq.length) {\n    const [d, u] = pq.shift();\n    if (d > dist[u]) continue;\n    for (let [v,w] of adj[u]) {\n      if (dist[v] > d + w) {\n        dist[v] = d + w;\n        pq.push([dist[v], v]);\n        pq.sort((a,b) => a[0] - b[0]);\n      }\n    }\n  }\n  const maxTime = Math.max(...dist.slice(1));\n  return maxTime === Infinity ? -1 : maxTime;\n}",
            "annotations": [
                {
                    "lines": [
                        2,
                        3,
                        4
                    ],
                    "text": "Побудувати список суміжності: Вузол -> [[Сусід, Вага]]."
                },
                {
                    "lines": [
                        6
                    ],
                    "text": "Ініціалізувати відстані як Infinity. Відстань до джерела дорівнює 0."
                },
                {
                    "lines": [
                        8
                    ],
                    "text": "Min-Priority Queue: зберігає [час, вузол]. Симуляція за допомогою масиву + сортування."
                },
                {
                    "lines": [
                        10
                    ],
                    "text": "Основний цикл Дейкстри: обробляти найближчий вузол першим."
                },
                {
                    "lines": [
                        11
                    ],
                    "text": "Оптимізація: Якщо поточний шлях довший за вже знайдений найкоротший шлях, пропустити."
                },
                {
                    "lines": [
                        13
                    ],
                    "text": "Релаксація: Якщо шлях через u до v коротший за поточний відомий шлях до v, оновити його."
                },
                {
                    "lines": [
                        15,
                        16
                    ],
                    "text": "Додати новий найкоротший шлях до PQ. Сортувати для підтримки властивості min-heap (спрощення)."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(E log V)",
        "space": "O(V + E)",
        "explanation_time": "Нехай V — кількість вузлів, а E — кількість ребер. Складність визначається операціями черги з пріоритетом. У гіршому випадку ми можемо додати запис до черги з пріоритетом для кожного ребра в графі. Кожна операція push або pop у черзі з мінімальним пріоритетом займає O(log V) часу. Отже, загальна часова складність становить O(E log V). (Примітка: Приклад коду симулює PQ шляхом сортування масиву, що є менш ефективним, ніж справжня купа).",
        "explanation_space": "Список суміжності вимагає O(V + E) простору. Масив `dist` вимагає O(V) простору, а черга з пріоритетом може містити до V вузлів, що вимагає O(V) простору. Це призводить до загальної просторової складності O(V + E)."
    },
    "diagram": "graph LR\n    2((2)) -->|1| 1((1))\n    2 -->|1| 3((3))\n    3 -->|1| 4((4))\n    \n    classDef default fill:#fff,stroke:#333,stroke-width:2px;\n    classDef source fill:#dcfce7,stroke:#166534,stroke-width:2px;\n    \n    class 2 source;"
}