{
    "id": "graphs-1",
    "title": "Драбина Слів (Найкоротший Шлях)",
    "difficulty": "Середній",
    "tags": [
        "bfs",
        "shortest-path",
        "strings"
    ],
    "follow_up": {
        "scenario": "Вам потрібно знайти шлях у графі з мільйонами вузлів (наприклад, зв'язки в соціальній мережі).",
        "trade_off": "Стандартний BFS досліджує занадто багато вузлів (експоненціальне зростання межі пошуку).",
        "strategy": "Двонаправлений BFS. Почніть одночасно і з джерела, і з пункту призначення. Зменшує часову складність з O(b^d) до O(b^(d/2)).",
        "answering_guide": "Згадка про <strong>'Двонаправлений BFS'</strong> є ключовим фактором, що відрізняє рівень L4 від L5 тут. Поясніть, <em>чому</em> це швидше (коефіцієнт розгалуження)."
    },
    "content": {
        "problem_statement": "**Послідовність перетворень** від слова `beginWord` до слова `endWord`, використовуючи словник `wordList`, — це послідовність слів `beginWord -> s1 -> s2 -> ... -> sk`, така що:\n\n1.  Кожна суміжна пара слів відрізняється однією літерою.\n2.  Кожне `si` для `1 <= i <= k` знаходиться у `wordList`. Зауважте, що `beginWord` не обов'язково має бути у `wordList`.\n3.  `sk == endWord`\n\nДано два слова, `beginWord` та `endWord`, і словник `wordList`, поверніть **кількість слів** у **найкоротшій послідовності перетворень** від `beginWord` до `endWord`, або `0`, якщо такої послідовності не існує.\n\n**Приклад 1:**\n```\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: Одна з найкоротших послідовностей перетворень: \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", яка складається з 5 слів.\n```",
        "explanation": {
            "understanding_the_problem": "Нас просять знайти *найкоротшу* послідовність перетворень, щоб дістатися від початкового слова до кінцевого. Єдине допустиме перетворення — це зміна однієї літери, і отримане слово має бути в заданому словнику. Цю задачу можна ідеально змоделювати як пошук найкоротшого шляху в графі.",
            "brute_force": "Простий спосіб візуалізувати це — граф, де кожне слово є вузлом. Ребро існує між двома вузлами-словами, якщо вони відрізняються на одну літеру. Наше завдання — знайти найкоротший шлях від вузла `beginWord` до вузла `endWord`.\n\nПошук в глибину (DFS) міг би дослідити шляхи. Ми б почали з `beginWord`, знайшли всі пов'язані слова (що відрізняються однією літерою) і рекурсивно досліджували кожне з них, відстежуючи довжину шляху. Нам знадобився б набір `visited`, щоб уникнути циклів (наприклад, `hit` -> `hot` -> `hit`).",
            "bottleneck": "DFS глибоко досліджує шляхи. Він може слідувати дуже довгим, звивистим шляхом перетворень до кінця, перш ніж навіть розгляне інший, набагато коротший шлях. Щоб знайти найкоротший шлях, DFS довелося б дослідити *кожен можливий шлях* між `beginWord` та `endWord`, що є дуже неефективним.",
            "optimized_approach": "Завдання вимагає знайти **найкоротший шлях** у тому, що фактично є **незваженим графом** (кожне перетворення коштує 1). Це класичний випадок використання **Пошуку в Ширину (BFS)**.\n\nBFS досліджує граф шар за шаром. Він починається з `beginWord` (шар 0), потім знаходить всі слова, що знаходяться на відстані 1 зміни (шар 1), потім всі слова на відстані 2 змін (шар 2) і так далі. Завдяки такому пошаровому дослідженню, як тільки BFS вперше досягає `endWord`, гарантується, що це було зроблено найкоротшим можливим шляхом.",
            "algorithm_steps": "1.  **Попередня обробка:** Додайте всі слова з `wordList` до `Set` для ефективного пошуку O(1). Цей набір також слугуватиме нашим набором 'невідвіданих'.\n2.  **Ініціалізація:** Створіть чергу `Queue` і додайте початковий стан: `[beginWord, 1]`, що представляє слово і поточну довжину шляху.\n3.  **Цикл BFS:** Поки черга не порожня:\n    a.  Вийміть з черги поточний стан: `[currentWord, currentLength]`.\n    b.  Якщо `currentWord` - це `endWord`, ми знайшли найкоротший шлях. Поверніть `currentLength`.\n    c.  **Генерація Сусідів:** Знайдіть всі можливі наступні слова, перебираючи кожен символ `currentWord` і замінюючи його кожною літерою від 'a' до 'z'.\n    d.  **Перевірка та Додавання в Чергу:** Для кожного згенерованого `newWord`:\n        i.  Якщо `newWord` існує в нашому наборі слів, це допустиме перетворення.\n        ii. Додайте новий стан `[newWord, currentLength + 1]` в чергу.\n        iii. **Важливо: видаліть `newWord` з набору слів.** Це позначає його як 'відвідане', запобігаючи повторній обробці та застряганню в циклах.\n4.  **Шляху немає:** Якщо черга стає порожньою, і ми так і не досягли `endWord`, такого шляху не існує. Поверніть 0."
        },
        "quizzes": [
            {
                "question": "Як ми можемо змоделювати цю задачу?",
                "options": [
                    "Дерево",
                    "Граф з ребрами між схожими словами",
                    "Масив",
                    "Стек"
                ],
                "correct": 1
            },
            {
                "question": "Чому DFS неефективний для пошуку найкоротшого шляху?",
                "options": [
                    "Забагато пам'яті",
                    "Досліджує довгі шляхи першим",
                    "Не може обробляти цикли",
                    "Занадто повільний"
                ],
                "correct": 1
            },
            {
                "question": "Який алгоритм знаходить найкоротший шлях у незважених графах?",
                "options": [
                    "DFS",
                    "Дейкстра",
                    "BFS",
                    "Беллман-Форд"
                ],
                "correct": 2
            },
            {
                "question": "Навіщо використовувати Set замість Array для списку слів?",
                "options": [
                    "Менше пам'яті",
                    "Пошук за O(1)",
                    "Легше перебирати (ітерувати)",
                    "Зберігає порядок"
                ],
                "correct": 1
            },
            {
                "question": "Що гарантує, що BFS знайде найкоротший шлях?",
                "options": [
                    "Випадкове дослідження",
                    "Пошарове дослідження",
                    "Пріоритет глибини",
                    "Евристика"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function ladderLength(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) return 0;\n  const queue = [[beginWord, 1]];\n  wordSet.delete(beginWord);\n  while (queue.length) {\n    const [word, steps] = queue.shift();\n    if (word === endWord) return steps;\n    for (let i = 0; i < word.length; i++) {\n      for (let c = 0; c < 26; c++) {\n        const newWord = word.slice(0,i) + String.fromCharCode(97+c) + word.slice(i+1);\n        if (wordSet.has(newWord)) {\n          queue.push([newWord, steps+1]);\n          wordSet.delete(newWord);\n        }\n      }\n    }\n  }\n  return 0;\n}",
            "annotations": [
                {
                    "lines": [
                        2,
                        3
                    ],
                    "text": "Створити Set для пошуку допустимих слів за O(1). Використання Array було б занадто повільним (O(N))."
                },
                {
                    "lines": [
                        4,
                        5
                    ],
                    "text": "Ініціалізувати чергу BFS з [поточне_слово, рівень]. Рівень починається з 1."
                },
                {
                    "lines": [
                        5,
                        6
                    ],
                    "text": "Позначити початкове слово як відвідане негайно, щоб запобігти циклам."
                },
                {
                    "lines": [
                        6,
                        7
                    ],
                    "text": "Стандартний цикл BFS: обробка вузлів рівень за рівнем."
                },
                {
                    "lines": [
                        9,
                        10,
                        11
                    ],
                    "text": "Спробувати змінити кожен символ (i) на кожну літеру (a-z), щоб знайти сусідів."
                },
                {
                    "lines": [
                        12,
                        13
                    ],
                    "text": "Якщо сусід є в словнику (і не відвіданий), це допустимий наступний крок."
                },
                {
                    "lines": [
                        14,
                        15
                    ],
                    "text": "Критично: Негайно видалити з набору, щоб позначити як відвідане. Це гарантує найкоротший шлях."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(N * L²)",
        "space": "O(N * L)",
        "explanation_time": "Нехай N — кількість слів у списку, а L — довжина слів. У гіршому випадку ми відвідуємо кожне слово (N). Для кожного слова ми проходимо по його довжині (L) і пробуємо всі 26 букв алфавіту. У JavaScript створення `newWord` шляхом розрізання та конкатенації рядків займає час O(L). Це призводить до складності O(N * L * 26 * L), що спрощується до O(N * L²).",
        "explanation_space": "`wordSet` зберігає N слів, кожне середньої довжини L, що дає O(N * L) простору. Черга, у гіршому випадку, також може містити велику частину слів, що також додає O(N * L) до просторової складності."
    },
    "diagram": "graph TD\n    hit --> hot\n    hit --> dot\n    hot --> dot\n    hot --> lot\n    dot --> lot\n    dot --> dog\n    lot --> log\n    dog --> log\n    dog --> cog\n    log --> cog\n    style hit fill:#4ade80,stroke:#333,stroke-width:2px,color:#000\n    style cog fill:#f87171,stroke:#333,stroke-width:2px,color:#000\n    linkStyle default stroke:#a1a1aa,stroke-width:2px"
}