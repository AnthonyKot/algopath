{
    "id": "graphs-5",
    "title": "Тихоокеанський та Атлантичний Водний Потік",
    "difficulty": "Середній",
    "leetcode_url": "https://leetcode.com/problems/pacific-atlantic-water-flow/",
    "related": [
        {
            "id": "graphs-4",
            "title": "Min Cost to Connect Points",
            "category": "graphs"
        },
        {
            "id": "graphs-1",
            "title": "Word Ladder",
            "category": "graphs"
        }
    ],
    "tags": [
        "dfs",
        "multi-source",
        "bfs"
    ],
    "content": {
        "problem_statement": "Існує прямокутний острів розміром `m x n`, який межує як з **Тихим океаном**, так і з **Атлантичним океаном**. **Тихий океан** торкається лівого та верхнього країв острова, а **Атлантичний океан** торкається правого та нижнього країв.\n\nОстрів розділений на сітку квадратних комірок. Вам надано цілочисельну матрицю `heights` розміром `m x n`, де `heights[r][c]` представляє висоту над рівнем моря комірки з координатами `(r, c)`.\n\nНа острів випадає багато дощу, і дощова вода може текти до сусідніх комірок безпосередньо на північ, південь, схід і захід, якщо висота сусідньої комірки **менша або дорівнює** висоті поточної комірки. Вода може стікати з будь-якої комірки, що прилягає до океану, в океан.\n\nПоверніть **2D список** координат сітки `result`, де `result[i] = [ri, ci]` означає, що дощова вода може текти з комірки `(ri, ci)` до **обох** океанів: Тихого та Атлантичного.\n\n**Приклад 1:**\n```\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n```",
        "explanation": {
            "understanding_the_problem": "Уявіть, що матриця - це континент, де кожне число представляє висоту цієї ділянки землі. Краї континенту оточені двома океанами: Тихим (верхній і лівий краї) і Атлантичним (нижній і правий краї).\n\nДощ падає на континент, і вода може текти з будь-якої комірки до сусідньої комірки (вгору, вниз, вліво або вправо), якщо висота сусіда **така ж або менша**.\n\nНаша мета - знайти кожну комірку на континенті, з якої вода може текти до **обох** океанів: Тихого та Атлантичного.",
            "brute_force": "Найбільш інтуїтивно зрозумілий спосіб розв'язати це - перевіряти кожну комірку по одній. Для кожної окремої комірки `(r, c)` в матриці ми могли б почати обхід (наприклад, DFS або BFS) і поставити два запитання:\n1. Чи можемо ми дістатися до Тихого океану (верхній або лівий край)?\n2. Чи можемо ми дістатися до Атлантичного океану (нижній або правий край)?\n\nЯкщо відповідь на обидва питання 'так', ми додаємо комірку до наших результатів.",
            "bottleneck": "Цей підхід дуже повільний. Якщо матриця має `M * N` комірок, ми б виконували повний обхід для кожної з них. Це призводить до часової складності приблизно `O((MN)²)` тому, що ми повторюємо одні й ті ж обчислення шляху знову і знову.",
            "optimized_approach": "Ключова оптимізація походить від зворотного мислення. Замість того, щоб запитувати 'Куди може текти вода з цієї комірки *до*?', ми повинні запитати:\n\n**'До яких комірок може дістатися вода, що тече *від* океанів?'**\n\nЯкщо ми зможемо знайти всі комірки, які можуть досягти Тихого океану, і всі комірки, які можуть досягти Атлантичного океану, відповіддю буде просто перетин цих двох множин.",
            "algorithm_steps": "Це розуміння веде до набагато ефективнішого алгоритму з двома проходами:\n\n1.  **Створити дві сітки 'досяжності':** Ми використаємо дві булеві матриці, `can_reach_pacific` та `can_reach_atlantic`, щоб відстежувати комірки, досяжні кожним океаном.\n2.  **Почати з Тихого океану:** Почніть обхід (або BFS, або DFS) одночасно з усіх комірок, що торкаються кордону Тихого океану. Коли ми рухаємось *всередину*, ми можемо переходити з комірки до сусіда, тільки якщо висота сусіда **більша або дорівнює** висоті нашої поточної комірки (оскільки ми течемо 'вгору' від океану). Позначте кожну комірку, яку ми відвідуємо, в сітці `can_reach_pacific`.\n3.  **Почати з Атлантичного океану:** Зробіть те саме для кордону Атлантичного океану, позначаючи відвідані комірки в сітці `can_reach_atlantic`.\n4.  **Знайти Перетин:** Пройдіть через усю матрицю останній раз. Будь-яка комірка `(r, c)`, яка позначена `true` в **обох** `can_reach_pacific` та `can_reach_atlantic`, є нашою відповіддю."
        },
        "quizzes": [
            {
                "question": "Яка ключова ідея для оптимізації цієї задачі?",
                "options": [
                    "Сортувати комірки",
                    "Думати від океанів всередину",
                    "Використовувати DP",
                    "Бінарний пошук"
                ],
                "correct": 1
            },
            {
                "question": "Яка техніка обходу тут використовується?",
                "options": [
                    "BFS з одним джерелом",
                    "BFS з багатьма джерелами",
                    "Дейкстра",
                    "Тільки DFS"
                ],
                "correct": 1
            },
            {
                "question": "Як ми знаходимо комірки, що досягають обох океанів?",
                "options": [
                    "Об'єднання множин",
                    "Перетин множин",
                    "Різниця множин",
                    "XOR множин"
                ],
                "correct": 1
            },
            {
                "question": "Коли течемо 'вгору' від океану, ми переходимо до комірок з висотою...?",
                "options": [
                    "Меншою",
                    "Рівною або вищою",
                    "Точно рівною",
                    "Випадковою"
                ],
                "correct": 1
            },
            {
                "question": "Яка часова складність оптимізованого рішення?",
                "options": [
                    "O((MN)²)",
                    "O(MN)",
                    "O(M + N)",
                    "O(M log N)"
                ],
                "correct": 1
            }
        ]
    },
    "code": {
        "javascript": {
            "solution": "function pacificAtlantic(heights) {\n  const m = heights.length, n = heights[0].length;\n  const pacific = new Set(), atlantic = new Set();\n  const dirs = [[0,1],[0,-1],[1,0],[-1,0]];\n  const bfs = (starts, reachable) => {\n    const q = [...starts];\n    for (const [r,c] of starts) reachable.add(`${r},${c}`);\n    while (q.length) {\n      const [r,c] = q.shift();\n      for (const [dr,dc] of dirs) {\n        const nr = r + dr, nc = c + dc;\n        if (nr >= 0 && nr < m && nc >= 0 && nc < n &&\n            !reachable.has(`${nr},${nc}`) &&\n            heights[nr][nc] >= heights[r][c]) {\n          reachable.add(`${nr},${nc}`);\n          q.push([nr,nc]);\n        }\n      }\n    }\n  };\n  const pacificStarts = [];\n  for (let c = 0; c < n; c++) pacificStarts.push([0,c]);\n  for (let r = 0; r < m; r++) pacificStarts.push([r,0]);\n  bfs(pacificStarts, pacific);\n  const atlanticStarts = [];\n  for (let c = 0; c < n; c++) atlanticStarts.push([m-1,c]);\n  for (let r = 0; r < m; r++) atlanticStarts.push([r,n-1]);\n  bfs(atlanticStarts, atlantic);\n  const result = [];\n  for (let r = 0; r < m; r++) {\n    for (let c = 0; c < n; c++) {\n      if (pacific.has(`${r},${c}`) && atlantic.has(`${r},${c}`)) {\n        result.push([r,c]);\n      }\n    }\n  }\n  return result;\n}",
            "annotations": [
                {
                    "lines": [
                        3
                    ],
                    "text": "Використовувати Set для відстеження досяжних комірок (зберігаючи рядки 'row,col')."
                },
                {
                    "lines": [
                        5
                    ],
                    "text": "Допоміжний BFS: починається з кордонів океану і тече 'вгору'."
                },
                {
                    "lines": [
                        6,
                        7
                    ],
                    "text": "Додати початкові прикордонні комірки в чергу та позначити як досяжні."
                },
                {
                    "lines": [
                        12,
                        13,
                        14
                    ],
                    "text": "Перевірити межі, чи не відвідували, та умову висоти (сусід >= поточний)."
                },
                {
                    "lines": [
                        21,
                        22
                    ],
                    "text": "Ініціалізувати старти: Верхній рядок і Лівий стовпець для Тихого."
                },
                {
                    "lines": [
                        25,
                        26
                    ],
                    "text": "Ініціалізувати старти: Нижній рядок і Правий стовпець для Атлантичного."
                },
                {
                    "lines": [
                        31
                    ],
                    "text": "Перетин: Якщо комірка є в обох наборах, вона може текти до обох океанів."
                }
            ]
        }
    },
    "complexity": {
        "time": "O(MN)",
        "space": "O(MN)",
        "explanation_time": "Часова складність становить O(M * N), оскільки ми відвідуємо кожну комірку постійну кількість разів. Перший прохід (Тихий) відвідує кожну досяжну комірку один раз, другий прохід (Атлантичний) робить те саме, і останній прохід ітерує через усі M*N комірок, щоб знайти перетин. Це дає нам лінійну часову складність відносно кількості комірок.",
        "explanation_space": "Просторова складність становить O(M * N), оскільки ми використовуємо дві додаткові булеві матриці/набори (`pacific` та `atlantic`) того ж розміру, що й вхідна сітка, щоб зберігати інформацію про досяжність. Стек рекурсії (для DFS) або черга (для BFS) також можуть займати до O(M*N) місця в найгіршому сценарії, коли всі комірки досяжні з океану."
    }
}