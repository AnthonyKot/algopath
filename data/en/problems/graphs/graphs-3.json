{
  "id": "graphs-3",
  "title": "Network Delay Time (Dijkstra)",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/network-delay-time/",
  "related": [
    {
      "id": "graphs-2",
      "title": "Course Schedule II",
      "category": "graphs"
    },
    {
      "id": "graphs-4",
      "title": "Min Cost to Connect Points",
      "category": "graphs"
    }
  ],
  "tags": [
    "dijkstra",
    "shortest-path",
    "priority-queue"
  ],
  "content": {
    "problem_statement": "You are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = [u, v, w]`, where `u` is the source node, `v` is the target node, and `w` is the time it takes for a signal to travel from source to target.\n\nWe will send a signal from a given node `k`. Return the time it takes for all `n` nodes to receive the signal. If it is impossible for all `n` nodes to receive the signal, return `-1`.\n\n**Example 1:**\n```\nInput: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\nOutput: 2\n```",
    "explanation": {
      "understanding_the_problem": "We have a network of nodes with weighted directed connections (travel times). A signal starts at a source node `K` and propagates through the network. The time for the signal to reach any given node is the shortest path time from `K` to that node.\n\nThe problem asks for the time it takes for the *entire network* to get the signal. This means we must find the shortest path from `K` to all other nodes, and the answer will be the *longest* of these shortest paths. If any node is unreachable, its shortest path time will be infinity, and it's impossible to alert the whole network.",
      "brute_force": "This is a classic **single-source shortest path** problem on a weighted, directed graph. The nodes are the network nodes, the edges are the travel times, and the source is `K`.\n\nSince the edge weights (times) are non-negative, this is a perfect scenario for **Dijkstra's Algorithm**. Dijkstra's is a greedy algorithm that finds the shortest paths from a single source to all other nodes in a graph.",
      "bottleneck": "A naive implementation of Dijkstra's might repeatedly scan all nodes to find the unvisited node with the smallest current distance. This would be slow, around O(V²). The key to an efficient implementation is using a data structure that can quickly provide the node with the minimum distance.",
      "optimized_approach": "The standard and efficient way to implement Dijkstra's is by using a **Min-Priority Queue**. The priority queue will store pairs of `[time, node]`, always ordered by the smallest time. This allows us to greedily and efficiently select the next node to visit—the one that is closest to the source among all nodes we've reached but not yet finalized.",
      "algorithm_steps": "1.  **Build the Graph:** Create an adjacency list where `graph[u]` stores a list of its neighbors and the corresponding travel times, like `[v, w]`.\n2.  **Initialization:**\n    a.  Create a `distances` array to store the shortest time from `K` to every node. Initialize all values to `Infinity` and set `distances[K] = 0`.\n    b.  Push the starting state `[0, K]` (representing `[time, node]`) into a min-priority queue.\n3.  **Process Nodes (Dijkstra's Loop):**\n    a.  While the priority queue is not empty, extract the state with the smallest time: `[currentTime, currentNode]`.\n    b.  If `currentTime` is already greater than `distances[currentNode]`, it's a stale, longer path. Ignore it and continue.\n    c.  For each neighbor `[neighborNode, travelTime]` of `currentNode`:\n        i.  If `currentTime + travelTime < distances[neighborNode]`, we've found a shorter path.\n        ii. Update `distances[neighborNode]` to this new, shorter time and push `[newTime, neighborNode]` to the priority queue.\n4.  **Find the Result:**\n    a.  After the loop, find the maximum value in the `distances` array.\n    b.  If this max value is `Infinity`, at least one node was unreachable, so return -1. Otherwise, return the max value."
    },
    "quizzes": [
      {
        "question": "What algorithm finds single-source shortest paths with non-negative weights?",
        "options": [
          "BFS",
          "DFS",
          "Dijkstra",
          "Bellman-Ford"
        ],
        "correct": 2
      },
      {
        "question": "What data structure makes Dijkstra efficient?",
        "options": [
          "Stack",
          "Array",
          "Min-Priority Queue",
          "Hash Table"
        ],
        "correct": 2
      },
      {
        "question": "Why can't Dijkstra handle negative edge weights?",
        "options": [
          "Memory overflow",
          "Greedy assumption breaks",
          "Too slow",
          "Can't represent them"
        ],
        "correct": 1
      },
      {
        "question": "What is 'relaxation' in Dijkstra?",
        "options": [
          "Removing edges",
          "Updating shorter path distance",
          "Adding nodes",
          "Sorting edges"
        ],
        "correct": 1
      },
      {
        "question": "What's the time complexity with a heap?",
        "options": [
          "O(V)",
          "O(V²)",
          "O(E log V)",
          "O(V³)"
        ],
        "correct": 2
      }
    ]
  },
  "code": {
    "javascript": {
      "solution": "function networkDelayTime(times, N, K) {\n  const adj = Array(N+1).fill().map(() => []);\n  for (let [u,v,w] of times) {\n    adj[u].push([v,w]);\n  }\n  const dist = new Array(N+1).fill(Infinity);\n  dist[K] = 0;\n  const pq = [[0, K]];\n  while (pq.length) {\n    const [d, u] = pq.shift();\n    if (d > dist[u]) continue;\n    for (let [v,w] of adj[u]) {\n      if (dist[v] > d + w) {\n        dist[v] = d + w;\n        pq.push([dist[v], v]);\n        pq.sort((a,b) => a[0] - b[0]);\n      }\n    }\n  }\n  const maxTime = Math.max(...dist.slice(1));\n  return maxTime === Infinity ? -1 : maxTime;\n}",
      "annotations": [
        {
          "lines": [
            2,
            3,
            4
          ],
          "text": "Build adjacency list: Node -> [[Neighbor, Weight]]."
        },
        {
          "lines": [
            6
          ],
          "text": "Initialize distances to Infinity. Source node distance is 0."
        },
        {
          "lines": [
            8
          ],
          "text": "Min-Priority Queue: stores [time, node]. Simulating with array + sort."
        },
        {
          "lines": [
            10
          ],
          "text": "Dijkstra's main loop: process closest node first."
        },
        {
          "lines": [
            11
          ],
          "text": "Optimization: If current path is longer than already found shortest path, skip."
        },
        {
          "lines": [
            13
          ],
          "text": "Relaxation: If path through u to v is shorter than current known path to v, update it."
        },
        {
          "lines": [
            15,
            16
          ],
          "text": "Push new shortest path to PQ. Sort to maintain min-heap property (simplification)."
        }
      ]
    }
  },
  "complexity": {
    "time": "O(E log V)",
    "space": "O(V + E)",
    "explanation_time": "Let V be the number of nodes and E be the number of edges. The complexity is dominated by the priority queue operations. In the worst case, we may add an entry to the priority queue for every edge in the graph. Each push or pop operation on a min-priority queue takes O(log V) time. Therefore, the total time complexity is O(E log V). (Note: The sample code simulates a PQ by sorting an array, which is less efficient than a true heap-based priority queue).",
    "explanation_space": "The adjacency list requires O(V + E) space. The `dist` array requires O(V) space, and the priority queue can hold up to V nodes, requiring O(V) space. This results in a total space complexity of O(V + E)."
  },
  "diagram": "graph LR\n    2((2)) -->|1| 1((1))\n    2 -->|1| 3((3))\n    3 -->|1| 4((4))\n    \n    classDef default fill:#fff,stroke:#333,stroke-width:2px;\n    classDef source fill:#dcfce7,stroke:#166534,stroke-width:2px;\n    \n    class 2 source;"
}