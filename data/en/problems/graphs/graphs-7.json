{
  "id": "graphs-7",
  "title": "Cheapest Flights Within K Stops",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/cheapest-flights-within-k-stops/",
  "related": [
    {
      "id": "graphs-2",
      "title": "Network Delay Time",
      "category": "graphs"
    },
    {
      "id": "graphs-3",
      "title": "Course Schedule II",
      "category": "graphs"
    }
  ],
  "tags": [
    "bfs",
    "dijkstra",
    "bellman-ford"
  ],
  "content": {
    "problem_statement": "There are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there is a flight from city `fromi` to city `toi` with cost `pricei`.\n\nYou are also given three integers `src`, `dst`, and `k`, return the **cheapest price** from `src` to `dst` with at most `k` stops. If there is no such route, return `-1`.\n\n**Example 1:**\n```\nInput: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1\nOutput: 700\nExplanation:\nThe path 0 -> 1 -> 3 costs 100 + 600 = 700.\nThe path 0 -> 1 -> 2 -> 3 costs 100 + 100 + 200 = 400, but it has 2 stops (exceeding k=1).\n```",
    "explanation": {
      "understanding_the_problem": "We need to find the shortest path in a weighted graph, but with a constraint on the number of edges (stops). A stop is an intermediate city, so `k` stops means we can visit at most `k+1` edges.\n\nThis is not a standard pure Dijkstra because a longer path (more stops) might be cheaper, but we are limited by stops. A cheaper path with too many stops is invalid.",
      "brute_force": "DFS can explore all paths from `src` to `dst`. We can track the current cost and current stops.\n`DFS(city, cost, stops)`\nHowever, without memoization, this is exponential.",
      "bottleneck": "Standard Dijkstra is greedy and might discard a path with more stops but cheaper cost if it's not the absolute shortest path found so far *to that node*. We need to track `(cost, stops)` or relax edges differently.",
      "optimized_approach": "Allowed approaches:\n1.  **Bellman-Ford:** Run the outer loop `k+1` times. This naturally explores paths of length 1, then 2, ..., up to `k+1` edges. This is very intuitive for 'at most k stops'.\n2.  **BFS / Modified Dijkstra:** Use a priority queue `(cost, city, stops)`. Standard Dijkstra but we only add a node to the queue if we found a cheaper way to reach it *or* a way to reach it with fewer stops.",
      "algorithm_steps": "**Bellman-Ford Approach:**\n1.  Initialize `prices` array with Infinity, `prices[src] = 0`.\n2.  Loop `k + 1` times:\n    a. Create `tempPrices` copy of `prices`.\n    b. Iterate through every flight `[u, v, w]`.\n    c. If `prices[u]` is reachable, `tempPrices[v] = min(tempPrices[v], prices[u] + w)`.\n    d. Update `prices = tempPrices`.\n3.  Return `prices[dst]` if not Infinity, else -1."
    },
    "quizzes": []
  },
  "code": {
    "javascript": {
      "solution": "var findCheapestPrice = function(n, flights, src, dst, k) {\n    let prices = new Array(n).fill(Infinity);\n    prices[src] = 0;\n    \n    for (let i = 0; i < k + 1; i++) {\n        const tempPrices = [...prices];\n        for (const [u, v, w] of flights) {\n            if (prices[u] === Infinity) continue;\n            if (prices[u] + w < tempPrices[v]) {\n                tempPrices[v] = prices[u] + w;\n            }\n        }\n        prices = tempPrices;\n    }\n    \n    return prices[dst] === Infinity ? -1 : prices[dst];\n};",
      "annotations": []
    }
  },
  "complexity": {
    "time": "O((K + 1) * E)",
    "space": "O(N)",
    "explanation_time": "We iterate `K + 1` times. In each iteration, we iterate through all `E` flights (edges).",
    "explanation_space": "We perform the operations using two arrays (`prices` and `tempPrices`) of size N."
  },
  "diagram": "graph LR\n    0((0)) -- \"100\" --> 1((1))\n    1 -- \"100\" --> 2((2))\n    2 -- \"100\" --> 0\n    1 -- \"600\" --> 3((3))\n    2 -- \"200\" --> 3\n    \n    linkStyle 0,3 stroke:#22c55e,stroke-width:4px;\n    linkStyle 1,2,4 stroke:#94a3b8,stroke-width:2px;"
}