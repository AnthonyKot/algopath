{
  "id": "graphs-6",
  "title": "Critical Connections in a Network",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/critical-connections-in-a-network/",
  "related": [
    {
      "id": "graphs-1",
      "title": "Word Ladder",
      "category": "graphs"
    }
  ],
  "tags": [
    "dfs",
    "tarjan",
    "bridges"
  ],
  "content": {
    "problem_statement": "There are `n` servers numbered from `0` to `n - 1` connected by undirected server-to-server `connections` forming a network where `connections[i] = [ai, bi]` represents a connection between servers `ai` and `bi`. Any server can reach other servers directly or indirectly through the network.\n\nA **critical connection** is a connection that, if removed, will make some servers unable to reach some other server.\n\nReturn all critical connections in the network in any order.\n\n**Example 1:**\n```\nInput: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]\nOutput: [[1,3]]\nExplanation: [[3,1]] is also accepted.\n```",
    "explanation": {
      "understanding_the_problem": "We need to find edges in a graph that, if removed, would increase the number of connected components. In graph theory, these edges are called **Bridges**.\n\nIn the example, nodes 0, 1, and 2 form a cycle (a strongly connected component). Node 3 is attached only to node 1. If we cut the edge `1-3`, node 3 becomes isolated. Thus, `1-3` is a critical connection.",
      "brute_force": "A naive approach is to iterate through every edge, temporarily remove it, and run DFS/BFS to check if the graph is still connected. If it's disconnected, that edge is critical.\n\nTime Complexity: O(E * (V + E)), which is too slow for large graphs.",
      "bottleneck": "Repeatedly traversing the graph is inefficient. We need a way to identify bridges in a single pass.",
      "optimized_approach": "We can use **Tarjan's Bridge-Finding Algorithm** (or a variation using DFS discovery and low-link values).\n\n1.  **Rank (Discovery Time):** The order in which a node is visited during DFS.\n2.  **Low-Link Value:** The lowest rank reachable from the current node in the DFS tree (possibly using a back-edge, but not the direct parent edge).\n\n**Logic:** An edge `u-v` is a bridge if and only if `low[v] > rank[u]`. This means there is no back-edge from `v` or any of its descendants to `u` or any of `u`'s ancestors. `v` is 'stuck' needing `u` to reach the rest of the graph.",
      "algorithm_steps": "1. Initialize `rank` and `low` arrays with -1. Time starts at 0.\n2. Start DFS from node 0 (or any node).\n3. In DFS(u, parent):\n    a. Set `rank[u] = low[u] = time++`.\n    b. Iterate neighbors `v`.\n    c. If `v` is parent, continue.\n    d. If `v` is visited, update `low[u] = min(low[u], rank[v])`.\n    e. If `v` is unvisited:\n        i. `DFS(v, u)`\n        ii. `low[u] = min(low[u], low[v])`\n        iii. If `low[v] > rank[u]`, add `[u, v]` to results."
    },
    "quizzes": []
  },
  "code": {
    "javascript": {
      "solution": "var criticalConnections = function(n, connections) {\n    const adj = Array.from({length: n}, () => []);\n    for (const [u, v] of connections) {\n        adj[u].push(v);\n        adj[v].push(u);\n    }\n    \n    const rank = new Array(n).fill(-1);\n    const low = new Array(n).fill(-1);\n    const result = [];\n    let time = 0;\n    \n    const dfs = (u, p) => {\n        rank[u] = low[u] = time++;\n        for (const v of adj[u]) {\n            if (v === p) continue;\n            if (rank[v] !== -1) {\n                low[u] = Math.min(low[u], rank[v]);\n            } else {\n                dfs(v, u);\n                low[u] = Math.min(low[u], low[v]);\n                if (low[v] > rank[u]) {\n                    result.push([u, v]);\n                }\n            }\n        }\n    };\n    \n    dfs(0, -1);\n    return result;\n};",
      "annotations": []
    }
  },
  "complexity": {
    "time": "O(V + E)",
    "space": "O(V + E)",
    "explanation_time": "We perform a single standard DFS traversal of the graph. We visit every node and every edge exactly once.",
    "explanation_space": "Adjacency list takes O(V+E). Recursion stack and arrays take O(V)."
  },
  "diagram": "graph TD\n    0((0)) --- 1((1))\n    1 --- 2((2))\n    2 --- 0\n    1 ---|Bridge| 3((3))\n    \n    classDef default fill:#fff,stroke:#333,stroke-width:2px;\n    classDef bridge fill:#fecaca,stroke:#ef4444,stroke-width:4px;\n    \n    linkStyle 3 stroke:#ef4444,stroke-width:4px;\n    class 3 bridge;"
}