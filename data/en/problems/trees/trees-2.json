{
  "id": "trees-2",
  "title": "Distance Queries (LCA with Binary Lifting)",
  "difficulty": "Medium",
  "related": [
    {
      "id": "trees-1",
      "title": "Segment Tree",
      "category": "trees"
    },
    {
      "id": "trees-3",
      "title": "Tree Diameter",
      "category": "trees"
    }
  ],
  "tags": [
    "lca",
    "binary-lifting",
    "trees"
  ],
  "content": {
    "problem_statement": "You are given a tree with `n` nodes labeled from `0` to `n - 1`, and an array of `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree.\n\nYou are also given an array `queries` where `queries[i] = [u, v]`. For each query, find the **distance** between node `u` and node `v`.\n\nThe **distance** between two nodes is the number of edges on the unique simple path between them.\n\n**Example 1:**\n```\nInput: n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], queries = [[3,5],[4,5]]\nOutput: [3, 3]\nExplanation: \nThe distance between 3 and 5 is 3 (3 -> 1 -> 0 -> 2 -> 5).\nThe distance between 4 and 5 is 3 (4 -> 1 -> 0 -> 2 -> 5).\n```",
    "explanation": {
      "understanding_the_problem": "A naive approach of running a separate BFS/DFS for each query to find the path length would be too slow if there are many queries. A more efficient method relies on finding the **Lowest Common Ancestor (LCA)** of the two nodes.\n\nThe path from node `u` to `v` can be seen as the path from `u` up to `lca(u,v)` and then down to `v`. This gives us a formula for the distance: `dist(u,v) = depth(u) + depth(v) - 2 * depth(lca(u,v))`. The problem now becomes: how to find the LCA efficiently?",
      "brute_force": "To find the LCA of `u` and `v`, we could first bring them to the same depth by moving the deeper node up one parent at a time. Then, we move both nodes up one parent at a time until they meet. This is simple but can take O(N) time per query in the worst case (for a tall, skinny tree).",
      "bottleneck": "The O(N) time per query is the bottleneck. We need a way to move nodes up the tree much faster than one step at a time. This is where Binary Lifting comes in.",
      "optimized_approach": "**Binary Lifting** is a technique that allows us to answer LCA queries in O(log N) time after an O(N log N) preprocessing step. The core idea is to precompute, for each node, its ancestor at various powers-of-2 distances (1st parent, 2nd, 4th, 8th, etc.).\n\nWe build a table `up[k][u]` that stores the `2^k`-th ancestor of node `u`. This table can be built with the recurrence: `up[k][u] = up[k-1][up[k-1][u]]` (the 2^k-th ancestor is the 2^(k-1)-th ancestor of the 2^(k-1)-th ancestor).\n\nWith this table, we can jump up the tree by large distances (any distance `d` can be represented as a sum of powers of 2), allowing us to find the LCA very quickly.",
      "algorithm_steps": "1.  **Preprocessing (O(N log N)):**\n    a.  Run a DFS from the root to compute `depth[u]` and the direct parent `up[0][u]` for every node.\n    b.  Fill the `up` table using the binary lifting recurrence described above.\n\n2.  **LCA Query (O(log N)):**\n    a.  **Equalize Depths:** Bring the deeper node up until it's at the same depth as the other node. This is done in O(log N) by jumping up by powers of 2.\n    b.  **Check for Ancestor:** If the nodes are now the same, one was an ancestor of the other, so we've found the LCA.\n    c.  **Simultaneous Lifting:** If not, lift both nodes up simultaneously by powers of 2, from largest to smallest (`k = logN...0`). We take a jump `up[k]` only if their ancestors are **not** the same. This ensures they land just below the LCA.\n    d.  The LCA is then the direct parent of either of the current nodes.\n\n3.  **Distance Query:** Once the LCA is found, apply the distance formula."
    },
    "quizzes": [
      {
        "question": "What does LCA stand for?",
        "options": [
          "Last Common Ancestor",
          "Lowest Common Ancestor",
          "Linear Chain Analysis",
          "Longest Connected Arc"
        ],
        "correct": 1
      },
      {
        "question": "How is distance calculated using LCA?",
        "options": [
          "depth(u) * depth(v)",
          "depth(u) + depth(v) - 2*depth(lca)",
          "depth(lca)",
          "max(depth(u), depth(v))"
        ],
        "correct": 1
      },
      {
        "question": "What does up[k][u] store?",
        "options": [
          "k-th child",
          "2^k-th ancestor of u",
          "k ancestors",
          "Distance to root"
        ],
        "correct": 1
      },
      {
        "question": "What's the key idea of binary lifting?",
        "options": [
          "Sort nodes",
          "Jump by powers of 2",
          "Hash ancestors",
          "Split tree"
        ],
        "correct": 1
      },
      {
        "question": "What's the preprocessing complexity?",
        "options": [
          "O(N)",
          "O(N log N)",
          "O(NÂ²)",
          "O(log N)"
        ],
        "correct": 1
      }
    ]
  },
  "code": {
    "javascript": {
      "solution": "class LCA {\n  constructor(n, edges, root = 0) {\n    this.log = Math.ceil(Math.log2(n)) + 1;\n    this.parent = Array.from({length: this.log}, () => new Array(n).fill(-1));\n    this.depth = new Array(n).fill(0);\n    this.adj = Array(n).fill().map(() => []);\n    for (let [u,v] of edges) {\n      this.adj[u].push(v); this.adj[v].push(u);\n    }\n    this.dfs(root, -1);\n    this.preprocess();\n  }\n  dfs(u, p) {\n    this.parent[0][u] = p;\n    for (let v of this.adj[u]) if (v !== p) {\n      this.depth[v] = this.depth[u] + 1;\n      this.dfs(v, u);\n    }\n  }\n  preprocess() {\n    for (let k=1; k<this.log; k++)\n      for (let v=0; v<this.parent[0].length; v++)\n        if (this.parent[k-1][v] !== -1)\n          this.parent[k][v] = this.parent[k-1][this.parent[k-1][v]];\n  }\n  getLCA(u, v) {\n    if (this.depth[u] < this.depth[v]) [u,v] = [v,u];\n    let diff = this.depth[u] - this.depth[v];\n    for (let k=0; k<this.log; k++)\n      if (diff & (1<<k)) u = this.parent[k][u];\n    if (u === v) return u;\n    for (let k=this.log-1; k>=0; k--)\n      if (this.parent[k][u] !== this.parent[k][v]) {\n        u = this.parent[k][u]; v = this.parent[k][v];\n      }\n    return this.parent[0][u];\n  }\n  getDistance(u, v) {\n    const lca = this.getLCA(u, v);\n    return this.depth[u] + this.depth[v] - 2 * this.depth[lca];\n  }\n}",
      "annotations": [
        {
          "lines": [
            2
          ],
          "text": "Calculate max height (log N) for binary lifting table."
        },
        {
          "lines": [
            3
          ],
          "text": "Up table: parent[k][u] is the 2^k-th ancestor of u."
        },
        {
          "lines": [
            10,
            15
          ],
          "text": "DFS: Compute depths and fill 0-th ancestors (direct parents)."
        },
        {
          "lines": [
            17,
            18
          ],
          "text": "Preprocess: Build table. 2^k-th ancestor is (2^(k-1))-th of (2^(k-1))-th."
        },
        {
          "lines": [
            21
          ],
          "text": "LCA Query: Ensure 'u' is deeper than 'v'."
        },
        {
          "lines": [
            23,
            24
          ],
          "text": "Lift 'u' to the same depth as 'v' using binary jumps."
        },
        {
          "lines": [
            27,
            28,
            29
          ],
          "text": "Lift both up simultaneously by largest powers of 2 as long as ancestors differ."
        },
        {
          "lines": [
            31
          ],
          "text": "After loop, they are just below LCA, so return parent."
        }
      ]
    }
  },
  "complexity": {
    "time": "O(N log N) preprocess, O(log N) per query",
    "space": "O(N log N)",
    "explanation_time": "The initial DFS to compute depths and parents is O(N). Building the binary lifting table `up` takes O(N log N). Each LCA query then takes O(log N) because it involves a few loops that iterate up to log N times.",
    "explanation_space": "The adjacency list, depth array, etc., take O(N) space. The dominant factor is the `up` table, which has dimensions of roughly (log N) x N, resulting in O(N log N) space complexity."
  },
  "diagram": "graph TD\n    0((0))\n    1((1))\n    2((2))\n    3((3))\n    4((4))\n    5((5))\n    \n    0 --- 1\n    0 --- 2\n    1 --- 3\n    1 --- 4\n    2 --- 5\n    \n    %% Binary Lifting Paths (Example for nodes 3 and 5)\n    3 -.->|2^0| 1\n    3 -.->|2^1| 0\n    5 -.->|2^0| 2\n    5 -.->|2^1| 0\n    \n    classDef default fill:#fff,stroke:#333,stroke-width:2px;"
}