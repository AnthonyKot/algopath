{
  "id": "dp-1",
  "title": "Edit Distance (Levenshtein)",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/edit-distance/",
  "related": [
    {
      "id": "dp-5",
      "title": "Regular Expression Matching",
      "category": "dp"
    },
    {
      "id": "graphs-1",
      "title": "Word Ladder",
      "category": "graphs"
    }
  ],
  "tags": [
    "dp",
    "strings",
    "edit-distance"
  ],
  "follow_up": {
    "scenario": "Spell checker for a search engine. Need millisecond response for 'Did you mean?'.",
    "trade_off": "O(N^2) DP is too slow for real-time query correction on millions of terms.",
    "strategy": "Use a Levenshtein Automaton or BK-Trees for retrieval. For exact distance between long strings, use Bit-parallelism.",
    "answering_guide": "The magic phrase is <strong>'fuzzy search'</strong>. If you mention <strong>'Lucene Automaton'</strong> or <strong>'Bit-parallelism'</strong>, you win instantly."
  },
  "content": {
    "problem_statement": "Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.\n\nYou have the following three operations permitted on a word:\n1. Insert a character\n2. Delete a character\n3. Replace a character\n\n**Example 1:**\n```\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n```\n\n**Example 2:**\n```\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n```",
    "explanation": {
      "understanding_the_problem": "We need to find the *minimum* number of edits (insert, delete, replace) to transform one string into another. The 'minimum' requirement is a strong hint that this is an optimization problem, and since it involves sequences (strings), it's a classic candidate for Dynamic Programming.\n\nThe core idea of DP is to solve a complex problem by breaking it down into simpler, overlapping subproblems. The edit distance between `word1` and `word2` depends on the edit distances of their prefixes.",
      "brute_force": "We can define a function `dp(i, j)` that gives the edit distance between the first `i` characters of `word1` and the first `j` characters of `word2`. Our goal is to find `dp(m, n)` where `m` and `n` are the lengths of the words.\n\nTo calculate `dp(i, j)`, we look at the last characters, `word1[i-1]` and `word2[j-1]`.\n\n- **If the characters match:** No operation is needed. The cost is just the result of the subproblem for the prefixes without these characters: `dp(i-1, j-1)`.\n- **If the characters don't match:** We must perform an operation. We choose the one with the minimum cost:\n    - **Replace:** `1 + dp(i-1, j-1)` (cost of replace + cost of smaller subproblem)\n    - **Delete:** `1 + dp(i-1, j)` (cost of delete + cost of matching `word1` prefix to `word2`)\n    - **Insert:** `1 + dp(i, j-1)` (cost of insert + cost of matching `word1` to `word2` prefix)",
      "bottleneck": "A purely recursive solution would be extremely slow because it would re-calculate the same subproblems (e.g., `dp(3, 4)`) many times. This is the 'overlapping subproblems' property that DP is designed to solve.",
      "optimized_approach": "We can use a 2D table (an array of arrays) to store the results of the subproblems, a technique called memoization or tabulation. Let `dp[i][j]` be the minimum edit distance between `word1.slice(0, i)` and `word2.slice(0, j)`.\n\nWe fill this table bottom-up, starting with the base cases (like the distance from an empty string to a prefix), and use the state transition logic described above to fill the entire table. The final answer is the value in the bottom-right cell, `dp[m][n]`.",
      "algorithm_steps": "1.  **Initialization:**\n    a.  Create a `dp` table of size `(m+1) x (n+1)`.\n    b.  `dp[0][0] = 0` (distance between two empty strings is 0).\n    c.  Fill the first row: `dp[0][j] = j`. This is the cost to create `word2`'s prefix from an empty string (j insertions).\n    d.  Fill the first column: `dp[i][0] = i`. This is the cost to reduce `word1`'s prefix to an empty string (i deletions).\n\n2.  **Main Loop:**\n    a.  Iterate with `i` from 1 to `m` and `j` from 1 to `n`.\n    b.  If `word1[i-1] == word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`.\n    c.  Otherwise, `dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])`.\n\n3.  **Result:** Return `dp[m][n]`.\n\n**Space Optimization:** Notice that to compute a cell `dp[i][j]`, we only need values from the previous row and the current row. This means we can optimize the space from O(mn) to O(n) by only storing one or two rows at a time. The provided solution uses a clever single-array approach for this."
    },
    "quizzes": [
      {
        "question": "What technique best fits a problem with overlapping subproblems?",
        "options": [
          "Greedy",
          "Divide & Conquer",
          "Dynamic Programming",
          "Backtracking"
        ],
        "correct": 2
      },
      {
        "question": "What is the main bottleneck of naive recursion here?",
        "options": [
          "Stack overflow",
          "Repeated subproblems",
          "Memory allocation",
          "String copying"
        ],
        "correct": 1
      },
      {
        "question": "How do we avoid recomputing the same subproblems?",
        "options": [
          "Sorting",
          "Hashing",
          "Memoization",
          "Parallelism"
        ],
        "correct": 2
      },
      {
        "question": "What does dp[i][j] represent in this solution?",
        "options": [
          "Max edits",
          "Min edits for prefixes",
          "Character count",
          "String length"
        ],
        "correct": 1
      },
      {
        "question": "What is the space complexity after optimization?",
        "options": [
          "O(m*n)",
          "O(m+n)",
          "O(min(m,n))",
          "O(1)"
        ],
        "correct": 2
      }
    ]
  },
  "code": {
    "javascript": {
      "solution": "function editDistance(s1, s2) {\n  let [m, n] = [s1.length, s2.length];\n  if (m < n) { [s1, s2] = [s2, s1]; [m, n] = [n, m]; }\n  const dp = Array(n+1).fill(0);\n  for (let j = 0; j <= n; j++) dp[j] = j;\n  for (let i = 1; i <= m; i++) {\n    let prev = i;\n    for (let j = 1; j <= n; j++) {\n      let temp = dp[j];\n      dp[j] = s1[i-1] === s2[j-1] ? dp[j-1] : 1 + Math.min(dp[j-1], prev, dp[j]);\n      prev = temp;\n    }\n  }\n  return dp[n];\n}",
      "annotations": [
        {
          "lines": [
            3
          ],
          "text": "Swap so s2 is shorter - dp array is smaller for space optimization"
        },
        {
          "lines": [
            4,
            5
          ],
          "text": "Base case: dp[j] = j means j insertions to transform empty string to s2[0..j]"
        },
        {
          "lines": [
            7
          ],
          "text": "'prev' stores dp[i-1][j-1] from 2D table - the diagonal value we need"
        },
        {
          "lines": [
            9
          ],
          "text": "'temp' saves dp[j] before overwrite, becomes 'prev' for next column"
        },
        {
          "lines": [
            10
          ],
          "text": "Core recurrence: if chars match use diagonal, else 1 + min(replace, insert, delete)"
        },
        {
          "lines": [
            14
          ],
          "text": "Final answer: min edits to transform s1[0..m] to s2[0..n]"
        }
      ]
    }
  },
  "complexity": {
    "time": "O(m*n)",
    "space": "O(min(m,n))",
    "explanation_time": "We need to compute the value for each of the m*n cells in our conceptual DP table. Each computation takes constant time. Therefore, the time complexity is O(m*n), where m and n are the lengths of the two strings.",
    "explanation_space": "The standard 2D DP table approach requires O(m*n) space. However, the provided solution is space-optimized. It only stores one row of the DP table at a time, reducing the space complexity to O(n), where n is the length of the shorter string (due to the initial swap)."
  }
}