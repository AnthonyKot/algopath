{
  "id": "optimization-1",
  "title": "Sliding Window Maximum",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/sliding-window-maximum/",
  "related": [
    {
      "id": "optimization-2",
      "title": "Largest Rectangle in Histogram",
      "category": "optimization"
    },
    {
      "id": "design-4",
      "title": "Design Hit Counter",
      "category": "design"
    }
  ],
  "tags": [
    "sliding-window",
    "deque",
    "monotonic"
  ],
  "follow_up": {
    "scenario": "The input stream is infinite and high-speed. K is 1 Million.",
    "trade_off": "Storing 1M indices in a standard List causes GC pressure and cache misses.",
    "strategy": "Use a fixed-size circular buffer for the Deque. Optimize memory layout (Int32Array) to prevent pointer chasing.",
    "answering_guide": "Move beyond the algorithm to <strong>'Memory Locality'</strong> and <strong>'GC Pressure'</strong>. Mentioning <strong>'Typed Arrays'</strong> or <strong>'Ring Buffers'</strong> demonstrates systems knowledge."
  },
  "content": {
    "problem_statement": "You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.\n\nReturn *the max sliding window*.\n\n**Example 1:**\n```\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]\nExplanation: \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```",
    "explanation": {
      "understanding_the_problem": "We need to find the maximum element within a fixed-size window that slides across an array. A new maximum is produced for each position the window slides to.",
      "brute_force": "For each of the `N-k+1` possible windows, we could iterate through the `k` elements within it to find the maximum. This would have a time complexity of O(N*k), which is too slow if N and k are large.",
      "bottleneck": "Re-scanning the `k` elements for every single window is highly redundant. The maximum of the current window is very likely to be the maximum of the next window, but we aren't reusing that information.",
      "optimized_approach": "An optimal O(N) solution uses a **monotonic deque** (a double-ended queue). This deque will store *indices* of elements from the array, and it will be kept in strictly decreasing order based on the values at those indices. \n\nThe front of the deque will always hold the index of the maximum element in the current window. As we slide the window, we add new elements to the back of the deque, but before adding, we remove any elements from the back that are smaller than the new element, thus maintaining the monotonic property.",
      "algorithm_steps": "1.  Initialize an empty deque and a results array.\n2.  Iterate through `nums` from left to right with index `i`:\n    a.  **Clean Front:** Remove any indices from the *front* of the deque that are no longer in the current window (i.e., index `<= i - k`).\n    b.  **Clean Back:** While the deque is not empty and the value at the *back* of the deque is less than `nums[i]`, pop from the back. This is the key step to maintain the decreasing monotonic property.\n    c.  **Add Index:** Push the current index `i` to the back.\n    d.  **Store Result:** If our window is full (`i >= k - 1`), the maximum for this window is the value at the index at the *front* of the deque. Add this to the results."
    },
    "quizzes": [
      {
        "question": "What property does the deque maintain?",
        "options": [
          "Increasing values",
          "Decreasing values",
          "Sorted indices",
          "Random order"
        ],
        "correct": 1
      },
      {
        "question": "Why do we store indices instead of values?",
        "options": [
          "To save memory",
          "To check window bounds (expiry)",
          "Faster comparison",
          "Required by array"
        ],
        "correct": 1
      },
      {
        "question": "When do we pop from the back?",
        "options": [
          "When window slides",
          "When new element is larger than back",
          "When deque is full",
          "Never"
        ],
        "correct": 1
      },
      {
        "question": "When do we pop from the front?",
        "options": [
          "When element is too small",
          "When element is out of window range",
          "When finding max",
          "Randomly"
        ],
        "correct": 1
      },
      {
        "question": "What is the time complexity?",
        "options": [
          "O(N*k)",
          "O(N log k)",
          "O(N)",
          "O(NÂ²)",
          "O(N)"
        ],
        "correct": 0
      }
    ]
  },
  "code": {
    "javascript": {
      "solution": "function maxSlidingWindow(nums, k) {\n  const deque = [];\n  const result = [];\n  \n  for (let i = 0; i < nums.length; i++) {\n    while (deque.length && deque[0] <= i - k) {\n      deque.shift();\n    }\n    \n    while (deque.length && nums[deque[deque.length - 1]] <= nums[i]) {\n      deque.pop();\n    }\n    \n    deque.push(i);\n    \n    if (i >= k - 1) {\n      result.push(nums[deque[0]]);\n    }\n  }\n  \n  return result;\n}",
      "annotations": [
        {
          "lines": [
            2
          ],
          "text": "Deque stores indices, not values. It maintains a decreasing order of values."
        },
        {
          "lines": [
            6
          ],
          "text": "Clean Front: Remove indices that have fallen out of the current window (i - k)."
        },
        {
          "lines": [
            10
          ],
          "text": "Clean Back: Remove indices whose values are smaller than current num. They can't be max anymore."
        },
        {
          "lines": [
            16
          ],
          "text": "Result: The front of the deque always holds the index of the max value for the current window."
        }
      ]
    }
  },
  "complexity": {
    "time": "O(N)",
    "space": "O(k)",
    "explanation_time": "Each index from the input array is pushed onto and popped from the deque at most once. This gives an amortized O(1) cost for each of the N elements, leading to a total linear time complexity.",
    "explanation_space": "The deque will store at most `k` indices, so the space complexity is O(k)."
  }
}