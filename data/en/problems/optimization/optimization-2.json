{
  "id": "optimization-2",
  "title": "Largest Rectangle in Histogram",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/largest-rectangle-in-histogram/",
  "related": [
    {
      "id": "optimization-3",
      "title": "Maximal Rectangle",
      "category": "optimization"
    },
    {
      "id": "optimization-5",
      "title": "Trapping Rain Water",
      "category": "optimization"
    }
  ],
  "tags": [
    "stack",
    "monotonic",
    "optimization"
  ],
  "follow_up": {
    "scenario": "The histogram is distributed across 1000 machines (MapReduce).",
    "trade_off": "Cannot just sum the local results. The largest rectangle might span across machine boundaries.",
    "strategy": "Each machine computes local max area AND a 'skyline' profile (left/right increasing subsequences). The reducer merges these 1000 compressed profiles.",
    "answering_guide": "This is a classic <strong>'Divide and Conquer'</strong> at scale. Explain that the result is NOT just the max of local results; <strong>boundary merging</strong> is the key."
  },
  "content": {
    "problem_statement": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return *the area of the largest rectangle in the histogram*.\n\n**Example 1:**\n```\nInput: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The largest rectangle has an area = 10 units.\n```",
    "explanation": {
      "understanding_the_problem": "We need to find the largest rectangular area that can be inscribed within the given histogram bars.",
      "brute_force": "For each bar `i`, we can try to form the largest rectangle that has this bar as its height. To do this, we would expand left and right from `i` to find the boundaries (the first bars shorter than `heights[i]`). This would take O(N) for each bar, leading to an overall O(N²) time complexity.",
      "bottleneck": "The O(N²) approach is slow because for each bar, we are re-scanning its left and right sides to find the boundaries.",
      "optimized_approach": "An O(N) solution uses a **monotonic stack**. The stack will store indices of bars in increasing order of their height. For any bar, its contribution to the max area is `height * width`. The width is determined by the first shorter bar to its left and the first shorter bar to its right. The monotonic stack helps us find these boundaries efficiently for all bars in a single pass.\n\nWhen we encounter a bar that is shorter than the one at the top of the stack, we know we've found the 'right boundary' for the bar on the stack. Its 'left boundary' is the next element in the stack.",
      "algorithm_steps": "1.  Initialize an empty stack (to store indices) and `max_area = 0`.\n2.  Iterate through the `heights` array (it's helpful to append a 0 to the end to ensure all bars are processed).\n3.  For each bar `i`, while the stack is not empty and `heights[i]` is less than the height of the bar at the stack's top:\n    a.  Pop the index `h_idx` from the stack. This is the bar whose max area we are calculating.\n    b.  The `height` is `heights[h_idx]`.\n    c.  The right boundary is `i`. The left boundary is the next element in the stack.\n    d.  Calculate `width = i - (stack.length > 0 ? stack[stack.length-1] : -1) - 1`.\n    e.  Update `max_area = max(max_area, height * width)`.\n4.  Push the current index `i` onto the stack."
    },
    "quizzes": [
      {
        "question": "What does the stack store?",
        "options": [
          "Heights",
          "Indices",
          "Areas",
          "Reversed Heights"
        ],
        "correct": 1
      },
      {
        "question": "What property of heights does the stack maintain?",
        "options": [
          "Decreasing",
          "Increasing",
          "Random",
          "Constant"
        ],
        "correct": 1
      },
      {
        "question": "What triggers a calculation?",
        "options": [
          "Pushing a taller bar",
          "Pushing a shorter bar",
          "Stack empty",
          "Every step"
        ],
        "correct": 1
      },
      {
        "question": "How is width calculated?",
        "options": [
          "right - left",
          "right - left - 1",
          "right + left",
          "constant"
        ],
        "correct": 1
      },
      {
        "question": "Why append 0 at the end?",
        "options": [
          "To avoid overflow",
          "To flush the stack",
          "To start index at 1",
          "Padding"
        ],
        "correct": 1
      }
    ]
  },
  "code": {
    "javascript": {
      "solution": "function largestRectangleArea(heights) {\n  const stack = [];\n  let maxArea = 0;\n  heights.push(0);\n  \n  for (let i = 0; i < heights.length; i++) {\n    while (stack.length && heights[i] < heights[stack[stack.length - 1]]) {\n      const h = heights[stack.pop()];\n      const w = stack.length ? i - stack[stack.length - 1] - 1 : i;\n      maxArea = Math.max(maxArea, h * w);\n    }\n    stack.push(i);\n  }\n  \n  return maxArea;\n}",
      "annotations": [
        {
          "lines": [
            4
          ],
          "text": "Sentinel: Add 0 height at the end to force processing remaining bars in stack."
        },
        {
          "lines": [
            7
          ],
          "text": "Condition: Current bar is shorter than stack top? Stack top is the 'height' of the rect."
        },
        {
          "lines": [
            9
          ],
          "text": "Width Calc: i is right boundary (exclusive), new stack top is left boundary (exclusive)."
        },
        {
          "lines": [
            10
          ],
          "text": "Area: height * width. Update maxArea if this rectangle is bigger."
        }
      ]
    }
  },
  "complexity": {
    "time": "O(N)",
    "space": "O(N)",
    "explanation_time": "Each bar's index is pushed onto and popped from the stack exactly once, leading to a linear time complexity.",
    "explanation_space": "In the worst case (a histogram with increasing heights), the stack could hold all N indices."
  }
}