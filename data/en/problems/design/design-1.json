{
  "id": "design-1",
  "title": "LRU Cache",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/lru-cache/",
  "related": [
    {
      "id": "design-4",
      "title": "Design Hit Counter",
      "category": "design"
    },
    {
      "id": "design-5",
      "title": "Design Add and Search Words",
      "category": "design"
    }
  ],
  "tags": [
    "design",
    "hash-table",
    "doubly-linked-list"
  ],
  "follow_up": {
    "scenario": "Your cache is used by 1000 concurrent threads. The global lock is a bottleneck.",
    "trade_off": "Sharding the cache (segments) reduces contention but approximates LRU accuracy globally.",
    "strategy": "Use a `ConcurrentHashMap` with segmented locks (like Java 7) or a Clock algorithm (Second Chance) to avoid full locking.",
    "answering_guide": "Acknowledge the lock contention issue immediately. Proposing <strong>'segmentation' (sharding)</strong> is the standard L5 move here. Mentioning <strong>'Clock Algorithm'</strong> shows depth."
  },
  "content": {
    "problem_statement": "Design a data structure that follows the constraints of a **[Least Recently Used (LRU) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU)**.\n\nImplement the `LRUCache` class:\n*   `LRUCache(int capacity)` Initialize the LRU cache with positive size `capacity`.\n*   `int get(int key)` Return the value of the `key` if the key exists, otherwise return `-1`.\n*   `void put(int key, int value)` Update the value of the `key` if the `key` exists. Otherwise, add the `key-value` pair to the cache. If the number of keys exceeds the `capacity` from this operation, **evict** the least recently used key.\n\nThe functions `get` and `put` must each run in `O(1)` average time complexity.\n\n**Example 1:**\n```\nInput\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n```",
    "explanation": {
      "understanding_the_problem": "We need a data structure that can store key-value pairs up to a certain `capacity`. When we access or add an item, it becomes the 'most recently used'. When we need to make space, we evict the 'least recently used' item. All operations must be very fast (O(1)).",
      "brute_force": "A simple hash map gives O(1) `get` and `put`, but it doesn't track usage order. A linked list can track order (by moving nodes to the front), but `get` would take O(N) to find the item. We need to combine the strengths of both.",
      "bottleneck": "No single standard data structure provides both O(1) key-based lookup and O(1) reordering. The challenge is to link these two capabilities.",
      "optimized_approach": "The optimal solution combines a **Hash Map** and a **Doubly Linked List**.\n\n- The **Hash Map** stores keys and maps them to nodes in the linked list (`key -> Node`). This gives us the O(1) lookup.\n- The **Doubly Linked List** stores the actual key-value pairs in its nodes and maintains the usage order. The head of the list is the most recently used item, and the tail is the least recently used. A doubly linked list is crucial because it allows O(1) removal of any node *if we have a direct pointer to it* (which the hash map provides).",
      "algorithm_steps": "1.  **`get(key)`:**\n    a.  Look up the key in the hash map. If it doesn't exist, return -1.\n    b.  If it exists, we get a direct pointer to the linked list node. Move this node to the head of the list to mark it as most recently used.\n    c.  Return the node's value.\n\n2.  **`put(key, value)`:**\n    a.  Check if the key exists in the map.\n    b.  If yes, update the node's value and move it to the head of the list.\n    c.  If no, create a new node. If the cache is at full capacity, evict the tail of the list and remove its key from the hash map. Then, add the new node to the head of the list and add its `(key, node)` pair to the map."
    },
    "quizzes": [
      {
        "question": "What combination of data structures is optimal?",
        "options": [
          "Array + List",
          "HashMap + Doubly Linked List",
          "Stack + Queue",
          "Two Heaps"
        ],
        "correct": 1
      },
      {
        "question": "Why is a Doubly Linked List needed?",
        "options": [
          "To sort keys",
          "O(1) removal of any node given a pointer",
          "Less memory",
          "To handle collisions"
        ],
        "correct": 1
      },
      {
        "question": "Which item is evicted when full?",
        "options": [
          "Head (Most Recently Used)",
          "Tail (Least Recently Used)",
          "Random",
          "Middle"
        ],
        "correct": 1
      },
      {
        "question": "What is the time complexity of put/get?",
        "options": [
          "O(1)",
          "O(log N)",
          "O(N)",
          "O(N log N)"
        ],
        "correct": 0
      },
      {
        "question": "Why use dummy head/tail nodes?",
        "options": [
          "Required by language",
          "Avoid null checks/edge cases",
          "Store metadata",
          "Increase capacity"
        ],
        "correct": 1
      }
    ]
  },
  "code": {
    "javascript": {
      "solution": "class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n    this.head = { key: 0, val: 0 };\n    this.tail = { key: 0, val: 0 };\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n  \n  addNode(node) {\n    node.prev = this.head;\n    node.next = this.head.next;\n    this.head.next.prev = node;\n    this.head.next = node;\n  }\n  \n  removeNode(node) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n  }\n  \n  moveToHead(node) {\n    this.removeNode(node);\n    this.addNode(node);\n  }\n  \n  popTail() {\n    const last = this.tail.prev;\n    this.removeNode(last);\n    return last;\n  }\n  \n  get(key) {\n    const node = this.cache.get(key);\n    if (node) {\n      this.moveToHead(node);\n      return node.val;\n    }\n    return -1;\n  }\n  \n  put(key, value) {\n    const node = this.cache.get(key);\n    if (node) {\n      node.val = value;\n      this.moveToHead(node);\n    } else {\n      const newNode = { key, val: value };\n      if (this.cache.size >= this.capacity) {\n        const tail = this.popTail();\n        this.cache.delete(tail.key);\n      }\n      this.cache.set(key, newNode);\n      this.addNode(newNode);\n    }\n  }\n}",
      "annotations": [
        {
          "lines": [
            6,
            7
          ],
          "text": "Sentinel Nodes: Head and Tail dummies simplify add/remove logic (no null checks)."
        },
        {
          "lines": [
            11,
            12
          ],
          "text": "Add Node: Always add to front (right after head). Most recently used."
        },
        {
          "lines": [
            23
          ],
          "text": "Pop Tail: Remove from back (right before tail). Least recently used."
        },
        {
          "lines": [
            30
          ],
          "text": "Get: If found, move to head to refresh 'recently used' status."
        }
      ]
    }
  },
  "complexity": {
    "time": "O(1)",
    "space": "O(capacity)",
    "explanation_time": "All `get` and `put` operations involve a hash map lookup/insertion (O(1)) and a few pointer re-assignments in the doubly linked list (O(1)).",
    "explanation_space": "The hash map and the linked list both store up to the `capacity` number of items."
  }
}