<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimization Techniques - L4/L5 FAANG Algorithms Guide</title>
    <meta name="description" content="Optimization techniques: two pointers, binary search, divide and conquer, meet in the middle for Codeforces.">
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body>
    <nav id="main-nav">
        <div class="container nav-container">
            <div class="nav-brand">
                <h2><i class="fas fa-code"></i>FAANG Algorithms</h2>
            </div>
            <div class="nav-links">
                <a href="index.html#home"><i class="fas fa-home"></i>Home</a>
                <a href="index.html#algorithms"><i class="fas fa-cubes"></i>Problems</a>
                <a href="dp.html"><i class="fas fa-route"></i>DP</a>
                <a href="graphs.html"><i class="fas fa-project-diagram"></i>Graphs</a>
                <a href="trees.html"><i class="fas fa-sitemap"></i>Trees</a>
                <a href="strings.html"><i class="fas fa-align-left"></i>Strings</a>
                <a href="math.html"><i class="fas fa-calculator"></i>Math</a>
                <a href="geometry.html"><i class="fas fa-shapes"></i>Geometry</a>
                <a href="design.html"><i class="fas fa-cogs"></i>Design</a>
                <a href="#optimization"><i class="fas fa-tachometer-alt"></i>Optimization</a>
                <a href="index.html#concepts"><i class="fas fa-lightbulb"></i>Concepts</a>
                <a href="index.html#resources"><i class="fas fa-book"></i>Resources</a>
            </div>
        </div>
    </nav>

    <main>
        <section id="optimization" class="hero category-hero">
            <div class="container">
                <h1>Optimization Techniques</h1>
                <p class="hero-text">Two pointers, binary search on answer, divide and conquer, and advanced optimizations for Codeforces. Rating: 1600-2400+.</p>
                <div class="category-stats">
                    <div class="stat-item"><span class="stat-number">5</span><span class="stat-label">Problems</span></div>
                    <div class="stat-item"><span class="stat-number">O(N log N)</span><span class="stat-label">Avg Time</span></div>
                    <div class="stat-item"><span class="stat-number">1600-2400</span><span class="stat-label">CF Rating</span></div>
                </div>
            </div>
        </section>

        <section class="problems-section">
            <div class="container">
                <h2>Key Optimization Problems</h2>
                <div class="problems-grid">

                    <!-- Problem 1: Two Pointers -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Two Pointers</h3>
                            <div class="card-difficulty difficulty-hard">1600</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">two-pointers, sorted-arrays, greedy</span>
                            <span class="cf-contest">LeetCode Easy/Medium / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Given sorted array, find pair with target sum or maximize/minimize constraint using two pointers.</p>
                        <p><strong>Constraints:</strong> Array length ≤ 10^5, sorted input.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>nums = [2,7,11,15], target = 9</code><br>
                            Output: <code>Indices: 0, 1 (nums[0]+nums[1]=2+7=9)</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Left pointer = start, right pointer = end. Based on sum vs target, move pointers inward. Works for sorted arrays.</p>
                        <p><strong>Time:</strong> O(N) | <strong>Space:</strong> O(1)</p>
                        <div class="code-snippet">
<pre><code>function twoSum(nums, target) {
  const n = nums.length;
  let left = 0, right = n - 1;

  while (left < right) {
    const sum = nums[left] + nums[right];

    if (sum === target) {
      return [left, right];
    } else if (sum < target) {
      left++; // Need larger sum
    } else {
      right--; // Need smaller sum
    }
  }
  return [-1, -1]; // Not found
}

// Example: Container With Most Water
function maxArea(heights) {
  let left = 0, right = heights.length - 1;
  let maxArea = 0;

  while (left < right) {
    const width = right - left;
    const h = Math.min(heights[left], heights[right]);
    maxArea = Math.max(maxArea, width * h);

    if (heights[left] < heights[right]) {
      left++;
    } else {
      right--;
    }
  }
  return maxArea;
}
// O(N) with two pointers moving from both ends</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Two pointers exploit sorted order, reducing O(N²) to O(N). Works for sorted arrays.
                        </div>
                    </div>

                    <!-- Problem 2: Binary Search on Answer -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Binary Search on Answer</h3>
                            <div class="card-difficulty difficulty-hard">1800</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">binary-search, predicate, optimization</span>
                            <span class="cf-contest">Codeforces EDU Binary Search / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Find minimum/maximum value satisfying monotonic predicate. Binary search on answer, not array.</p>
                        <p><strong>Constraints:</strong> Range up to 10^18, predicate O(N) to check.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>Search minimum k where predicate(k) is true</code><br>
                            Output: <code>k = answer (first k where predicate(k)=true)</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Define predicate P(k): true if k works/is enough. Binary search range [low,high]. Find boundary where P changes false→true.</p>
                        <p><strong>Time:</strong> O(log range × predicate(N)) | <strong>Space:</strong> O(1)</p>
                        <div class="code-snippet">
<pre><code>function binarySearchAnswer(low, high, predicate) {
  // Find smallest k where predicate(k) is true
  while (low < high) {
    const mid = Math.floor((low + high) / 2);

    if (predicate(mid)) {
      high = mid; // Try smaller
    } else {
      low = mid + 1; // Need larger
    }
  }
  return low; // First true (or high if none)
}

// Example: Aggressive Cows
function aggressiveCows(stalls, cows) {
  stalls.sort((a, b) => a - b);

  // Predicate: can we place cows with distance >= k?
  const canPlace = (minDist) => {
    let last = stalls[0];
    let placed = 1;

    for (let i = 1; i < stalls.length; i++) {
      if (stalls[i] - last >= minDist) {
        placed++;
        last = stalls[i];
        if (placed >= cows) return true;
      }
    }
    return false;
  };

  // Binary search on minimum distance
  return binarySearchAnswer(1, stalls[stalls.length - 1] - stalls[0], canPlace);
}

// O(log(range) × N) instead of checking all distances</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Monotonic predicate: if P(k) true, then P(k+1) true. Enables binary search on function values.
                        </div>
                    </div>

                    <!-- Problem 3: Sliding Window Maximum -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Sliding Window Maximum</h3>
                            <div class="card-difficulty difficulty-hard">1900</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">sliding-window, deque, monotone-queue</span>
                            <span class="cf-contest">LeetCode Hard / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Given array, return maximum of each sliding window of size k. Do it in O(N).</p>
                        <p><strong>Constraints:</strong> Array length ≤ 10^5, window size ≤ N.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>nums = [1,3,-1,-3,5,3,6,7], k = 3</code><br>
                            Output: <code>[3,3,5,5,6,7]</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Use deque (monotonic queue). Maintain decreasing order: remove smaller back elements, pop front if outside window.</p>
                        <p><strong>Time:</strong> O(N) | <strong>Space:</strong> O(k)</p>
                        <div class="code-snippet">
<pre><code>function maxSlidingWindow(nums, k) {
  const result = [];
  const deque = []; // Stores indices, maintains decreasing nums

  for (let i = 0; i < nums.length; i++) {
    // Remove indices outside window
    while (deque.length && deque[0] <= i - k) {
      deque.shift();
    }

    // Remove smaller elements from back
    while (deque.length && nums[deque[deque.length - 1]] < nums[i]) {
      deque.pop();
    }

    deque.push(i);

    // Add max for current window (once window is full)
    if (i >= k - 1) {
      result.push(nums[deque[0]]);
    }
  }
  return result;
}

// Alternative: For minimum, reverse comparison (maintain increasing queue)
// Deque property: front = max of current window
// O(N) because each element pushed/poped at most once</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Monotonic deque maintains decreasing order. Front = window max, enables O(1) max query.
                        </div>
                    </div>

                    <!-- Problem 4: Meet in the Middle -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Meet in the Middle</h3>
                            <div class="card-difficulty difficulty-hard">2000</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">meet-in-middle, divide-and-conquer, subset-sum</span>
                            <span class="cf-contest">Codeforces EDU Divide & Conquer / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Split array in half, enumerate all subsets of each half (2^(N/2) each), combine to find best solution.</p>
                        <p><strong>Constraints:</strong> N ≤ 40 (2^(N/2) manageable), values up to 10^9.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>arr = [1,2,3,4,5], target = 10</code><br>
                            Output: <code>Exists: true (2+3+5=10)</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Split array into left (first N/2) and right (remaining). Enumerate all subsets of left: sums[mask] = sum. Enumerate right: check if target-leftSum exists.</p>
                        <p><strong>Time:</strong> O(2^(N/2) × N/2) | <strong>Space:</strong> O(2^(N/2))</p>
                        <div class="code-snippet">
<pre><code>function meetInMiddle(arr, target) {
  const n = arr.length;
  const half = Math.floor(n / 2);

  // Enumerate first half
  const left = arr.slice(0, half);
  const leftSums = [];
  for (let mask = 0; mask < (1 << half); mask++) {
    let sum = 0;
    for (let i = 0; i < half; i++) {
      if (mask & (1 << i)) {
        sum += left[i];
      }
    }
    leftSums.push(sum);
  }

  // Enumerate second half
  const right = arr.slice(half);
  for (let mask = 0; mask < (1 << (n - half)); mask++) {
    let sum = 0;
    for (let i = 0; i < n - half; i++) {
      if (mask & (1 << i)) {
        sum += right[i];
      }
    }

    // Check if target - sum exists in left
    if (leftSums.includes(target - sum)) {
      return true;
    }
  }
  return false;
}

// Time: O(2^(N/2) × N/2) instead of O(2^N)
// Works for N <= 40, exponential but manageable</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Splits 2^N into two 2^(N/2) enumerations. Optimize using bitmasks and hash maps for subset sums.
                        </div>
                    </div>

                    <!-- Problem 5: Divide and Conquer Optimization -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Divide and Conquer Optimization</h3>
                            <div class="card-difficulty difficulty-hard">2400</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">dp-optimization, divide-and-conquer, monotone</span>
                            <span class="cf-contest">Codeforces EDU DP Optimizations / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Optimize DP using divide and conquer: Knuth optimization or monotone opt. Reduces O(N³) to O(N²) DP.</p>
                        <p><strong>Constraints:</strong> DP state dimension N up to 5000.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>DP[l][r] = min over k: cost(l,k) + cost(k,r) + DP[l][k-1] × DP[k+1][r]</code><br>
                            Output: <code>O(N²) solution using D&C optimization</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Knuth: optimal split point moves monotonically as we expand interval. Compute in increasing order of interval length.</p>
                        <p><strong>Time:</strong> O(N²) instead of O(N³) | <strong>Space:</strong> O(N²)</p>
                        <div class="code-snippet">
<pre><code>function knuthOptimization(cost, n) {
  // cost[i][j] = cost of splitting [i,j] at position k
  const dp = Array(n + 2).fill().map(() => Array(n + 2).fill(Infinity));
  const opt = Array(n + 2).fill().map(() => Array(n + 2).fill(0));

  // Base case
  for (let i = 1; i <= n; i++) {
    dp[i][i] = 0;
  }

  // Iterate by increasing interval length
  for (let len = 2; len <= n; len++) {
    for (let i = 1; i + len - 1 <= n; i++) {
      const j = i + len - 1;

      // Knuth optimization: search opt[i][j-1] to opt[i+1][j]
      const minK = Math.max(i + 1, opt[i][j-1]);
      const maxK = Math.min(j - 1, opt[i+1][j]);

      dp[i][j] = Infinity;
      for (let k = minK; k <= maxK; k++) {
        const val = dp[i][k] + dp[k+1][j] + cost[i][j];
        if (val < dp[i][j]) {
          dp[i][j] = val;
          opt[i][j] = k; // Optimal split point
        }
      }
    }
  }
  return dp[1][n];
}

// Knuth requires quadrangle inequality:
// cost[a][c] + cost[b][d] <= cost[a][d] + cost[b][c] for a <= b < c <= d
// Reduces O(N³) to O(N²) DP</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Divide and conquer DP optimization exploits monotonicity of optimal split points. Knuth and Aliens are common approaches.
                        </div>
                    </div>

                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 L4/L5 FAANG Algorithms Guide | Codeforces problems for educational use</p>
        </div>
    </footer>

    <script src="script.js"></script>
</body>
</html>