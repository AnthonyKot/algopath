<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Design - L4/L5 FAANG Algorithms Guide</title>
    <meta name="description" content="System Design: rate limiting, caching, load balancing, distributed systems for L4/L5 interviews.">
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body>
    <nav id="main-nav">
        <div class="container nav-container">
            <div class="nav-brand">
                <h2><i class="fas fa-code"></i>FAANG Algorithms</h2>
            </div>
            <div class="nav-links">
                <a href="index.html#home"><i class="fas fa-home"></i>Home</a>
                <a href="index.html#algorithms"><i class="fas fa-cubes"></i>Problems</a>
                <a href="dp.html"><i class="fas fa-route"></i>DP</a>
                <a href="graphs.html"><i class="fas fa-project-diagram"></i>Graphs</a>
                <a href="trees.html"><i class="fas fa-sitemap"></i>Trees</a>
                <a href="strings.html"><i class="fas fa-align-left"></i>Strings</a>
                <a href="math.html"><i class="fas fa-calculator"></i>Math</a>
                <a href="geometry.html"><i class="fas fa-shapes"></i>Geometry</a>
                <a href="#design"><i class="fas fa-cogs"></i>Design</a>
                <a href="optimization.html"><i class="fas fa-tachometer-alt"></i>Optimization</a>
                <a href="index.html#concepts"><i class="fas fa-lightbulb"></i>Concepts</a>
                <a href="index.html#resources"><i class="fas fa-book"></i>Resources</a>
            </div>
        </div>
    </nav>

    <main>
        <section id="design" class="hero category-hero">
            <div class="container">
                <h1>System Design Patterns</h1>
                <p class="hero-text">Rate limiting, caching, load balancing, and distributed systems design for L4/L5 interviews. Complexity: O(1) operations, scalable architectures.</p>
                <div class="category-stats">
                    <div class="stat-item"><span class="stat-number">5</span><span class="stat-label">Problems</span></div>
                    <div class="stat-item"><span class="stat-number">O(1)</span><span class="stat-label">Avg Time</span></div>
                    <div class="stat-item"><span class="stat-number">System Design</span><span class="stat-label">Focus</span></div>
                </div>
            </div>
        </section>

        <section class="problems-section">
            <div class="container">
                <h2>Key System Design Problems</h2>
                <div class="problems-grid">

                    <!-- Problem 1: Rate Limiter -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Rate Limiter (Fixed Window)</h3>
                            <div class="card-difficulty difficulty-hard">1700</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">rate-limiting, sliding-window, api-design</span>
                            <span class="cf-contest">System Design / LeetCode Medium</span>
                        </div>
                        <p><strong>Problem:</strong> Design rate limiter that allows N requests per second per user/IP. Handle bursts and ensure fairness.</p>
                        <p><strong>Constraints:</strong> Up to 10^6 requests/sec, 1000+ concurrent users.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            User limit: 5 requests/sec<br>
                            Times: <code>t1: 1,2,3,4,5</code> (burst)<br>
                            <code>t2: 5,6</code> (rate-limited to 6)<br>
                        </div>
                        <p><strong>Walkthrough:</strong> Fixed window: track requests in last T seconds. Sliding window: circular buffer with timestamps. Token bucket: refill tokens periodically.</p>
                        <p><strong>Time:</strong> O(1) per request | <strong>Space:</strong> O(N) or O(windowSize)</p>
                        <div class="code-snippet">
<pre><code>class FixedWindowRateLimiter {
  constructor(windowMs, maxRequests) {
    this.windowMs = windowMs;
    this.maxRequests = maxRequests;
    this.requests = [];
  }

  allow(user) {
    const now = Date.now();
    // Remove old requests outside window
    this.requests = this.requests.filter(t => now - t < this.windowMs);

    // Count user requests in window
    const userReqs = this.requests.filter(r => r.user === user).length;

    if (userReqs >= this.maxRequests) {
      return false; // Rate limited
    }

    this.requests.push({user, time: now});
    return true;
  }
}

class TokenBucketRateLimiter {
  constructor(capacity, refillRate) { // tokens per second
    this.capacity = capacity;
    this.tokens = capacity;
    this.refillRate = refillRate;
    this.lastRefill = Date.now();
  }

  allow() {
    const now = Date.now();
    const elapsed = (now - this.lastRefill) / 1000; // seconds
    this.tokens = Math.min(this.capacity, this.tokens + elapsed * this.refillRate);
    this.lastRefill = now;

    if (this.tokens >= 1) {
      this.tokens -= 1;
      return true;
    }
    return false;
  }
}
// O(1) request check, handles bursts better than fixed window</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Fixed window protects against bursts but may be unfair. Token bucket handles bursts while maintaining average rate.
                        </div>
                    </div>

                    <!-- Problem 2: LRU Cache -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Cache System (LRU)</h3>
                            <div class="card-difficulty difficulty-hard">1800</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">lru-cache, data-structures, optimization</span>
                            <span class="cf-contest">System Design / LeetCode Medium</span>
                        </div>
                        <p><strong>Problem:</strong> Design LRU (Least Recently Used) cache with O(1) get/put. Evict least recently used when full.</p>
                        <p><strong>Constraints:</strong> Cache size up to 10^6 items, concurrent access.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Cache capacity: 3<br>
                            Operations: <code>put(1,A), put(2,B), put(3,C), get(2), get(1), put(4,D)</code><br>
                            Result: <code>put(4,D) evicts A (LRU), C stays (most recent)</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Hash map + doubly linked list. Hash for O(1) lookup. List tracks usage order (move to head on access, tail = LRU).</p>
                        <p><strong>Time:</strong> O(1) get/put | <strong>Space:</strong> O(capacity)</p>
                        <div class="code-snippet">
<pre><code>class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (!this.cache.has(key)) return -1;
    const value = this.cache.get(key);
    // Move to end (most recently used)
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  put(key, value) {
    if (this.cache.has(key)) {
      // Update existing
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // Evict least recently used (first in Map)
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
}

// Using Map maintains insertion order (LRU = first key)
// For explicit doubly linked list:
class Node {
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
}
class LRUCacheDLL {
  // head = MRU, tail = LRU
  // O(1) using map for node lookup
}
// Map-based: O(1), DLL-based: explicit control</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> LRU exploits temporal locality: recently accessed items likely to be accessed again. LFU (Least Frequently Used) for frequency locality.
                        </div>
                    </div>

                    <!-- Problem 3: Consistent Hashing -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Consistent Hashing</h3>
                            <div class="card-difficulty difficulty-hard">1900</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">consistent-hashing, load-balancing, distributed</span>
                            <span class="cf-contest">System Design / Distributed Systems</span>
                        </div>
                        <p><strong>Problem:</strong> Design consistent hash ring for distributed cache. Minimize data movement when nodes added/removed.</p>
                        <p><strong>Constraints:</strong> 1000+ nodes, keys uniformly distributed.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            3 nodes, ring with 3 virtual nodes per physical:<br>
                            <code>Node 1: [0,1,2]</code><br>
                            <code>Node 2: [3,4,5]</code><br>
                            <code>Node 3: [6,7,8]</code><br>
                            Adding Node 4: minimal redistribution
                        </div>
                        <p><strong>Walkthrough:</strong> Hash key to [0, 2^32-1). Map to ring position using modulo. When adding node, only rebalance affected ranges.</p>
                        <p><strong>Time:</strong> O(1) lookup + O(virtualNodes) rebalance on change | <strong>Space:</strong> O(nodes × virtualNodes)</p>
                        <div class="code-snippet">
<pre><code>class ConsistentHash {
  constructor(virtualNodes = 150) {
    this.ring = []; // [{node, keyRanges}]
    this.virtualNodes = virtualNodes;
  }

  addNode(node) {
    // Create virtual nodes
    for (let i = 0; i < this.virtualNodes; i++) {
      const vnode = `${node}_${i}`;
      this.ring.push({node: vnode, hashes: []});
    }
    this.rebalance();
  }

  removeNode(node) {
    // Find and remove all virtual nodes
    this.ring = this.ring.filter(item => !item.node.startsWith(`${node}_`));
    this.rebalance();
  }

  rebalance() {
    // Find load: count keys per range
    const loads = this.ring.map(r => r.hashes.length);
    const avg = loads.reduce((a,b) => a+b) / this.ring.length;

    // Move keys from overloaded to underloaded
    for (let i = 0; i < this.ring.length; i++) {
      if (loads[i] > avg * 1.5) {
        // Redistribute to neighbors
        const target = (i + 1) % this.ring.length;
        const keysToMove = this.ring[i].hashes.slice(0, loads[i] - avg);
        this.ring[target].hashes.push(...keysToMove);
        this.ring[i].hashes = this.ring[i].hashes.slice(keysToMove.length);
      }
    }
  }

  get(key) {
    const hash = this.hash(key);
    const idx = hash % this.ring.length;
    return this.ring[idx].node;
  }

  hash(key) {
    // Simple hash: use cryptographic in production
    let hash = 0;
    for (const c of key) {
      hash = (hash * 31 + c.charCodeAt(0)) >>> 0;
    }
    return hash;
  }
}
// Virtual nodes reduce load imbalance from O(n) to O(n/k)</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Consistent hashing ensures key routes to same node. Virtual nodes provide better load distribution with minimal data movement.
                        </div>
                    </div>

                    <!-- Problem 4: Load Balancer -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Load Balancer</h3>
                            <div class="card-difficulty difficulty-hard">2000</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">load-balancing, algorithms, distributed</span>
                            <span class="cf-contest">System Design / Distributed Systems</span>
                        </div>
                        <p><strong>Problem:</strong> Design load balancer distributing requests across backend servers. Support: round robin, least connections, health checks.</p>
                        <p><strong>Constraints:</strong> 10-100 backend servers, 10^4+ requests/sec.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            3 servers: <code>S1, S2, S3</code><br>
                            Requests: <code>R1→S1, R2→S1, R3→S2, R4→S2, R5→S3, R6→S1, R7→S2</code><br>
                            (Round robin: S1,S2,S3,S1,S2,S3,S1...)
                        </div>
                        <p><strong>Walkthrough:</strong> Round Robin: cycle through servers. Least Connections: track active connections, route to server with fewest. Weighted: assign proportionally.</p>
                        <p><strong>Time:</strong> O(1) routing + O(n) health checks | <strong>Space:</strong> O(servers)</p>
                        <div class="code-snippet">
<pre><code>class LoadBalancer {
  constructor(algorithm = 'round-robin') {
    this.algorithm = algorithm;
    this.servers = [];
    this.currentIndex = 0;
    this.connections = new Map(); // server -> count
  }

  addServer(server) {
    this.servers.push(server);
    this.connections.set(server, 0);
  }

  removeServer(server) {
    this.servers = this.servers.filter(s => s !== server);
    this.connections.delete(server);
  }

  route(request) {
    // Skip unhealthy servers
    const healthy = this.servers.filter(s => s.healthy);
    if (healthy.length === 0) throw new Error('No healthy servers');

    if (this.algorithm === 'round-robin') {
      const server = healthy[this.currentIndex % healthy.length];
      this.currentIndex++;
      return server;
    }

    if (this.algorithm === 'least-connections') {
      let minConn = Infinity, selected;
      for (const server of healthy) {
        const conn = this.connections.get(server) || 0;
        if (conn < minConn) {
          minConn = conn;
          selected = server;
        }
      }
      this.connections.set(selected, minConn + 1);
      return selected;
    }

    if (this.algorithm === 'random') {
      const idx = Math.floor(Math.random() * healthy.length);
      return healthy[idx];
    }
  }

  healthCheck() {
    // Async health checks
    for (const server of this.servers) {
      // Ping endpoint, update server.healthy
      server.healthy = await checkHealth(server.url);
    }
  }
}

// Algorithms: Round Robin (fair), Least Conn (latency-aware),
// Random (avoid hotspots), IP Hash (session affinity)</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Choice depends on use case: RR (stateless), Least Conn (connection pooling), IP Hash (sessions), Weighted (server capacity).
                        </div>
                    </div>

                    <!-- Problem 5: Distributed Lock -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Distributed Lock (Redlock)</h3>
                            <div class="card-difficulty difficulty-hard">2200</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">distributed-lock, redis, coordination</span>
                            <span class="cf-contest">System Design / Distributed Systems</span>
                        </div>
                        <p><strong>Problem:</strong> Design distributed lock across multiple instances. Prevent split-brain, ensure only one client holds lock. Handle failures.</p>
                        <p><strong>Constraints:</strong> 10-100 instances, network latency, clock skew.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            3 instances: <code>I1, I2, I3</code><br>
                            Lock: <code>resource_1</code><br>
                            <code>I1: lock_1, lock_2, lock_3</code> (success: 3/3 > half)<br>
                            <code>I2: lock_2, lock_1, lock_3</code> (success: 2/3, fail)<br>
                        </div>
                        <p><strong>Walkthrough:</strong> Redlock algorithm: lock key in Redis with expiration. Get majority (>N/2). Extend if hold. Release on unlock. Monitor for split-brain.</p>
                        <p><strong>Time:</strong> O(N) lock acquisition + lock TTL for auto-release | <strong>Space:</strong> O(1) lock entry</p>
                        <div class="code-snippet">
<pre><code>class DistributedLock {
  constructor(redis, key, ttl = 30000, retry = 3) {
    this.redis = redis;
    this.key = key;
    this.ttl = ttl; // 30 seconds
    this.retry = retry;
    this.identifier = Math.random().toString(36).substring(7);
  }

  async acquire() {
    for (let attempt = 0; attempt < this.retry; attempt++) {
      const lockKey = `${this.key}:${this.identifier}`;

      // Try to acquire lock
      const acquired = await this.redis.set(lockKey, this.identifier, {
        NX: true, // Only set if not exists
        PX: this.ttl // Expire automatically
      });

      if (acquired === 'OK') {
        // Check if still majority holder
        const owners = await this.getOwners();
        if (this.isMajority(owners)) {
          return true; // Acquired
        }
      }

      // Wait before retry with exponential backoff
      await new Promise(r => setTimeout(r, 50 * Math.pow(2, attempt)));
    }
    return false; // Failed after retries
  }

  async release() {
    const lockKey = `${this.key}:${this.identifier}`;
    await this.redis.del(lockKey);
  }

  async getOwners() {
    // Get all lock identifiers for this key
    const pattern = `${this.key}:*`;
    const keys = await this.redis.keys(pattern);
    const owners = await Promise.all(
      keys.map(k => this.redis.get(k))
    );
    return owners;
  }

  isMajority(owners) {
    const count = {};
    for (const owner of owners) {
      count[owner] = (count[owner] || 0) + 1;
    }
    for (const owner in count) {
      if (count[owner] > owners.length / 2) {
        return owner === this.identifier;
      }
    }
    return false;
  }
}

// Redlock: O(N) acquisition, automatic TTL expiry,
// prevents split-brain with majority check</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Distributed locks need fencing tokens, automatic expiry, and majority voting to handle failures and network partitions.
                        </div>
                    </div>

                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 L4/L5 FAANG Algorithms Guide | System Design problems for educational use</p>
        </div>
    </footer>

    <script src="script.js"></script>
</body>
</html>