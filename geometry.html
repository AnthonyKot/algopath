<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computational Geometry - L4/L5 FAANG Algorithms Guide</title>
    <meta name="description" content="Computational Geometry: convex hulls, line intersections, polygon problems for Codeforces.">
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body>
    <nav id="main-nav">
        <div class="container nav-container">
            <div class="nav-brand">
                <h2><i class="fas fa-code"></i>FAANG Algorithms</h2>
            </div>
            <div class="nav-links">
                <a href="index.html#home"><i class="fas fa-home"></i>Home</a>
                <a href="index.html#algorithms"><i class="fas fa-cubes"></i>Problems</a>
                <a href="dp.html"><i class="fas fa-route"></i>DP</a>
                <a href="graphs.html"><i class="fas fa-project-diagram"></i>Graphs</a>
                <a href="trees.html"><i class="fas fa-sitemap"></i>Trees</a>
                <a href="strings.html"><i class="fas fa-align-left"></i>Strings</a>
                <a href="math.html"><i class="fas fa-calculator"></i>Math</a>
                <a href="#geometry"><i class="fas fa-shapes"></i>Geometry</a>
                <a href="index.html#concepts"><i class="fas fa-lightbulb"></i>Concepts</a>
                <a href="index.html#resources"><i class="fas fa-book"></i>Resources</a>
            </div>
        </div>
    </nav>

    <main>
        <section id="geometry" class="hero category-hero">
            <div class="container">
                <h1>Computational Geometry</h1>
                <p class="hero-text">Convex hulls, line intersections, point relationships, and polygon algorithms. Codeforces rating: 1700-2300+.</p>
                <div class="category-stats">
                    <div class="stat-item"><span class="stat-number">5</span><span class="stat-label">Problems</span></div>
                    <div class="stat-item"><span class="stat-number">O(N log N)</span><span class="stat-label">Avg Time</span></div>
                    <div class="stat-item"><span class="stat-number">1700-2300</span><span class="stat-label">CF Rating</span></div>
                </div>
            </div>
        </section>

        <section class="problems-section">
            <div class="container">
                <h2>Key Geometry Problems</h2>
                <div class="problems-grid">

                    <!-- Problem 1: Point in Polygon -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Point in Polygon Test</h3>
                            <div class="card-difficulty difficulty-hard">1700</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">geometry, polygon, point-in-polygon</span>
                            <span class="cf-contest">Codeforces EDU Geometry / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Given polygon vertices (clockwise or counter-clockwise) and point P, determine if P is inside polygon.</p>
                        <p><strong>Constraints:</strong> Polygon vertices ≤ 10^5, test points ≤ 10^5.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>Polygon: [(0,0),(0,4),(4,4),(4,0)], Point: (2,2)</code><br>
                            Output: <code>Inside: true</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Ray casting: draw horizontal ray from P to infinity. Count intersections with polygon edges. Odd = inside, even = outside. Handle edge cases.</p>
                        <p><strong>Time:</strong> O(N) per query | <strong>Space:</strong> O(1)</p>
                        <div class="code-snippet">
<pre><code>function pointInPolygon(P, polygon) {
  const [px, py] = P;
  let inside = false;

  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const [xi, yi] = polygon[i];
    const [xj, yj] = polygon[j];

    const intersect = ((yi > py) !== (yj > py)) &&
                     (px < (xj - xi) * (py - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

// Cross product for orientation
function crossProduct(o, a, b) {
  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
}
// Ray casting: O(N) intersections</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Ray casting works for simple polygons. For complex (self-intersecting) polygons, use winding number.
                        </div>
                    </div>

                    <!-- Problem 2: Line Segment Intersection -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Line Segment Intersection</h3>
                            <div class="card-difficulty difficulty-hard">1800</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">geometry, line-intersection, orientation</span>
                            <span class="cf-contest">Codeforces EDU Geometry / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Given two line segments (p1,p2) and (p3,p4), determine if they intersect.</p>
                        <p><strong>Constraints:</strong> Coordinates within 32-bit signed integers.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>Segment 1: [(0,0),(2,2)], Segment 2: [(0,2),(2,0)]</code><br>
                            Output: <code>Intersect: true at (1,1)</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Compute orientations of point p relative to segment (p3,p4). Segments intersect if orientations differ and opposite orientations for the endpoints.</p>
                        <p><strong>Time:</strong> O(1) per query | <strong>Space:</strong> O(1)</p>
                        <div class="code-snippet">
<pre><code>function onSegment(p, q, r) {
  // Check if q is on segment pr
  const min_x = Math.min(p[0], r[0]), max_x = Math.max(p[0], r[0]);
  const min_y = Math.min(p[1], r[1]), max_y = Math.max(p[1], r[1]);
  return (q[0] >= min_x && q[0] <= max_x && q[1] >= min_y && q[1] <= max_y);
}

function orientation(p, q, r) {
  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
  if (val > 0) return 1;  // Clockwise
  if (val < 0) return 2;  // Counter-clockwise
  return 0;  // Collinear
}

function segmentsIntersect(p1, p2, p3, p4) {
  const o1 = orientation(p1, p2, p3);
  const o2 = orientation(p1, p2, p4);
  const o3 = orientation(p3, p4, p1);
  const o4 = orientation(p3, p4, p2);

  // General case
  if (o1 !== o2 && o3 !== o4) return true;

  // Special Cases: collinear endpoints
  if (o1 === 0 && onSegment(p1, p3, p2)) return true;
  if (o2 === 0 && onSegment(p1, p4, p2)) return true;
  if (o3 === 0 && onSegment(p3, p1, p4)) return true;
  if (o4 === 0 && onSegment(p3, p2, p4)) return true;

  return false;
}
// O(1) intersection test using orientation</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Orientation (cross product) determines if three points are collinear or form clockwise/counter-clockwise turn.
                        </div>
                    </div>

                    <!-- Problem 3: Convex Hull -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Convex Hull (Monotone Chain)</h3>
                            <div class="card-difficulty difficulty-hard">1900</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">convex-hull, geometry, sorting</span>
                            <span class="cf-contest">Codeforces EDU Geometry / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Given N points, find convex hull (smallest convex polygon containing all points).</p>
                        <p><strong>Constraints:</strong> Points ≤ 2×10^5.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>Points: [(0,0),(0,3),(1,1),(2,2),(3,0),(3,3)]</code><br>
                            Output: <code>Hull: [(0,0),(0,3),(3,3),(3,0)]</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Monotone chain: sort by x (and y for ties). Build lower hull (left-to-right), then upper hull (right-to-left). Remove points that create non-left turns.</p>
                        <p><strong>Time:</strong> O(N log N) | <strong>Space:</strong> O(N)</p>
                        <div class="code-snippet">
<pre><code>function convexHull(points) {
  // Sort by x, then y
  points.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);

  const cross = (o, a, b) => (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);

  const buildHull = (pts) => {
    const hull = [];
    for (const p of pts) {
      while (hull.length >= 2 && cross(hull[hull.length-2], hull[hull.length-1], p) <= 0) {
        hull.pop();
      }
      hull.push(p);
    }
    return hull;
  };

  // Build lower hull
  const lower = buildHull(points);

  // Build upper hull in reverse
  const upper = buildHull([...points].reverse());

  // Concatenate (remove duplicate endpoints)
  const hull = [...lower.slice(0, -1), ...upper.slice(0, -1)];
  return hull;
}
// O(N log N) hull construction</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Monotone chain removes points that create non-left turn (cross product ≤ 0). Graham scan uses polar angle sorting.
                        </div>
                    </div>

                    <!-- Problem 4: Closest Pair of Points -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Closest Pair of Points</h3>
                            <div class="card-difficulty difficulty-hard">2000</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">divide-and-conquer, geometry, closest-pair</span>
                            <span class="cf-contest">Codeforces EDU Geometry / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Given N points, find minimum Euclidean distance between any two points.</p>
                        <p><strong>Constraints:</strong> Points ≤ 10^5.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>Points: [(2,3),(12,30),(40,50),(5,1),(12,10),(3,4)]</code><br>
                            Output: <code>Closest pair: (2,3) and (3,4), distance: 1.414</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Divide and conquer: sort by x. Recursively split by median. Merge: check closest in halves and cross-border (strip) with O(N) points.</p>
                        <p><strong>Time:</strong> O(N log N) | <strong>Space:</strong> O(N)</p>
                        <div class="code-snippet">
<pre><code>function dist(p1, p2) {
  return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2;
}

function closestPair(points) {
  const n = points.length;
  if (n <= 3) return bruteForce(points);

  // Sort by x-coordinate
  points.sort((a, b) => a[0] - b[0]);

  const mid = Math.floor(n / 2);
  const midX = points[mid][0];

  // Divide
  const left = points.slice(0, mid);
  const right = points.slice(mid);

  // Conquer
  const [dl, pl] = closestPair(left);
  const [dr, pr] = closestPair(right);
  const d = Math.min(dl, dr);

  // Combine: check strip near midX
  const strip = points.filter(p => Math.abs(p[0] - midX) < d);
  strip.sort((a, b) => a[1] - b[1]);

  // Check up to 7 closest in strip
  for (let i = 0; i < strip.length; i++) {
    for (let j = i + 1; j < Math.min(i + 7, strip.length); j++) {
      if (dist(strip[i], strip[j]) < d) {
        d = dist(strip[i], strip[j]);
        pl = [strip[i], strip[j]];
      }
    }
  }

  return d < dl ? [d, [pl[0], pl[1]]] : [dl, pl];
}

// O(N log N) with strip optimization (at most 7 points to check)</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Strip contains O(N) points but only O(1) points are within distance d of midline (geometric fact).
                        </div>
                    </div>

                    <!-- Problem 5: Rotating Calipers -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Rotating Calipers (Diameter)</h3>
                            <div class="card-difficulty difficulty-hard">2300</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">rotating-calipers, convex-hull, geometry</span>
                            <span class="cf-contest">Codeforces EDU Geometry / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Given convex polygon, find diameter (maximum distance between any two points).</p>
                        <p><strong>Constraints:</strong> Polygon vertices ≤ 10^5.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>Convex hull: [(0,0),(0,5),(5,5),(5,0)]</code><br>
                            Output: <code>Diameter: √50 ≈ 7.071 (between (0,0) and (5,5))</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Use rotating calipers on convex hull. Two antipodal points with parallel supporting lines maximize distance. Rotate one point at a time.</p>
                        <p><strong>Time:</strong> O(N) on convex hull | <strong>Space:</strong> O(1)</p>
                        <div class="code-snippet">
<pre><code>function rotatingCalipers(hull) {
  const n = hull.length;
  if (n === 2) return Math.sqrt(dist(hull[0], hull[1]));

  // Initialize: p0 = hull[0], p1 = hull[1]
  let p0 = 0, p1 = 1, maxDist = dist(hull[0], hull[1]);

  // Initialize antipodal: q0 = hull[1], q1 = hull[2]
  let q0 = 1, q1 = 2;

  // Rotate all points
  for (let i = 0; i < n; i++) {
    // Check edge (p0, p1) with antipodal q1
    const d1 = dist(hull[p0], hull[q1]);
    if (d1 > maxDist) {
      maxDist = d1;
    }

    // Check edge (q0, q1) with antipodal p1
    const d2 = dist(hull[p1], hull[q0]);
    if (d2 > maxDist) {
      maxDist = d2;
    }

    // Rotate: move p1, q1, q0 clockwise
    p1 = (p1 + 1) % n;
    q1 = (q1 + 1) % n;
    q0 = (q0 + 1) % n;
  }

  return Math.sqrt(maxDist);
}

function dist(a, b) {
  return (a[0]-b[0])**2 + (a[1]-b[1])**2;
}
// O(N) diameter on convex hull</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Rotating calipers exploit convex hull property: antipodal pairs can be found by rotating around hull in O(N).
                        </div>
                    </div>

                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 L4/L5 FAANG Algorithms Guide | Codeforces problems for educational use</p>
        </div>
    </footer>

    <script src="script.js"></script>
</body>
</html>