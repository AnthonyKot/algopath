<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String Algorithms - L4/L5 FAANG Algorithms Guide</title>
    <meta name="description" content="Advanced String algorithms: KMP, Rabin-Karp, suffix arrays, Z-algorithm for Codeforces problems.">
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body>
    <nav id="main-nav">
        <div class="container nav-container">
            <div class="nav-brand">
                <h2><i class="fas fa-code"></i>FAANG Algorithms</h2>
            </div>
            <div class="nav-links">
                <a href="index.html#home"><i class="fas fa-home"></i>Home</a>
                <a href="index.html#algorithms"><i class="fas fa-cubes"></i>Problems</a>
                <a href="dp.html"><i class="fas fa-route"></i>DP</a>
                <a href="graphs.html"><i class="fas fa-project-diagram"></i>Graphs</a>
                <a href="trees.html"><i class="fas fa-sitemap"></i>Trees</a>
                <a href="#strings"><i class="fas fa-align-left"></i>Strings</a>
                <a href="math.html"><i class="fas fa-calculator"></i>Math</a>
                <a href="geometry.html"><i class="fas fa-shapes"></i>Geometry</a>
                <a href="index.html#concepts"><i class="fas fa-lightbulb"></i>Concepts</a>
                <a href="index.html#resources"><i class="fas fa-book"></i>Resources</a>
            </div>
        </div>
    </nav>

    <main>
        <section id="strings" class="hero category-hero">
            <div class="container">
                <h1>Advanced String Algorithms</h1>
                <p class="hero-text">Pattern matching, suffix structures, and advanced string processing. Codeforces rating: 1700-2400+.</p>
                <div class="category-stats">
                    <div class="stat-item"><span class="stat-number">5</span><span class="stat-label">Problems</span></div>
                    <div class="stat-item"><span class="stat-number">O(N)</span><span class="stat-label">Avg Time</span></div>
                    <div class="stat-item"><span class="stat-number">1700-2400</span><span class="stat-label">CF Rating</span></div>
                </div>
            </div>
        </section>

        <section class="problems-section">
            <div class="container">
                <h2>Key String Problems</h2>
                <div class="problems-grid">

                    <!-- Problem 1: KMP Pattern Matching -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>KMP Pattern Matching</h3>
                            <div class="card-difficulty difficulty-hard">1700</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">kmp, strings, pattern-matching</span>
                            <span class="cf-contest">Codeforces EDU String Algorithms / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Find all occurrences of pattern in text using KMP algorithm.</p>
                        <p><strong>Constraints:</strong> Text length ≤ 10^5, pattern length ≤ 10^5.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>text = "ababcabcabcabcab", pattern = "abcab"</code><br>
                            Output: <code>Positions: 2, 7, 10</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Build LPS (Longest Proper Prefix which is also Suffix) array for pattern. Then scan text, using LPS to skip backtracking when mismatches occur.</p>
                        <p><strong>Time:</strong> O(N+M) | <strong>Space:</strong> O(M)</p>
                        <div class="code-snippet">
<pre><code>function buildLPS(pattern) {
  const m = pattern.length;
  const lps = new Array(m).fill(0);
  let len = 0;
  for (let i = 1; i < m; i++) {
    while (len > 0 && pattern[i] !== pattern[len]) len = lps[len - 1];
    if (pattern[i] === pattern[len]) len++;
    lps[i] = len;
  }
  return lps;
}

function kmpSearch(text, pattern) {
  const n = text.length, m = pattern.length;
  const lps = buildLPS(pattern);
  const result = [];

  let i = 0, j = 0;
  while (i < n) {
    if (pattern[j] === text[i]) {
      i++; j++;
    }
    if (j === m) {
      result.push(i - j); // Pattern found at i-j
      j = lps[j - 1];
    } else if (i < n && pattern[j] !== text[i]) {
      if (j !== 0) j = lps[j - 1];
      else i++;
    }
  }
  return result;
}
// O(N+M) where N=text length, M=pattern length</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> KMP's LPS array precomputes pattern structure to avoid re-comparing characters.
                        </div>
                    </div>

                    <!-- Problem 2: Rabin-Karp Rolling Hash -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Rabin-Karp Rolling Hash</h3>
                            <div class="card-difficulty difficulty-hard">1800</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">hashing, strings, pattern-matching</span>
                            <span class="cf-contest">Codeforces EDU Hashing / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Find all occurrences of pattern in text using rolling hash. Handle collisions.</p>
                        <p><strong>Constraints:</strong> Text length ≤ 10^6, pattern length ≤ 10^6.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>text = "abababab", pattern = "ab"</code><br>
                            Output: <code>Positions: 0, 2, 4</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Compute hash of pattern. Compute rolling hash of text substrings. When hashes match, verify actual strings (handle collisions).</p>
                        <p><strong>Time:</strong> O(N+M) expected, O(N×M) worst with collisions | <strong>Space:</strong> O(M)</p>
                        <div class="code-snippet">
<pre><code>function rabinKarp(text, pattern, base=256, mod=10**9+7) {
  const n = text.length, m = pattern.length;
  if (m > n) return [];

  // Compute hash of pattern and first m chars of text
  let hashPattern = 0, hashText = 0;
  let h = 1; // base^(m-1) % mod

  for (let i = 0; i < m; i++) {
    hashPattern = (hashPattern * base + pattern.charCodeAt(i)) % mod;
    hashText = (hashText * base + text.charCodeAt(i)) % mod;
    if (i < m - 1) h = (h * base) % mod;
  }

  const result = [];
  for (let i = 0; i <= n - m; i++) {
    if (hashPattern === hashText) {
      // Verify actual strings (collision check)
      if (text.slice(i, i+m) === pattern) result.push(i);
    }
    // Roll hash: remove text[i], add text[i+m]
    if (i < n - m) {
      hashText = ((hashText - text.charCodeAt(i) * h) * base + text.charCodeAt(i+m)) % mod;
      if (hashText < 0) hashText += mod;
    }
  }
  return result;
}
// Rolling hash enables O(1) hash update for sliding window</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Rolling hash enables O(1) hash computation for adjacent substrings. Use double hashing to reduce collision probability.
                        </div>
                    </div>

                    <!-- Problem 3: Z-Algorithm -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Z-Algorithm for Pattern Finding</h3>
                            <div class="card-difficulty difficulty-hard">1900</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">z-algorithm, strings, prefix-function</span>
                            <span class="cf-contest">Codeforces EDU String Algorithms / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Find all occurrences of pattern in text using Z-algorithm (concatenate pattern + '$' + text).</p>
                        <p><strong>Constraints:</strong> Text length ≤ 10^5, pattern length ≤ 10^5.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>pattern = "abc", text = "abcabcabcab"</code><br>
                            Output: <code>Occurrences at positions: 0, 3</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Construct string s = pattern + special_char + text. Compute Z-array where Z[i] = longest substring starting at i matching prefix of s.</p>
                        <p><strong>Time:</strong> O(N+M) | <strong>Space:</strong> O(N+M)</p>
                        <div class="code-snippet">
<pre><code>function computeZ(s) {
  const n = s.length;
  const Z = new Array(n).fill(0);
  Z[0] = 0;

  let l = 0, r = 0;
  for (let i = 1; i < n; i++) {
    if (i <= r) {
      Z[i] = Math.min(r - i + 1, Z[i - l]);
    }
    while (i + Z[i] < n && s[Z[i]] === s[i + Z[i]]) {
      Z[i]++;
    }
    if (i + Z[i] - 1 > r) {
      l = i;
      r = i + Z[i] - 1;
    }
  }
  return Z;
}

function zSearch(pattern, text, special = '$') {
  const combined = pattern + special + text;
  const Z = computeZ(combined);
  const m = pattern.length;
  const result = [];

  for (let i = m + 1; i < combined.length; i++) {
    if (Z[i] === m) {
      result.push(i - m - 1); // Position in original text
    }
  }
  return result;
}
// Z-array computes prefix matches in O(N) using Z-box</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Z-algorithm computes all prefix matches in linear time, enabling efficient pattern search without preprocessing pattern.
                        </div>
                    </div>

                    <!-- Problem 4: Suffix Array -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Suffix Array Construction</h3>
                            <div class="card-difficulty difficulty-hard">2000</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">suffix-array, strings, sorting</span>
                            <span class="cf-contest">Codeforces EDU Suffix Structures / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Build suffix array of string. Suffix array = array of suffix starting indices sorted lexicographically.</p>
                        <p><strong>Constraints:</strong> String length ≤ 10^5.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>s = "banana"</code><br>
                            Output: <code>SA = [5, 3, 1, 0, 4, 2]</code><br>
                            <code>Suffixes: ["a", "ana", "anana", "banana", "na", "nana"]</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Build SA using doubling: sort by first 1, 2, 4, 8, ... characters. Rank suffixes by their prefixes of increasing lengths.</p>
                        <p><strong>Time:</strong> O(N log N) | <strong>Space:</strong> O(N)</p>
                        <div class="code-snippet">
<pre><code>function buildSuffixArray(s) {
  const n = s.length;
  const sa = Array.from({length: n}, (_, i) => i);
  const rank = s.split('').map(c => c.charCodeAt(0));
  const tmp = new Array(n).fill(0);

  for (let k = 1; k < n; k *= 2) {
    // Sort by rank[sa[i]+k], rank[sa[i]]
    sa.sort((a, b) => {
      const ra = rank[a], rb = rank[b];
      if (ra === rb) {
        const rak = rank[a+k] || -1, rbk = rank[b+k] || -1;
        return rak - rbk;
      }
      return ra - rb;
    });

    // Update ranks
    tmp[sa[0]] = 0;
    for (let i = 1; i < n; i++) {
      const prev = sa[i-1], curr = sa[i];
      const prevRank = rank[prev] + ',' + (rank[prev+k] || -1);
      const currRank = rank[curr] + ',' + (rank[curr+k] || -1);
      tmp[curr] = tmp[prev] + (prevRank < currRank ? 1 : 0);
    }
    [rank, tmp] = [tmp, rank];
  }
  return sa;
}

function suffixArray(s) {
  return buildSuffixArray(s).map(i => s.slice(i));
}
// Doubling technique: sort by prefixes of length 1, 2, 4, 8, ...</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> SA + LCP (Longest Common Prefix) array enables O(1) substring comparisons and efficient string operations.
                        </div>
                    </div>

                    <!-- Problem 5: Manacher's Algorithm -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Manacher's (Longest Palindrome)</h3>
                            <div class="card-difficulty difficulty-hard">2200</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">manacher, palindrome, strings</span>
                            <span class="cf-contest">Codeforces EDU String Algorithms / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Find longest palindromic substring in O(N) time using Manacher's algorithm.</p>
                        <p><strong>Constraints:</strong> String length ≤ 10^6.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>s = "babad"</code><br>
                            Output: <code>"bab" or "aba"</code><br>
                            <code>Length: 3</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Insert '#' between chars and at boundaries to unify odd/even palindromes. Expand around centers using previously computed radii to achieve O(N).</p>
                        <p><strong>Time:</strong> O(N) | <strong>Space:</strong> O(N)</p>
                        <div class="code-snippet">
<pre><code>function manacher(s) {
  // Transform: "abc" -> "#a#b#c#"
  const t = '#' + s.split('').join('#') + '#';
  const n = t.length;
  const P = new Array(n).fill(0); // Radii

  let C = 0, R = 0; // Center and right boundary
  for (let i = 1; i < n - 1; i++) {
    const mirror = 2*C - i; // Mirror of i around C

    if (i < R) {
      P[i] = Math.min(R - i, P[mirror]);
    }

    // Attempt to expand
    while (i + 1 + P[i] < n && i - 1 - P[i] >= 0 &&
           t[i + 1 + P[i]] === t[i - 1 - P[i]]) {
      P[i]++;
    }

    // Update center and right boundary
    if (i + P[i] > R) {
      C = i;
      R = i + P[i];
    }
  }

  // Find max radius and center
  let maxLen = 0, centerIndex = 0;
  for (let i = 1; i < n - 1; i++) {
    if (P[i] > maxLen) {
      maxLen = P[i];
      centerIndex = i;
    }
  }

  // Extract palindrome from original string
  const start = Math.floor((centerIndex - 1 - maxLen) / 2);
  return s.slice(start, start + maxLen);
}
// O(N) algorithm for longest palindromic substring</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Manacher's algorithm uses symmetry and previously computed values to avoid redundant checks, achieving linear time.
                        </div>
                    </div>

                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 L4/L5 FAANG Algorithms Guide | Codeforces problems for educational use</p>
        </div>
    </footer>

    <script src="script.js"></script>
</body>
</html>