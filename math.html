<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number Theory - L4/L5 FAANG Algorithms Guide</title>
    <meta name="description" content="Advanced Number Theory: modular arithmetic, FFT, binary exponentiation, combinatorial problems.">
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body>
    <nav id="main-nav">
        <div class="container nav-container">
            <div class="nav-brand">
                <h2><i class="fas fa-code"></i>FAANG Algorithms</h2>
            </div>
            <div class="nav-links">
                <a href="index.html#home"><i class="fas fa-home"></i>Home</a>
                <a href="index.html#algorithms"><i class="fas fa-cubes"></i>Problems</a>
                <a href="dp.html"><i class="fas fa-route"></i>DP</a>
                <a href="graphs.html"><i class="fas fa-project-diagram"></i>Graphs</a>
                <a href="trees.html"><i class="fas fa-sitemap"></i>Trees</a>
                <a href="strings.html"><i class="fas fa-align-left"></i>Strings</a>
                <a href="#math"><i class="fas fa-calculator"></i>Math</a>
                <a href="geometry.html"><i class="fas fa-shapes"></i>Geometry</a>
                <a href="index.html#concepts"><i class="fas fa-lightbulb"></i>Concepts</a>
                <a href="index.html#resources"><i class="fas fa-book"></i>Resources</a>
            </div>
        </div>
    </nav>

    <main>
        <section id="math" class="hero category-hero">
            <div class="container">
                <h1>Number Theory & Combinatorics</h1>
                <p class="hero-text">Modular arithmetic, FFT, binary exponentiation, primes, and advanced combinatorics. Codeforces rating: 1700-2400+.</p>
                <div class="category-stats">
                    <div class="stat-item"><span class="stat-number">5</span><span class="stat-label">Problems</span></div>
                    <div class="stat-item"><span class="stat-number">O(log N)</span><span class="stat-label">Avg Time</span></div>
                    <div class="stat-item"><span class="stat-number">1700-2400</span><span class="stat-label">CF Rating</span></div>
                </div>
            </div>
        </section>

        <section class="problems-section">
            <div class="container">
                <h2>Key Math Problems</h2>
                <div class="problems-grid">

                    <!-- Problem 1: Modular Exponentiation -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Modular Exponentiation</h3>
                            <div class="card-difficulty difficulty-hard">1700</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">modular, exponentiation, fast-power</span>
                            <span class="cf-contest">Codeforces EDU Math / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Compute a^b mod m efficiently where a, b, m up to 10^18.</p>
                        <p><strong>Constraints:</strong> a, b, m ≤ 10^18.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>a=2, b=10^18, m=10^9+7</code><br>
                            Output: <code>2^(10^18) mod (10^9+7)</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Binary exponentiation: a^b = product of a^(2^k) where b's binary bits are set. Mod at each step to avoid overflow.</p>
                        <p><strong>Time:</strong> O(log b) | <strong>Space:</strong> O(1)</p>
                        <div class="code-snippet">
<pre><code>function modPow(a, b, mod) {
  let result = 1;
  a = a % mod;

  while (b > 0) {
    if (b % 2 === 1) {
      result = (result * a) % mod;
    }
    a = (a * a) % mod;
    b = Math.floor(b / 2);
  }
  return result;
}

// Extended: a^b mod m where b can be negative
function modPowExtended(a, b, mod) {
  let result = 1;
  a = a % mod;

  for (let i = 0; i < 32; i++) {
    if ((b >> i) & 1) {
      result = (result * a) % mod;
    }
    a = (a * a) % mod;
  }
  return result;
}
// O(log b) instead of O(b)</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Precompute a^(2^k) mod m for k=0,1,2,...,log b to enable fast exponentiation.
                        </div>
                    </div>

                    <!-- Problem 2: Sieve of Eratosthenes -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Sieve of Eratosthenes</h3>
                            <div class="card-difficulty difficulty-hard">1800</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">sieve, primes, factorization</span>
                            <span class="cf-contest">Codeforces EDU Math / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Generate all primes up to N and answer prime queries.</p>
                        <p><strong>Constraints:</strong> N ≤ 10^7, Q queries up to 10^5.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>N=30</code><br>
                            Output: <code>Primes: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Initialize sieve array. Mark multiples of each prime starting from prime^2. Remaining unmarked numbers are prime.</p>
                        <p><strong>Time:</strong> O(N log log N) | <strong>Space:</strong> O(N)</p>
                        <div class="code-snippet">
<pre><code>function sieve(N) {
  const isPrime = new Array(N + 1).fill(true);
  isPrime[0] = isPrime[1] = false;

  for (let p = 2; p * p <= N; p++) {
    if (isPrime[p]) {
      // Mark all multiples of p
      for (let multiple = p * p; multiple <= N; multiple += p) {
        isPrime[multiple] = false;
      }
    }
  }

  const primes = [];
  for (let i = 2; i <= N; i++) {
    if (isPrime[i]) primes.push(i);
  }
  return primes;
}

function sieveWithPrimeCount(N, Q, queries) {
  const isPrime = new Array(N + 1).fill(true);
  const primeCount = new Array(N + 1).fill(0);
  isPrime[0] = isPrime[1] = false;
  let cnt = 0;

  for (let i = 2; i <= N; i++) {
    if (isPrime[i]) {
      cnt++;
      for (let j = i * 2; j <= N; j += i) {
        isPrime[j] = false;
      }
    }
    primeCount[i] = cnt;
  }

  return queries.map(q => primeCount[q]);
}
// O(N log log N) sieve + O(1) queries</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Sieve marks composites in O(N log log N). Can also compute smallest prime factor (SPF) for factorization.
                        </div>
                    </div>

                    <!-- Problem 3: Extended Euclidean Algorithm -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Extended Euclidean Algorithm</h3>
                            <div class="card-difficulty difficulty-hard">1900</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">gcd, modular-inverse, number-theory</span>
                            <span class="cf-contest">Codeforces EDU Math / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Find integers x, y such that ax + by = gcd(a,b). Compute modular inverse when gcd=1.</p>
                        <p><strong>Constraints:</strong> a, b ≤ 10^18.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>a=35, b=15</code><br>
                            Output: <code>gcd=5, x=-1, y=3 (since -1*35 + 3*15 = 10)</code><br>
                            <code>Modular inverse: 3^-1 mod 35 = 12 (since 3*12 = 36 ≡ 1 mod 35)</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Extended Euclid finds coefficients x,y along with gcd. Modular inverse exists when gcd(a,m)=1, and x mod m is the inverse.</p>
                        <p><strong>Time:</strong> O(log max(a,b)) | <strong>Space:</strong> O(1)</p>
                        <div class="code-snippet">
<pre><code>function extendedGCD(a, b) {
  if (b === 0) {
    return [a, 1, 0]; // [gcd, x, y]
  }
  const [g, x1, y1] = extendedGCD(b, a % b);
  return [g, y1, x1 - Math.floor(a / b) * y1];
}

function modInverse(a, mod) {
  const [g, x, y] = extendedGCD(a, mod);
  if (g !== 1) {
    return -1; // No inverse exists
  }
  return ((x % mod) + mod) % mod;
}

// Example: Solve linear diophantine: 35x + 15y = 10
const [gcd, x, y] = extendedGCD(35, 15);
// gcd=5, x=-1, y=3
// Particular solution: x0 = 10/g * x = -2, y0 = 10/g * y = 6
// General: x = x0 + (15/5)*t, y = y0 - (35/5)*t for any t</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> Extended Euclid enables solving ax ≡ b (mod m) and linear Diophantine equations.
                        </div>
                    </div>

                    <!-- Problem 4: Chinese Remainder Theorem -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Chinese Remainder Theorem</h3>
                            <div class="card-difficulty difficulty-hard">2000</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">crt, modular, number-theory</span>
                            <span class="cf-contest">Codeforces EDU Math / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Find x such that x ≡ a1 (mod m1), x ≡ a2 (mod m2), ..., x ≡ ak (mod mk) where all m[i] are coprime.</p>
                        <p><strong>Constraints:</strong> k ≤ 10, m[i] ≤ 10^9.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>x ≡ 2 (mod 3), x ≡ 3 (mod 5), x ≡ 2 (mod 7)</code><br>
                            Output: <code>x = 23</code><br>
                            <code>Verify: 23 mod 3 = 2, 23 mod 5 = 3, 23 mod 7 = 2</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Merge equations pairwise. For two equations x ≡ a1 (mod m1), x ≡ a2 (mod m2), solution is x ≡ x0 (mod lcm(m1,m2)).</p>
                        <p><strong>Time:</strong> O(k log M) | <strong>Space:</strong> O(k)</p>
                        <div class="code-snippet">
<pre><code>function solveCRT(a, m) {
  // Merge two equations: x ≡ a1 (mod m1), x ≡ a2 (mod m2)
  function merge(a1, m1, a2, m2) {
    const [g, p, q] = extendedGCD(m1, m2);
    if ((a2 - a1) % g !== 0) {
      return [-1, 0]; // No solution
    }
    const lcm = (m1 / g) * m2;
    const x = (a1 + ((a2 - a1) / g * p % (m2 / g)) * m1) % lcm;
    return [(x % lcm + lcm) % lcm, lcm];
  }

  let [ans, mod] = [a[0], m[0]];
  for (let i = 1; i < a.length; i++) {
    [ans, mod] = merge(ans, mod, a[i], m[i]);
    if (ans === -1) return [-1, 0]; // No solution
  }
  return ans;
}

// Example: Solve x ≡ 2 (mod 3), x ≡ 3 (mod 5), x ≡ 2 (mod 7)
const x = solveCRT([2, 3, 2], [3, 5, 7]);
// x = 23
// Verify: 23 mod 3 = 2, 23 mod 5 = 3, 23 mod 7 = 2</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> CRT has unique solution modulo lcm of all m[i] when coprime. General CRT handles non-coprime cases.
                        </div>
                    </div>

                    <!-- Problem 5: Fast Fourier Transform (FFT) -->
                    <div class="problem-card">
                        <div class="card-header">
                            <h3>Fast Fourier Transform (FFT)</h3>
                            <div class="card-difficulty difficulty-hard">2300</div>
                        </div>
                        <div class="cf-meta">
                            <span class="cf-tags">fft, polynomial-multiplication, number-theory</span>
                            <span class="cf-contest">Codeforces EDU Convolution / CF Representative</span>
                        </div>
                        <p><strong>Problem:</strong> Multiply two polynomials efficiently using FFT. Given arrays A and B, compute C where C[k] = Σ A[i]*B[k-i].</p>
                        <p><strong>Constraints:</strong> Polynomial degrees ≤ 10^5.</p>
                        <div class="sample-io">
                            <strong>Sample:</strong><br>
                            Input: <code>A = [1,2,3] (1+2x+3x²), B = [4,5,6] (4+5x+6x²)</code><br>
                            Output: <code>C = [4, 13, 28, 27, 18]</code><br>
                            <code>(1+2x+3x²) * (4+5x+6x²) = 4+13x+28x²+27x³+18x⁴</code>
                        </div>
                        <p><strong>Walkthrough:</strong> Cooley-Tukey FFT uses divide-and-conquer: split even/odd coefficients, recurse, combine. Inverse FFT converts back to coefficients.</p>
                        <p><strong>Time:</strong> O(N log N) | <strong>Space:</strong> O(N)</p>
                        <div class="code-snippet">
<pre><code>function fft(a, invert = false) {
  const n = a.length;
  const rev = new Array(n).fill(0);
  const bits = Math.log2(n);

  // Bit-reversal permutation
  for (let i = 0; i < n; i++) {
    rev[i] = (rev[i >> 1] >> 1) | (i & 1) << (bits - 1);
  }
  for (let i = 0; i < n; i++) {
    if (i < rev[i]) [a[i], a[rev[i]] = [a[rev[i]], a[i]];
  }

  // Cooley-Tukey FFT
  for (let len = 2; len <= n; len *= 2) {
    const ang = 2 * Math.PI / len * (invert ? -1 : 1);
    const wlen = [Math.cos(ang), Math.sin(ang)];
    for (let i = 0; i < n; i += len) {
      let u = [1, 0];
      for (let j = 0; j < len/2; j++) {
        const v = [a[i+j+len/2][0] * wlen[0] - a[i+j+len/2][1] * wlen[1],
                 a[i+j+len/2][0] * wlen[1] + a[i+j+len/2][1] * wlen[0]];
        [a[i+j], a[i+j+len/2]] = [[u[0] + v[0], u[1] + v[1]],
                                         [u[0] - v[0], u[1] - v[1]]];
        u = [u[0] * wlen[0] - u[1] * wlen[1],
              u[0] * wlen[1] + u[1] * wlen[0]];
      }
    }
  }

  if (invert) {
    for (let i = 0; i < n; i++) {
      a[i] = [a[i][0] / n, a[i][1] / n];
    }
  }
  return a;
}

function multiplyPolynomials(A, B) {
  const n = 1;
  while (n < A.length + B.length) n *= 2;

  // Pad with zeros
  const a = A.map(x => [x, 0]).concat(new Array(n - A.length).fill([0, 0]));
  const b = B.map(x => [x, 0]).concat(new Array(n - B.length).fill([0, 0]));

  // FFT both
  const fa = fft(a), fb = fft(b);

  // Point-wise multiplication
  const fc = fa.map((x, i) => [x[0] * fb[i][0] - x[1] * fb[i][1],
                                      x[0] * fb[i][1] + x[1] * fb[i][0]]);

  // Inverse FFT
  const C = fft(fc, true);

  // Round to integers
  return C.map(x => Math.round(x[0])).slice(0, A.length + B.length - 1);
}
// O(N log N) polynomial multiplication</code></pre>
                        </div>
                        <div class="insights">
                            <strong>Key Insight:</strong> FFT enables convolution in O(N log N). Used for polynomial multiplication, signal processing, and string matching with FFT.
                        </div>
                    </div>

                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 L4/L5 FAANG Algorithms Guide | Codeforces problems for educational use</p>
        </div>
    </footer>

    <script src="script.js"></script>
</body>
</html>